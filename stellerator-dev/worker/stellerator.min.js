(function () {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var Event_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var factories = [];
	factories[0] = function () {
	    return function dispatcher0() { };
	};
	factories[1] = function (callback, context) {
	    if (typeof (context) === 'undefined')
	        return callback;
	    return function dispatcher1(payload) {
	        callback(payload, context);
	    };
	};
	function getFactory(handlerCount) {
	    if (!factories[handlerCount])
	        factories[handlerCount] = compileFactory(handlerCount);
	    return factories[handlerCount];
	}
	function compileFactory(handlerCount) {
	    var src = 'return function dispatcher' + handlerCount + '(payload) {\n';
	    var argsHandlers = [], argsContexts = [];
	    for (var i = 0; i < handlerCount; i++) {
	        argsHandlers.push('cb' + i);
	        argsContexts.push('ctx' + i);
	        src += '    cb' + i + '(payload, ctx' + i + ');\n';
	    }
	    src += '};';
	    return new (Function.bind.apply(Function, [void 0].concat(argsHandlers.concat(argsContexts), [src])))();
	}
	var Event = /** @class */ (function () {
	    function Event() {
	        this.hasHandlers = false;
	        this._handlers = [];
	        this._contexts = [];
	        this._createDispatcher();
	    }
	    Event.prototype.addHandler = function (handler, context) {
	        if (!this.isHandlerAttached(handler, context)) {
	            this._handlers.push(handler);
	            this._contexts.push(context);
	            this._createDispatcher();
	            this._updateHasHandlers();
	        }
	        return this;
	    };
	    Event.prototype.removeHandler = function (handler, context) {
	        var idx = this._getHandlerIndex(handler, context);
	        if (typeof (idx) !== 'undefined') {
	            this._handlers.splice(idx, 1);
	            this._contexts.splice(idx, 1);
	            this._createDispatcher();
	            this._updateHasHandlers();
	        }
	        return this;
	    };
	    Event.prototype.isHandlerAttached = function (handler, context) {
	        return typeof (this._getHandlerIndex(handler, context)) !== 'undefined';
	    };
	    Event.prototype._updateHasHandlers = function () {
	        this.hasHandlers = !!this._handlers.length;
	    };
	    Event.prototype._getHandlerIndex = function (handler, context) {
	        var handlerCount = this._handlers.length;
	        var idx;
	        for (idx = 0; idx < handlerCount; idx++) {
	            if (this._handlers[idx] === handler && this._contexts[idx] === context)
	                break;
	        }
	        return idx < handlerCount ? idx : undefined;
	    };
	    Event.prototype._createDispatcher = function () {
	        this.dispatch = getFactory(this._handlers.length).apply(this, this._handlers.concat(this._contexts));
	    };
	    return Event;
	}());
	exports.default = Event;
	});

	unwrapExports(Event_1);

	var lib = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.Event = Event_1.default;
	});

	unwrapExports(lib);
	var lib_1 = lib.Event;

	var RpcProvider_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	var MSG_RESOLVE_TRANSACTION = "resolve_transaction", MSG_REJECT_TRANSACTION = "reject_transaction", MSG_ERROR = "error";
	var RpcProvider = /** @class */ (function () {
	    function RpcProvider(_dispatch, _rpcTimeout) {
	        if (_rpcTimeout === void 0) { _rpcTimeout = 0; }
	        this._dispatch = _dispatch;
	        this._rpcTimeout = _rpcTimeout;
	        this.error = new lib.Event();
	        this._rpcHandlers = {};
	        this._signalHandlers = {};
	        this._pendingTransactions = {};
	        this._nextTransactionId = 0;
	    }
	    RpcProvider.prototype.dispatch = function (payload) {
	        var message = payload;
	        switch (message.type) {
	            case RpcProvider.MessageType.signal:
	                return this._handleSignal(message);
	            case RpcProvider.MessageType.rpc:
	                return this._handeRpc(message);
	            case RpcProvider.MessageType.internal:
	                return this._handleInternal(message);
	            default:
	                this._raiseError("invalid message type " + message.type);
	        }
	    };
	    RpcProvider.prototype.rpc = function (id, payload, transfer) {
	        var _this = this;
	        var transactionId = this._nextTransactionId++;
	        this._dispatch({
	            type: RpcProvider.MessageType.rpc,
	            transactionId: transactionId,
	            id: id,
	            payload: payload
	        }, transfer ? transfer : undefined);
	        return new Promise(function (resolve, reject) {
	            var transaction = _this._pendingTransactions[transactionId] = {
	                id: transactionId,
	                resolve: resolve,
	                reject: reject
	            };
	            if (_this._rpcTimeout > 0) {
	                _this._pendingTransactions[transactionId].timeoutHandle =
	                    setTimeout(function () { return _this._transactionTimeout(transaction); }, _this._rpcTimeout);
	            }
	        });
	    };
	    RpcProvider.prototype.signal = function (id, payload, transfer) {
	        this._dispatch({
	            type: RpcProvider.MessageType.signal,
	            id: id,
	            payload: payload,
	        }, transfer ? transfer : undefined);
	        return this;
	    };
	    RpcProvider.prototype.registerRpcHandler = function (id, handler) {
	        if (this._rpcHandlers[id]) {
	            throw new Error("rpc handler for " + id + " already registered");
	        }
	        this._rpcHandlers[id] = handler;
	        return this;
	    };
	    RpcProvider.prototype.registerSignalHandler = function (id, handler) {
	        if (!this._signalHandlers[id]) {
	            this._signalHandlers[id] = [];
	        }
	        this._signalHandlers[id].push(handler);
	        return this;
	    };
	    RpcProvider.prototype.deregisterRpcHandler = function (id, handler) {
	        if (this._rpcHandlers[id]) {
	            delete this._rpcHandlers[id];
	        }
	        return this;
	    };
	    RpcProvider.prototype.deregisterSignalHandler = function (id, handler) {
	        if (this._signalHandlers[id]) {
	            this._signalHandlers[id] = this._signalHandlers[id].filter(function (h) { return handler !== h; });
	        }
	        return this;
	    };
	    RpcProvider.prototype._raiseError = function (error) {
	        this.error.dispatch(new Error(error));
	        this._dispatch({
	            type: RpcProvider.MessageType.internal,
	            id: MSG_ERROR,
	            payload: error
	        });
	    };
	    RpcProvider.prototype._handleSignal = function (message) {
	        if (!this._signalHandlers[message.id]) {
	            return this._raiseError("invalid signal " + message.id);
	        }
	        this._signalHandlers[message.id].forEach(function (handler) { return handler(message.payload); });
	    };
	    RpcProvider.prototype._handeRpc = function (message) {
	        var _this = this;
	        if (!this._rpcHandlers[message.id]) {
	            return this._raiseError("invalid rpc " + message.id);
	        }
	        Promise.resolve(this._rpcHandlers[message.id](message.payload))
	            .then(function (result) { return _this._dispatch({
	            type: RpcProvider.MessageType.internal,
	            id: MSG_RESOLVE_TRANSACTION,
	            transactionId: message.transactionId,
	            payload: result
	        }); }, function (reason) { return _this._dispatch({
	            type: RpcProvider.MessageType.internal,
	            id: MSG_REJECT_TRANSACTION,
	            transactionId: message.transactionId,
	            payload: reason
	        }); });
	    };
	    RpcProvider.prototype._handleInternal = function (message) {
	        var transaction = typeof (message.transactionId) !== 'undefined' ? this._pendingTransactions[message.transactionId] : undefined;
	        switch (message.id) {
	            case MSG_RESOLVE_TRANSACTION:
	                if (!transaction || typeof (message.transactionId) === 'undefined') {
	                    return this._raiseError("no pending transaction with id " + message.transactionId);
	                }
	                transaction.resolve(message.payload);
	                this._clearTransaction(this._pendingTransactions[message.transactionId]);
	                break;
	            case MSG_REJECT_TRANSACTION:
	                if (!transaction || typeof (message.transactionId) === 'undefined') {
	                    return this._raiseError("no pending transaction with id " + message.transactionId);
	                }
	                this._pendingTransactions[message.transactionId].reject(message.payload);
	                this._clearTransaction(this._pendingTransactions[message.transactionId]);
	                break;
	            case MSG_ERROR:
	                this.error.dispatch(new Error("remote error: " + message.payload));
	                break;
	            default:
	                this._raiseError("unhandled internal message " + message.id);
	                break;
	        }
	    };
	    RpcProvider.prototype._transactionTimeout = function (transaction) {
	        transaction.reject('transaction timed out');
	        this._raiseError("transaction " + transaction.id + " timed out");
	        delete this._pendingTransactions[transaction.id];
	        return;
	    };
	    RpcProvider.prototype._clearTransaction = function (transaction) {
	        if (typeof (transaction.timeoutHandle) !== 'undefined') {
	            clearTimeout(transaction.timeoutHandle);
	        }
	        delete this._pendingTransactions[transaction.id];
	    };
	    return RpcProvider;
	}());
	(function (RpcProvider) {
	    var MessageType;
	    (function (MessageType) {
	        MessageType[MessageType["signal"] = 0] = "signal";
	        MessageType[MessageType["rpc"] = 1] = "rpc";
	        MessageType[MessageType["internal"] = 2] = "internal";
	    })(MessageType = RpcProvider.MessageType || (RpcProvider.MessageType = {}));
	})(RpcProvider || (RpcProvider = {}));
	exports.default = RpcProvider;
	});

	unwrapExports(RpcProvider_1);

	var lib$1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.RpcProvider = RpcProvider_1.default;
	});

	unwrapExports(lib$1);
	var lib_1$1 = lib$1.RpcProvider;

	let rpcProvider = null, port = null, portPending = null;
	function send(message, transfer) {
	    if (port) {
	        port.postMessage(message, transfer);
	    }
	    else {
	        postMessage(message, transfer);
	    }
	    if (portPending) {
	        port = portPending;
	        port.onmessage = (e) => rpcProvider.dispatch(e.data);
	    }
	    portPending = null;
	}
	rpcProvider = new lib_1$1(send);
	rpcProvider.error.addHandler(e => {
	    console.log(e ? e.message : 'unknown rpc error');
	});
	onmessage = (e) => port || rpcProvider.dispatch(e.data);
	rpcProvider.registerRpcHandler('/use-port', (newPort) => {
	    if (!(port || portPending)) {
	        portPending = newPort;
	        return Promise.resolve();
	    }
	    else {
	        return Promise.reject('RPC already switched to message port');
	    }
	});
	function getRpc() {
	    return rpcProvider;
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics = function(d, b) {
	    extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return extendStatics(d, b);
	};

	function __extends(d, b) {
	    extendStatics(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign = function() {
	    __assign = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};

	function __rest(s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	}

	function __decorate(decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	}

	function __param(paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	}

	function __metadata(metadataKey, metadataValue) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
	}

	function __awaiter(thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	}

	function __generator(thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	}

	function __exportStar(m, exports) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}

	function __values(o) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
	    if (m) return m.call(o);
	    return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	}

	function __read(o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	}

	function __spread() {
	    for (var ar = [], i = 0; i < arguments.length; i++)
	        ar = ar.concat(__read(arguments[i]));
	    return ar;
	}

	function __spreadArrays() {
	    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
	    for (var r = Array(s), k = 0, i = 0; i < il; i++)
	        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
	            r[k] = a[j];
	    return r;
	}
	function __await(v) {
	    return this instanceof __await ? (this.v = v, this) : new __await(v);
	}

	function __asyncGenerator(thisArg, _arguments, generator) {
	    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	    var g = generator.apply(thisArg, _arguments || []), i, q = [];
	    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
	    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
	    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
	    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
	    function fulfill(value) { resume("next", value); }
	    function reject(value) { resume("throw", value); }
	    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
	}

	function __asyncDelegator(o) {
	    var i, p;
	    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
	    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
	}

	function __asyncValues(o) {
	    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	    var m = o[Symbol.asyncIterator], i;
	    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
	    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
	    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
	}

	function __makeTemplateObject(cooked, raw) {
	    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
	    return cooked;
	}
	function __importStar(mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
	    result.default = mod;
	    return result;
	}

	function __importDefault(mod) {
	    return (mod && mod.__esModule) ? mod : { default: mod };
	}

	var tslib_es6 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		__extends: __extends,
		get __assign () { return __assign; },
		__rest: __rest,
		__decorate: __decorate,
		__param: __param,
		__metadata: __metadata,
		__awaiter: __awaiter,
		__generator: __generator,
		__exportStar: __exportStar,
		__values: __values,
		__read: __read,
		__spread: __spread,
		__spreadArrays: __spreadArrays,
		__await: __await,
		__asyncGenerator: __asyncGenerator,
		__asyncDelegator: __asyncDelegator,
		__asyncValues: __asyncValues,
		__makeTemplateObject: __makeTemplateObject,
		__importStar: __importStar,
		__importDefault: __importDefault
	});

	var EmulationServiceInterface;
	(function (EmulationServiceInterface) {
	    let State;
	    (function (State) {
	        State["stopped"] = "stopped";
	        State["running"] = "running";
	        State["paused"] = "paused";
	        State["error"] = "error";
	    })(State = EmulationServiceInterface.State || (EmulationServiceInterface.State = {}));
	})(EmulationServiceInterface || (EmulationServiceInterface = {}));

	class PoolMember {
	    constructor(_value, _releaseCB, _disposeCB) {
	        this._value = _value;
	        this._releaseCB = _releaseCB;
	        this._disposeCB = _disposeCB;
	        this._isAvailable = false;
	        this._isDisposed = false;
	    }
	    adopt(target) {
	        this._value = target;
	    }
	    get() {
	        return this._value;
	    }
	    release() {
	        this._releaseCB(this);
	    }
	    dispose() {
	        this._disposeCB(this);
	    }
	}

	class Pool {
	    constructor(_factory) {
	        this._factory = _factory;
	        this.event = {
	            release: new lib_1(),
	            dispose: new lib_1()
	        };
	        this._pool = [];
	        this._poolSize = 0;
	    }
	    get() {
	        let member;
	        if (this._poolSize === 0) {
	            const newItem = this._factory();
	            member = new PoolMember(newItem, (victim) => this._releaseMember(victim), (victim) => this._disposeMember(victim));
	        }
	        else {
	            member = this._pool[--this._poolSize];
	            member._isAvailable = false;
	        }
	        return member;
	    }
	    _releaseMember(victim) {
	        if (victim._isAvailable) {
	            throw new Error('Trying to release an already released pool member');
	        }
	        if (victim._isDisposed) {
	            throw new Error('Trying to release an already disposed pool member');
	        }
	        const position = this._poolSize++;
	        this._pool[position] = victim;
	        victim._isAvailable = true;
	        victim._poolPosition = position;
	        this.event.release.dispatch(victim.get());
	    }
	    _disposeMember(victim) {
	        if (victim._isDisposed) {
	            throw new Error('Trying to dispose of an already disposed pool member');
	        }
	        if (victim._isAvailable) {
	            if (this._poolSize > 1) {
	                this._pool[victim._poolPosition] = this._pool[this._poolSize - 1];
	            }
	            this._poolSize--;
	        }
	        victim._isDisposed = true;
	        this.event.dispose.dispatch(victim.get());
	    }
	}

	class ArrayBufferSurface {
	    constructor() {
	        this._height = 0;
	        this._width = 0;
	        this._buffer = null;
	    }
	    static createFromArrayBuffer(width, height, buffer) {
	        return new ArrayBufferSurface().replaceUnderlyingBuffer(width, height, buffer);
	    }
	    replaceUnderlyingBuffer(width, height, buffer) {
	        if (width * height * 4 !== buffer.byteLength) {
	            throw new Error('surface size mismatch');
	        }
	        this._width = width;
	        this._height = height;
	        this._underlyingBuffer = buffer;
	        this._buffer = new Uint32Array(this._underlyingBuffer);
	        return this;
	    }
	    getUnderlyingBuffer() {
	        return this._underlyingBuffer;
	    }
	    resetUnderlyingBuffer() {
	        this._width = this._height = 0;
	        this._underlyingBuffer = this._buffer = null;
	        return this;
	    }
	    getWidth() {
	        return this._width;
	    }
	    getHeight() {
	        return this._height;
	    }
	    getBuffer() {
	        return this._buffer;
	    }
	    getByteOrder() {
	        return 0;
	    }
	    fill(value) {
	        for (let i = 0; i < this._buffer.length; i++) {
	            this._buffer[i] = value;
	        }
	        return this;
	    }
	}

	class VideoEndpoint {
	    constructor(_video) {
	        this._video = _video;
	        this.newFrame = new lib_1();
	        this._poolMembers = new WeakMap();
	        this._surfaces = new WeakMap();
	        this._pool = new Pool(() => new ImageData(this._video.getWidth(), this._video.getHeight()));
	        this._video.setSurfaceFactory(() => {
	            const poolMember = this._pool.get(), imageData = poolMember.get();
	            if (!this._surfaces.has(imageData)) {
	                const newSurface = ArrayBufferSurface.createFromArrayBuffer(imageData.width, imageData.height, imageData.data.buffer);
	                this._surfaces.set(imageData, newSurface.fill(0xff000000));
	            }
	            const surface = this._surfaces.get(imageData);
	            this._poolMembers.set(surface, poolMember);
	            return surface;
	        });
	        this._video.newFrame.addHandler(imageData => this.newFrame.dispatch(this._poolMembers.get(imageData)));
	    }
	    getWidth() {
	        return this._video.getWidth();
	    }
	    getHeight() {
	        return this._video.getHeight();
	    }
	}

	class InducedMember {
	    constructor(_value, _mapper, _adopter) {
	        this._value = _value;
	        this._mapper = _mapper;
	        this._adopter = _adopter;
	    }
	    adopt(target) {
	        this._adopter(this._value, target);
	    }
	    get() {
	        return this._mapper(this._value.get());
	    }
	    release() {
	        this._value.release();
	    }
	    dispose() {
	        this._value.dispose();
	    }
	}

	class InducedPool {
	    constructor(_mapper, _adopter = () => {
	        throw new Error('adopt is not supported');
	    }) {
	        this._mapper = _mapper;
	        this._adopter = _adopter;
	        this._map = new WeakMap();
	    }
	    get(original) {
	        if (!this._map.has(original)) {
	            this._map.set(original, new InducedMember(original, this._mapper, this._adopter));
	        }
	        return this._map.get(original);
	    }
	}

	class AudioOutputBuffer {
	    constructor(_content, _sampleRate) {
	        this._content = _content;
	        this._sampleRate = _sampleRate;
	    }
	    getLength() {
	        return this._content.length;
	    }
	    getContent() {
	        return this._content;
	    }
	    getSampleRate() {
	        return this._sampleRate;
	    }
	    replaceUnderlyingBuffer(buffer) {
	        this._content = buffer;
	    }
	}

	class PCMAudioEndpoint {
	    constructor(_output) {
	        this._output = _output;
	        this.newFrame = new lib_1();
	        this.togglePause = new lib_1();
	        this._audioBufferPool = new Pool(() => new AudioOutputBuffer(new Float32Array(this.getFrameSize()), this.getSampleRate()));
	        this._audioBufferMap = new WeakMap();
	        this._pcmDataPool = new InducedPool((buffer) => buffer.getContent(), (value, target) => value.get().replaceUnderlyingBuffer(target));
	        this._output.newFrame.addHandler((buffer) => this.newFrame.dispatch(this._pcmDataPool.get(this._audioBufferMap.get(buffer))));
	        this._output.togglePause.addHandler((paused) => this.togglePause.dispatch(paused));
	        this._output.setFrameBufferFactory(() => {
	            const wrappedBuffer = this._audioBufferPool.get();
	            if (!this._audioBufferMap.has(wrappedBuffer.get())) {
	                this._audioBufferMap.set(wrappedBuffer.get(), wrappedBuffer);
	            }
	            return wrappedBuffer.get();
	        });
	    }
	    getSampleRate() {
	        return this._output.getSampleRate();
	    }
	    getFrameSize() {
	        return this._output.getFrameSize();
	    }
	    isPaused() {
	        return this._output.isPaused();
	    }
	}

	class EmulationContext {
	    constructor(_board, _asyncIO) {
	        this._board = _board;
	        this._asyncIO = _asyncIO;
	        this._videoEndpoint = null;
	        this._audioEndpoint = null;
	    }
	    getConfig() {
	        return this._board.getConfig();
	    }
	    getVideo() {
	        if (!this._videoEndpoint) {
	            this._videoEndpoint = new VideoEndpoint(this._board.getVideoOutput());
	        }
	        return this._videoEndpoint;
	    }
	    getJoystick(i) {
	        switch (i) {
	            case 0:
	                return this._board.getJoystick0();
	            case 1:
	                return this._board.getJoystick1();
	            default:
	                throw new Error(`invalid joystick index ${i}`);
	        }
	    }
	    getControlPanel() {
	        return this._board.getControlPanel();
	    }
	    getPaddle(i) {
	        if (i >= 0 && i < 4) {
	            return this._board.getPaddle(i);
	        }
	        else {
	            throw new Error(`invalid paddle index ${i}`);
	        }
	    }
	    getWaveformChannels() {
	        return this._board.getWaveformChannels();
	    }
	    getPCMChannel() {
	        if (!this._audioEndpoint) {
	            this._audioEndpoint = new PCMAudioEndpoint(this._board.getPCMChannel());
	        }
	        return this._audioEndpoint;
	    }
	    getRawVideo() {
	        if (this._videoEndpoint) {
	            throw new Error(`video endpoint already initialized; raw video unavailable`);
	        }
	        return this._board.getVideoOutput();
	    }
	    getAsyncIO() {
	        return this._asyncIO;
	    }
	}

	var BoardInterface;
	(function (BoardInterface) {
	    class TrapPayload {
	        constructor(reason, board, message) {
	            this.reason = reason;
	            this.board = board;
	            this.message = message;
	        }
	    }
	    BoardInterface.TrapPayload = TrapPayload;
	})(BoardInterface || (BoardInterface = {}));

	class Bus {
	    constructor() {
	        this.event = {
	            trap: new lib_1(),
	            read: new lib_1(),
	            write: new lib_1()
	        };
	        this._tia = null;
	        this._pia = null;
	        this._cartridge = null;
	        this._lastDataBusValue = 0;
	        this._lastAddressBusValue = 0;
	    }
	    setTia(tia) {
	        tia.trap.addHandler((payload) => this.triggerTrap(0, 'TIA: ' + (payload.message || '')));
	        this._tia = tia;
	        return this;
	    }
	    setPia(pia) {
	        pia.trap.addHandler((payload) => this.triggerTrap(1, 'PIA: ' + (payload.message || '')));
	        this._pia = pia;
	        return this;
	    }
	    setCartridge(cartridge) {
	        cartridge.trap.addHandler((payload) => this.triggerTrap(2, 'CARTRIDGE: ' + (payload.message || '')));
	        this._cartridge = cartridge;
	        return this;
	    }
	    readWord(address) {
	        return this.read(address) | (this.read((address + 1) & 0xffff) << 8);
	    }
	    read(address) {
	        this._lastAddressBusValue = address;
	        address &= 0x1fff;
	        if (address & 0x1000) {
	            this._lastDataBusValue = this._cartridge.read(address);
	            this.event.read.dispatch(2);
	        }
	        else if (address & 0x80) {
	            this._lastDataBusValue = this._pia.read(address);
	            this.event.read.dispatch(1);
	        }
	        else {
	            this._lastDataBusValue = this._tia.read(address);
	            this.event.read.dispatch(0);
	        }
	        return this._lastDataBusValue;
	    }
	    write(address, value) {
	        this._lastDataBusValue = value;
	        this._lastAddressBusValue = address;
	        address &= 0x1fff;
	        if (address & 0x1000) {
	            this._cartridge.write(address, value);
	            this.event.write.dispatch(2);
	        }
	        else if (address & 0x80) {
	            this._pia.write(address, value);
	            this.event.write.dispatch(1);
	        }
	        else {
	            this._tia.write(address, value);
	            this.event.write.dispatch(0);
	        }
	    }
	    peek(address) {
	        address &= 0x1fff;
	        if (address & 0x1000) {
	            return this._cartridge.peek(address);
	        }
	        else if (address & 0x80) {
	            return this._pia.peek(address);
	        }
	        else {
	            return this._tia.peek(address);
	        }
	    }
	    poke(address, value) { }
	    getLastDataBusValue() {
	        return this._lastDataBusValue;
	    }
	    setDataBusValue(value) {
	        this._lastDataBusValue = value;
	    }
	    getLastAddresBusValue() {
	        return this._lastAddressBusValue;
	    }
	    triggerTrap(reason, message) {
	        if (this.event.trap.hasHandlers) {
	            this.event.trap.dispatch(new Bus.TrapPayload(reason, this, message));
	        }
	        else {
	            throw new Error(message);
	        }
	    }
	}
	(function (Bus) {
	    class TrapPayload {
	        constructor(reason, bus, message) {
	            this.reason = reason;
	            this.bus = bus;
	            this.message = message;
	        }
	    }
	    Bus.TrapPayload = TrapPayload;
	})(Bus || (Bus = {}));

	class Pia {
	    constructor(_controlPanel, _joystick0, _joystick1, _rng) {
	        this._controlPanel = _controlPanel;
	        this._joystick0 = _joystick0;
	        this._joystick1 = _joystick1;
	        this._rng = _rng;
	        this.trap = new lib_1();
	        this.ram = new Uint8Array(128);
	        this._bus = null;
	        this._timerValue = 255;
	        this._subTimer = 0;
	        this._timerDivide = 1024;
	        this._interruptFlag = 0;
	        this._timerWrapped = false;
	        this._flagSetDuringThisCycle = false;
	        this.reset();
	    }
	    reset() {
	        for (let i = 0; i < 128; i++) {
	            this.ram[i] = this._rng ? this._rng.int(0xff) : 0;
	        }
	        this._interruptFlag = 0;
	        this._flagSetDuringThisCycle = false;
	        this._timerDivide = 1024;
	        this._subTimer = 0;
	        this._rng.int(0xff);
	        this._timerValue = 0;
	        this._timerWrapped = false;
	    }
	    read(address) {
	        if (address & 0x0200) {
	            if (address & 0x0004) {
	                return this._readTimer(address);
	            }
	            else {
	                return this._readIo(address);
	            }
	        }
	        else {
	            return this.ram[address & 0x7f];
	        }
	    }
	    peek(address) {
	        if (address & 0x0200) {
	            if (address & 0x0004) {
	                return this._peekTimer(address);
	            }
	            else {
	                return this._readIo(address);
	            }
	        }
	        else {
	            return this.ram[address & 0x7f];
	        }
	    }
	    write(address, value) {
	        if (address & 0x0200) {
	            if (address & 0x0004) {
	                return this._writeTimer(address, value);
	            }
	            else {
	                return this._writeIo(address, value);
	            }
	        }
	        else {
	            this.ram[address & 0x7f] = value;
	        }
	    }
	    cycle() {
	        this._cycleTimer();
	    }
	    getDebugState() {
	        return `divider: ${this._timerDivide} raw timer: INTIM: ${this._timerValue}`;
	    }
	    setBus(bus) {
	        this._bus = bus;
	        return this;
	    }
	    _writeIo(address, value) { }
	    _writeTimer(address, value) {
	        this._interruptFlag = 0;
	        switch (address & 0x0297) {
	            case 663:
	                return this._setTimer(1024, value);
	            case 662:
	                return this._setTimer(64, value);
	            case 661:
	                return this._setTimer(8, value);
	            case 660:
	                return this._setTimer(1, value);
	        }
	    }
	    _setTimer(divide, value) {
	        this._timerDivide = divide;
	        this._timerValue = value;
	        this._subTimer = 0;
	        this._timerWrapped = false;
	    }
	    _readIo(address) {
	        switch (address & 0x0283) {
	            case 640:
	                return ((this._joystick1.getUp().read() ? 0 : 0x01) |
	                    (this._joystick1.getDown().read() ? 0 : 0x02) |
	                    (this._joystick1.getLeft().read() ? 0 : 0x04) |
	                    (this._joystick1.getRight().read() ? 0 : 0x08) |
	                    (this._joystick0.getUp().read() ? 0 : 0x10) |
	                    (this._joystick0.getDown().read() ? 0 : 0x20) |
	                    (this._joystick0.getLeft().read() ? 0 : 0x40) |
	                    (this._joystick0.getRight().read() ? 0 : 0x80));
	            case 642:
	                return ((this._controlPanel.getResetButton().read() ? 0 : 0x01) |
	                    (this._controlPanel.getSelectSwitch().read() ? 0 : 0x02) |
	                    (this._controlPanel.getColorSwitch().read() ? 0 : 0x08) |
	                    (this._controlPanel.getDifficultySwitchP0().read() ? 0 : 0x40) |
	                    (this._controlPanel.getDifficultySwitchP1().read() ? 0 : 0x80));
	        }
	        return this._bus.getLastDataBusValue();
	    }
	    _readTimer(address) {
	        if (address & 0x01) {
	            const flag = this._interruptFlag;
	            return flag & 0x80;
	        }
	        else {
	            if (!this._flagSetDuringThisCycle) {
	                this._interruptFlag = 0;
	                this._timerWrapped = false;
	            }
	            return this._timerValue;
	        }
	    }
	    _peekTimer(address) {
	        return address & 0x01 ? this._interruptFlag & 0x80 : this._timerValue;
	    }
	    _cycleTimer() {
	        this._flagSetDuringThisCycle = false;
	        if (this._timerWrapped) {
	            this._timerValue = (this._timerValue + 0xff) & 0xff;
	        }
	        else if (this._subTimer === 0 && --this._timerValue < 0) {
	            this._timerValue = 0xff;
	            this._flagSetDuringThisCycle = true;
	            this._interruptFlag = 0xff;
	            this._timerWrapped = true;
	        }
	        if (++this._subTimer === this._timerDivide) {
	            this._subTimer = 0;
	        }
	    }
	}
	(function (Pia) {
	    class TrapPayload {
	        constructor(reason, pia, message) {
	            this.reason = reason;
	            this.pia = pia;
	            this.message = message;
	        }
	    }
	    Pia.TrapPayload = TrapPayload;
	})(Pia || (Pia = {}));

	var CpuInterface;
	(function (CpuInterface) {
	    class State {
	        constructor() {
	            this.a = 0;
	            this.x = 0;
	            this.y = 0;
	            this.s = 0;
	            this.p = 0;
	            this.flags = 0;
	            this.irq = false;
	            this.nmi = false;
	        }
	    }
	    CpuInterface.State = State;
	})(CpuInterface || (CpuInterface = {}));

	class ResultImpl {
	    constructor() {
	        this.cycleType = 0;
	        this.address = 0;
	        this.value = 0;
	        this.pollInterrupts = false;
	        this.nextStep = null;
	    }
	    read(nextStep, address) {
	        this.cycleType = 0;
	        this.address = address;
	        this.nextStep = nextStep;
	        return this;
	    }
	    write(nextStep, address, value) {
	        this.cycleType = 1;
	        this.address = address;
	        this.value = value;
	        this.nextStep = nextStep;
	        return this;
	    }
	    poll(poll) {
	        this.pollInterrupts = poll;
	        return this;
	    }
	}

	const immutables = Symbol('immutable properties');
	function freezeImmutables(target) {
	    const immutableProperties = target[immutables];
	    if (!immutableProperties) {
	        return;
	    }
	    for (const prop of immutableProperties) {
	        Object.defineProperty(target, prop, { writable: false, configurable: false });
	    }
	}
	function Immutable(target, prop) {
	    if (!target[immutables]) {
	        Object.defineProperty(target, immutables, { value: [], writable: false, enumerable: false });
	    }
	    target[immutables].push(prop);
	}

	class Boot {
	    constructor(state) {
	        this.reset = () => this._result.read(this._pre1Step, 0xff);
	        this._pre1Step = () => this._result.read(this._pre2Step, 0x0ff);
	        this._pre2Step = () => this._result.read(this._stack1Step, 0x0100);
	        this._stack1Step = () => this._result.read(this._stack2Step, 0x01ff);
	        this._stack2Step = () => {
	            this._state.s = 0xfd;
	            return this._result.read(this._stack3Step, 0x01fe);
	        };
	        this._stack3Step = () => this._result.read(this._readTargetLoStep, 0xfffc);
	        this._readTargetLoStep = (operand) => {
	            this._targetAddress = operand;
	            return this._result.read(this._readTargetHiStep, 0xfffd);
	        };
	        this._readTargetHiStep = (operand) => {
	            this._targetAddress |= operand << 8;
	            this._state.p = this._targetAddress;
	            return null;
	        };
	        this._targetAddress = 0;
	        this._result = new ResultImpl();
	        this._state = state;
	        freezeImmutables(this);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Boot.prototype, "reset", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Boot.prototype, "_pre1Step", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Boot.prototype, "_pre2Step", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Boot.prototype, "_stack1Step", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Boot.prototype, "_stack2Step", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Boot.prototype, "_stack3Step", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Boot.prototype, "_readTargetLoStep", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Boot.prototype, "_readTargetHiStep", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Boot.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], Boot.prototype, "_state", void 0);
	const boot = (state) => new Boot(state);

	class Interrupt {
	    constructor(state, defaultVector, isBrk) {
	        this.reset = () => this._result.read(this._dummyRead, this._state.p);
	        this._dummyRead = () => {
	            if (this._isBrk) {
	                this._state.p = (this._state.p + 1) & 0xffff;
	            }
	            return this._result.write(this._pushPch, 0x0100 + this._state.s, this._state.p >>> 8);
	        };
	        this._pushPch = () => {
	            this._state.s = (this._state.s - 1) & 0xff;
	            return this._result.write(this._pushPcl, 0x0100 + this._state.s, this._state.p & 0xff).poll(true);
	        };
	        this._pushPcl = () => {
	            this._state.s = (this._state.s - 1) & 0xff;
	            this._vector = this._state.nmi ? 0xfffa : this._defaultVector;
	            return this._result.write(this._pushFlags, 0x0100 + this._state.s, this._isBrk ? this._state.flags | 16 : this._state.flags & ~16);
	        };
	        this._pushFlags = () => {
	            this._state.s = (this._state.s - 1) & 0xff;
	            return this._result.read(this._fetchPcl, this._vector);
	        };
	        this._fetchPcl = (value) => {
	            this._state.flags |= 4;
	            this._state.p = value;
	            return this._result.read(this._fetchPch, ++this._vector);
	        };
	        this._fetchPch = (value) => {
	            this._state.p = this._state.p | (value << 8);
	            this._state.nmi = this._state.irq = false;
	            return null;
	        };
	        this._vector = 0;
	        this._result = new ResultImpl();
	        this._state = state;
	        this._defaultVector = defaultVector;
	        this._isBrk = isBrk;
	        freezeImmutables(this);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Interrupt.prototype, "reset", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Interrupt.prototype, "_dummyRead", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Interrupt.prototype, "_pushPch", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Interrupt.prototype, "_pushPcl", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Interrupt.prototype, "_pushFlags", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Interrupt.prototype, "_fetchPcl", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Interrupt.prototype, "_fetchPch", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Interrupt.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], Interrupt.prototype, "_state", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Number)
	], Interrupt.prototype, "_defaultVector", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Boolean)
	], Interrupt.prototype, "_isBrk", void 0);
	const brk = (state) => new Interrupt(state, 0xfffe, true);
	const irq = (state) => new Interrupt(state, 0xfffe, false);
	const nmi = (state) => new Interrupt(state, 0xfffa, false);

	class Instruction {
	    constructor(operation, addressingMode, effectiveAddressingMode = addressingMode) {
	        this.operation = operation;
	        this.addressingMode = addressingMode;
	        this.effectiveAddressingMode = effectiveAddressingMode;
	    }
	    getSize() {
	        switch (this.effectiveAddressingMode) {
	            case 1:
	            case 2:
	            case 6:
	            case 9:
	            case 8:
	            case 11:
	            case 5:
	                return 2;
	            case 3:
	            case 7:
	            case 10:
	            case 4:
	                return 3;
	            default:
	                return 1;
	        }
	    }
	}
	(function (Instruction) {
	    let OperationMap;
	    (function (OperationMap) {
	        OperationMap[OperationMap["adc"] = 0] = "adc";
	        OperationMap[OperationMap["and"] = 1] = "and";
	        OperationMap[OperationMap["asl"] = 2] = "asl";
	        OperationMap[OperationMap["bcc"] = 3] = "bcc";
	        OperationMap[OperationMap["bcs"] = 4] = "bcs";
	        OperationMap[OperationMap["beq"] = 5] = "beq";
	        OperationMap[OperationMap["bit"] = 6] = "bit";
	        OperationMap[OperationMap["bmi"] = 7] = "bmi";
	        OperationMap[OperationMap["bne"] = 8] = "bne";
	        OperationMap[OperationMap["bpl"] = 9] = "bpl";
	        OperationMap[OperationMap["brk"] = 10] = "brk";
	        OperationMap[OperationMap["bvc"] = 11] = "bvc";
	        OperationMap[OperationMap["bvs"] = 12] = "bvs";
	        OperationMap[OperationMap["clc"] = 13] = "clc";
	        OperationMap[OperationMap["cld"] = 14] = "cld";
	        OperationMap[OperationMap["cli"] = 15] = "cli";
	        OperationMap[OperationMap["clv"] = 16] = "clv";
	        OperationMap[OperationMap["cmp"] = 17] = "cmp";
	        OperationMap[OperationMap["cpx"] = 18] = "cpx";
	        OperationMap[OperationMap["cpy"] = 19] = "cpy";
	        OperationMap[OperationMap["dec"] = 20] = "dec";
	        OperationMap[OperationMap["dex"] = 21] = "dex";
	        OperationMap[OperationMap["dey"] = 22] = "dey";
	        OperationMap[OperationMap["eor"] = 23] = "eor";
	        OperationMap[OperationMap["inc"] = 24] = "inc";
	        OperationMap[OperationMap["inx"] = 25] = "inx";
	        OperationMap[OperationMap["iny"] = 26] = "iny";
	        OperationMap[OperationMap["jmp"] = 27] = "jmp";
	        OperationMap[OperationMap["jsr"] = 28] = "jsr";
	        OperationMap[OperationMap["lda"] = 29] = "lda";
	        OperationMap[OperationMap["ldx"] = 30] = "ldx";
	        OperationMap[OperationMap["ldy"] = 31] = "ldy";
	        OperationMap[OperationMap["lsr"] = 32] = "lsr";
	        OperationMap[OperationMap["nop"] = 33] = "nop";
	        OperationMap[OperationMap["ora"] = 34] = "ora";
	        OperationMap[OperationMap["pha"] = 35] = "pha";
	        OperationMap[OperationMap["php"] = 36] = "php";
	        OperationMap[OperationMap["pla"] = 37] = "pla";
	        OperationMap[OperationMap["plp"] = 38] = "plp";
	        OperationMap[OperationMap["rol"] = 39] = "rol";
	        OperationMap[OperationMap["ror"] = 40] = "ror";
	        OperationMap[OperationMap["rti"] = 41] = "rti";
	        OperationMap[OperationMap["rts"] = 42] = "rts";
	        OperationMap[OperationMap["sbc"] = 43] = "sbc";
	        OperationMap[OperationMap["sec"] = 44] = "sec";
	        OperationMap[OperationMap["sed"] = 45] = "sed";
	        OperationMap[OperationMap["sei"] = 46] = "sei";
	        OperationMap[OperationMap["sta"] = 47] = "sta";
	        OperationMap[OperationMap["stx"] = 48] = "stx";
	        OperationMap[OperationMap["sty"] = 49] = "sty";
	        OperationMap[OperationMap["tax"] = 50] = "tax";
	        OperationMap[OperationMap["tay"] = 51] = "tay";
	        OperationMap[OperationMap["tsx"] = 52] = "tsx";
	        OperationMap[OperationMap["txa"] = 53] = "txa";
	        OperationMap[OperationMap["txs"] = 54] = "txs";
	        OperationMap[OperationMap["tya"] = 55] = "tya";
	        OperationMap[OperationMap["dop"] = 56] = "dop";
	        OperationMap[OperationMap["top"] = 57] = "top";
	        OperationMap[OperationMap["alr"] = 58] = "alr";
	        OperationMap[OperationMap["axs"] = 59] = "axs";
	        OperationMap[OperationMap["dcp"] = 60] = "dcp";
	        OperationMap[OperationMap["lax"] = 61] = "lax";
	        OperationMap[OperationMap["arr"] = 62] = "arr";
	        OperationMap[OperationMap["slo"] = 63] = "slo";
	        OperationMap[OperationMap["aax"] = 64] = "aax";
	        OperationMap[OperationMap["lar"] = 65] = "lar";
	        OperationMap[OperationMap["isc"] = 66] = "isc";
	        OperationMap[OperationMap["aac"] = 67] = "aac";
	        OperationMap[OperationMap["atx"] = 68] = "atx";
	        OperationMap[OperationMap["rra"] = 69] = "rra";
	        OperationMap[OperationMap["rla"] = 70] = "rla";
	        OperationMap[OperationMap["invalid"] = 71] = "invalid";
	    })(OperationMap = Instruction.OperationMap || (Instruction.OperationMap = {}));
	    Instruction.opcodes = new Array(256);
	})(Instruction || (Instruction = {}));
	(function (Instruction) {
	    let __init;
	    (function (__init) {
	        for (let i = 0; i < 256; i++) {
	            Instruction.opcodes[i] = new Instruction(71, 12);
	        }
	        let operation, addressingMode, opcode;
	        for (let i = 0; i < 8; i++) {
	            switch (i) {
	                case 0:
	                    operation = 34;
	                    break;
	                case 1:
	                    operation = 1;
	                    break;
	                case 2:
	                    operation = 23;
	                    break;
	                case 3:
	                    operation = 0;
	                    break;
	                case 4:
	                    operation = 47;
	                    break;
	                case 5:
	                    operation = 29;
	                    break;
	                case 6:
	                    operation = 17;
	                    break;
	                case 7:
	                    operation = 43;
	                    break;
	            }
	            for (let j = 0; j < 8; j++) {
	                switch (j) {
	                    case 0:
	                        addressingMode = 8;
	                        break;
	                    case 1:
	                        addressingMode = 2;
	                        break;
	                    case 2:
	                        addressingMode = 1;
	                        break;
	                    case 3:
	                        addressingMode = 3;
	                        break;
	                    case 4:
	                        addressingMode = 11;
	                        break;
	                    case 5:
	                        addressingMode = 6;
	                        break;
	                    case 6:
	                        addressingMode = 10;
	                        break;
	                    case 7:
	                        addressingMode = 7;
	                        break;
	                }
	                if (operation === 47 && addressingMode === 1) {
	                    addressingMode = 12;
	                }
	                if (operation !== 71 && addressingMode !== 12) {
	                    opcode = (i << 5) | (j << 2) | 1;
	                    Instruction.opcodes[opcode] = new Instruction(operation, addressingMode);
	                }
	            }
	        }
	        function set(_opcode, _operation, _addressingMode, _effectiveAdressingMode) {
	            if (Instruction.opcodes[_opcode].operation !== 71) {
	                throw new Error('entry for opcode ' + _opcode + ' already exists');
	            }
	            Instruction.opcodes[_opcode] = new Instruction(_operation, _addressingMode, _effectiveAdressingMode);
	        }
	        set(0x06, 2, 2);
	        set(0x0a, 2, 0);
	        set(0x0e, 2, 3);
	        set(0x16, 2, 6);
	        set(0x1e, 2, 7);
	        set(0x26, 39, 2);
	        set(0x2a, 39, 0);
	        set(0x2e, 39, 3);
	        set(0x36, 39, 6);
	        set(0x3e, 39, 7);
	        set(0x46, 32, 2);
	        set(0x4a, 32, 0);
	        set(0x4e, 32, 3);
	        set(0x56, 32, 6);
	        set(0x5e, 32, 7);
	        set(0x66, 40, 2);
	        set(0x6a, 40, 0);
	        set(0x6e, 40, 3);
	        set(0x76, 40, 6);
	        set(0x7e, 40, 7);
	        set(0x86, 48, 2);
	        set(0x8e, 48, 3);
	        set(0x96, 48, 9);
	        set(0xa2, 30, 1);
	        set(0xa6, 30, 2);
	        set(0xae, 30, 3);
	        set(0xb6, 30, 9);
	        set(0xbe, 30, 10);
	        set(0xc6, 20, 2);
	        set(0xce, 20, 3);
	        set(0xd6, 20, 6);
	        set(0xde, 20, 7);
	        set(0xe6, 24, 2);
	        set(0xee, 24, 3);
	        set(0xf6, 24, 6);
	        set(0xfe, 24, 7);
	        set(0x24, 6, 2);
	        set(0x2c, 6, 3);
	        set(0x4c, 27, 3);
	        set(0x6c, 27, 4);
	        set(0x84, 49, 2);
	        set(0x8c, 49, 3);
	        set(0x94, 49, 6);
	        set(0xa0, 31, 1);
	        set(0xa4, 31, 2);
	        set(0xac, 31, 3);
	        set(0xb4, 31, 6);
	        set(0xbc, 31, 7);
	        set(0xc0, 19, 1);
	        set(0xc4, 19, 2);
	        set(0xcc, 19, 3);
	        set(0xe0, 18, 1);
	        set(0xe4, 18, 2);
	        set(0xec, 18, 3);
	        set(0x10, 9, 5);
	        set(0x30, 7, 5);
	        set(0x50, 11, 5);
	        set(0x70, 12, 5);
	        set(0x90, 3, 5);
	        set(0xb0, 4, 5);
	        set(0xd0, 8, 5);
	        set(0xf0, 5, 5);
	        set(0x00, 10, 0);
	        set(0x20, 28, 0, 3);
	        set(0x40, 41, 0);
	        set(0x60, 42, 0);
	        set(0x08, 36, 0);
	        set(0x28, 38, 0);
	        set(0x48, 35, 0);
	        set(0x68, 37, 0);
	        set(0x88, 22, 0);
	        set(0xa8, 51, 0);
	        set(0xc8, 26, 0);
	        set(0xe8, 25, 0);
	        set(0x18, 13, 0);
	        set(0x38, 44, 0);
	        set(0x58, 15, 0);
	        set(0x78, 46, 0);
	        set(0x98, 55, 0);
	        set(0xb8, 16, 0);
	        set(0xd8, 14, 0);
	        set(0xf8, 45, 0);
	        set(0x8a, 53, 0);
	        set(0x9a, 54, 0);
	        set(0xaa, 50, 0);
	        set(0xba, 52, 0);
	        set(0xca, 21, 0);
	        set(0xea, 33, 0);
	        set(0x1a, 33, 0);
	        set(0x3a, 33, 0);
	        set(0x5a, 33, 0);
	        set(0x7a, 33, 0);
	        set(0xda, 33, 0);
	        set(0xfa, 33, 0);
	        set(0x04, 56, 2);
	        set(0x14, 56, 6);
	        set(0x34, 56, 6);
	        set(0x44, 56, 2);
	        set(0x54, 56, 6);
	        set(0x64, 56, 2);
	        set(0x74, 56, 6);
	        set(0x80, 56, 1);
	        set(0x82, 56, 1);
	        set(0x89, 56, 1);
	        set(0xc2, 56, 1);
	        set(0xd4, 56, 6);
	        set(0xe2, 56, 1);
	        set(0xf4, 56, 6);
	        set(0x0c, 57, 3);
	        set(0x1c, 57, 7);
	        set(0x3c, 57, 7);
	        set(0x5c, 57, 7);
	        set(0x7c, 57, 7);
	        set(0xdc, 57, 7);
	        set(0xfc, 57, 7);
	        set(0xeb, 43, 1);
	        set(0x4b, 58, 1);
	        set(0xcb, 59, 1);
	        set(0xc7, 60, 2);
	        set(0xd7, 60, 6);
	        set(0xcf, 60, 3);
	        set(0xdf, 60, 7);
	        set(0xdb, 60, 10);
	        set(0xc3, 60, 8);
	        set(0xd3, 60, 11);
	        set(0xa7, 61, 2);
	        set(0xb7, 61, 9);
	        set(0xaf, 61, 3);
	        set(0xbf, 61, 10);
	        set(0xa3, 61, 8);
	        set(0xb3, 61, 11);
	        set(0x6b, 62, 1);
	        set(0x07, 63, 2);
	        set(0x17, 63, 6);
	        set(0x0f, 63, 3);
	        set(0x1f, 63, 7);
	        set(0x1b, 63, 10);
	        set(0x03, 63, 8);
	        set(0x13, 63, 11);
	        set(0x87, 64, 2);
	        set(0x97, 64, 9);
	        set(0x83, 64, 8);
	        set(0x8f, 64, 3);
	        set(0xbb, 65, 10);
	        set(0xe7, 66, 2);
	        set(0xf7, 66, 6);
	        set(0xef, 66, 3);
	        set(0xff, 66, 7);
	        set(0xfb, 66, 10);
	        set(0xe3, 66, 8);
	        set(0xf3, 66, 11);
	        set(0x0b, 67, 1);
	        set(0x2b, 67, 1);
	        set(0xab, 68, 1);
	        set(0x67, 69, 2);
	        set(0x77, 69, 6);
	        set(0x6f, 69, 3);
	        set(0x7f, 69, 7);
	        set(0x7b, 69, 10);
	        set(0x63, 69, 8);
	        set(0x73, 69, 11);
	        set(0x27, 70, 2);
	        set(0x37, 70, 6);
	        set(0x2f, 70, 3);
	        set(0x3f, 70, 7);
	        set(0x3b, 70, 10);
	        set(0x23, 70, 8);
	        set(0x33, 70, 11);
	    })(__init = Instruction.__init || (Instruction.__init = {}));
	})(Instruction || (Instruction = {}));

	class Absolute {
	    constructor(state, next = () => null) {
	        this.reset = () => this._result.read(this._fetchLo, this._state.p);
	        this._fetchLo = (value) => {
	            this._operand = value;
	            this._state.p = (this._state.p + 1) & 0xffff;
	            return this._result.read(this._fetchHi, this._state.p);
	        };
	        this._fetchHi = (value) => {
	            this._operand |= value << 8;
	            this._state.p = (this._state.p + 1) & 0xffff;
	            return this._next(this._operand, this._state);
	        };
	        this._operand = 0;
	        this._result = new ResultImpl();
	        this._state = state;
	        this._next = next;
	        freezeImmutables(this);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Absolute.prototype, "reset", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Absolute.prototype, "_fetchLo", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Absolute.prototype, "_fetchHi", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Absolute.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], Absolute.prototype, "_state", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Function)
	], Absolute.prototype, "_next", void 0);
	const absolute = (state, next) => new Absolute(state, next);

	class AbsoluteIndexed {
	    constructor(state, indexExtractor, next = () => null, writeOp = false) {
	        this.reset = () => this._result.read(this._fetchLo, this._state.p);
	        this._fetchLo = (value) => {
	            this._operand = value;
	            this._state.p = (this._state.p + 1) & 0xffff;
	            return this._result.read(this._fetchHi, this._state.p);
	        };
	        this._fetchHi = (value) => {
	            this._operand |= value << 8;
	            this._state.p = (this._state.p + 1) & 0xffff;
	            const index = this._indexExtractor(this._state);
	            this._carry = (this._operand & 0xff) + index > 0xff;
	            this._operand = (this._operand & 0xff00) | ((this._operand + index) & 0xff);
	            return this._carry || this._writeOp
	                ? this._result.read(this._dereferenceAndCarry, this._operand)
	                : this._next(this._operand, this._state);
	        };
	        this._dereferenceAndCarry = (value) => {
	            if (this._carry) {
	                this._operand = (this._operand + 0x0100) & 0xffff;
	            }
	            return this._next(this._operand, this._state);
	        };
	        this._operand = 0;
	        this._carry = false;
	        this._result = new ResultImpl();
	        this._state = state;
	        this._indexExtractor = indexExtractor;
	        this._next = next;
	        this._writeOp = writeOp;
	        freezeImmutables(this);
	    }
	    static absoluteX(state, next, writeOp) {
	        return new AbsoluteIndexed(state, s => s.x, next, writeOp);
	    }
	    static absoluteY(state, next, writeOp) {
	        return new AbsoluteIndexed(state, s => s.y, next, writeOp);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], AbsoluteIndexed.prototype, "reset", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], AbsoluteIndexed.prototype, "_fetchLo", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], AbsoluteIndexed.prototype, "_fetchHi", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], AbsoluteIndexed.prototype, "_dereferenceAndCarry", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], AbsoluteIndexed.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], AbsoluteIndexed.prototype, "_state", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Function)
	], AbsoluteIndexed.prototype, "_indexExtractor", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Function)
	], AbsoluteIndexed.prototype, "_next", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Boolean)
	], AbsoluteIndexed.prototype, "_writeOp", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Function),
	    __metadata("design:paramtypes", [CpuInterface.State, Function, Boolean]),
	    __metadata("design:returntype", AbsoluteIndexed)
	], AbsoluteIndexed, "absoluteX", null);
	__decorate([
	    Immutable,
	    __metadata("design:type", Function),
	    __metadata("design:paramtypes", [CpuInterface.State, Function, Boolean]),
	    __metadata("design:returntype", AbsoluteIndexed)
	], AbsoluteIndexed, "absoluteY", null);
	const absoluteX = (state, next, writeOp) => AbsoluteIndexed.absoluteX(state, next, writeOp);
	const absoluteY = (state, next, writeOp) => AbsoluteIndexed.absoluteY(state, next, writeOp);

	class Dereference {
	    constructor(state, next = () => null) {
	        this.reset = (operand) => this._result.read(this._dereference, operand);
	        this._dereference = (value) => this._next(value, this._state);
	        this._result = new ResultImpl();
	        this._next = next;
	        this._state = state;
	        freezeImmutables(this);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Dereference.prototype, "reset", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Dereference.prototype, "_dereference", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Dereference.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], Dereference.prototype, "_state", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Function)
	], Dereference.prototype, "_next", void 0);
	const dereference = (state, next) => new Dereference(state, next);

	class Immediate {
	    constructor(state, next = () => null) {
	        this.reset = () => this._result.read(this._fetchOperand, this._state.p);
	        this._fetchOperand = (value) => {
	            this._operand = value;
	            this._state.p = (this._state.p + 1) & 0xffff;
	            return this._next(this._operand, this._state);
	        };
	        this._operand = 0;
	        this._result = new ResultImpl();
	        this._state = state;
	        this._next = next;
	        freezeImmutables(this);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Immediate.prototype, "reset", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Immediate.prototype, "_fetchOperand", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Immediate.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], Immediate.prototype, "_state", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Function)
	], Immediate.prototype, "_next", void 0);
	const immediate = (state, next) => new Immediate(state, next);

	class IndexedIndirectX {
	    constructor(state, next = () => null) {
	        this.reset = () => this._result.read(this._fetchAddress, this._state.p);
	        this._fetchAddress = (value) => {
	            this._address = value;
	            this._state.p = (this._state.p + 1) & 0xffff;
	            return this._result.read(this._addIndex, this._address);
	        };
	        this._addIndex = (value) => {
	            this._address = (this._address + this._state.x) & 0xff;
	            return this._result.read(this._fetchLo, this._address);
	        };
	        this._fetchLo = (value) => {
	            this._operand = value;
	            this._address = (this._address + 1) & 0xff;
	            return this._result.read(this._fetchHi, this._address);
	        };
	        this._fetchHi = (value) => {
	            this._operand |= value << 8;
	            return this._next(this._operand, this._state);
	        };
	        this._operand = 0;
	        this._address = 0;
	        this._result = new ResultImpl();
	        this._state = state;
	        this._next = next;
	        freezeImmutables(this);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], IndexedIndirectX.prototype, "reset", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], IndexedIndirectX.prototype, "_fetchAddress", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], IndexedIndirectX.prototype, "_addIndex", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], IndexedIndirectX.prototype, "_fetchLo", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], IndexedIndirectX.prototype, "_fetchHi", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], IndexedIndirectX.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], IndexedIndirectX.prototype, "_state", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Function)
	], IndexedIndirectX.prototype, "_next", void 0);
	const indexedIndirectX = (state, next) => new IndexedIndirectX(state, next);

	class IndexedIndirectY {
	    constructor(state, next = () => null, writeOp) {
	        this.reset = () => this._result.read(this._fetchAddress, this._state.p);
	        this._fetchAddress = (value) => {
	            this._address = value;
	            this._state.p = (this._state.p + 1) & 0xffff;
	            return this._result.read(this._fetchLo, this._address);
	        };
	        this._fetchLo = (value) => {
	            this._operand = value;
	            this._address = (this._address + 1) & 0xff;
	            return this._result.read(this._fetchHi, this._address);
	        };
	        this._fetchHi = (value) => {
	            this._operand |= value << 8;
	            this._carry = (this._operand & 0xff) + this._state.y > 0xff;
	            this._operand = (this._operand & 0xff00) | ((this._operand + this._state.y) & 0xff);
	            return this._carry || this._writeOp
	                ? this._result.read(this._dereferenceAndCarry, this._operand)
	                : this._next(this._operand, this._state);
	        };
	        this._dereferenceAndCarry = (value) => {
	            if (this._carry) {
	                this._operand = (this._operand + 0x0100) & 0xffff;
	            }
	            return this._next(this._operand, this._state);
	        };
	        this._operand = 0;
	        this._address = 0;
	        this._carry = false;
	        this._result = new ResultImpl();
	        this._state = state;
	        this._next = next;
	        this._writeOp = writeOp;
	        freezeImmutables(this);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], IndexedIndirectY.prototype, "reset", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], IndexedIndirectY.prototype, "_fetchAddress", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], IndexedIndirectY.prototype, "_fetchLo", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], IndexedIndirectY.prototype, "_fetchHi", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], IndexedIndirectY.prototype, "_dereferenceAndCarry", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], IndexedIndirectY.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], IndexedIndirectY.prototype, "_state", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Function)
	], IndexedIndirectY.prototype, "_next", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Boolean)
	], IndexedIndirectY.prototype, "_writeOp", void 0);
	const indirectIndexedY = (state, next, writeOp) => new IndexedIndirectY(state, next, writeOp);

	class ZeroPage {
	    constructor(state, next = () => null) {
	        this.reset = () => this._result.read(this._fetchAddress, this._state.p);
	        this._fetchAddress = (value) => {
	            this._operand = value;
	            this._state.p = (this._state.p + 1) & 0xffff;
	            return this._next(this._operand, this._state);
	        };
	        this._operand = 0;
	        this._result = new ResultImpl();
	        this._state = state;
	        this._next = next;
	        freezeImmutables(this);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], ZeroPage.prototype, "reset", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], ZeroPage.prototype, "_fetchAddress", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], ZeroPage.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], ZeroPage.prototype, "_state", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Function)
	], ZeroPage.prototype, "_next", void 0);
	const zeroPage = (state, next) => new ZeroPage(state, next);

	class ZeroPageIndexed {
	    constructor(state, indexExtractor, next) {
	        this.reset = () => this._result.read(this._fetchAddress, this._state.p);
	        this._fetchAddress = (value) => {
	            this._operand = value;
	            this._state.p = (this._state.p + 1) & 0xffff;
	            return this._result.read(this._addIndex, this._operand);
	        };
	        this._addIndex = (value) => {
	            this._operand = (this._operand + this._indexExtractor(this._state)) & 0xff;
	            return this._next(this._operand, this._state);
	        };
	        this._operand = 0;
	        this._result = new ResultImpl();
	        this._state = state;
	        this._indexExtractor = indexExtractor;
	        this._next = next;
	        freezeImmutables(this);
	    }
	    static zeroPageX(state, next = () => null) {
	        return new ZeroPageIndexed(state, s => s.x, next);
	    }
	    static zeroPageY(state, next = () => null) {
	        return new ZeroPageIndexed(state, s => s.y, next);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], ZeroPageIndexed.prototype, "reset", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], ZeroPageIndexed.prototype, "_fetchAddress", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], ZeroPageIndexed.prototype, "_addIndex", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], ZeroPageIndexed.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], ZeroPageIndexed.prototype, "_state", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Function)
	], ZeroPageIndexed.prototype, "_next", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Function)
	], ZeroPageIndexed.prototype, "_indexExtractor", void 0);
	const zeroPageX = (state, next) => ZeroPageIndexed.zeroPageX(state, next);
	const zeroPageY = (state, next) => ZeroPageIndexed.zeroPageY(state, next);

	class Branch {
	    constructor(state, predicate) {
	        this.reset = () => this._result.read(this._fetchTarget, this._state.p).poll(true);
	        this._fetchTarget = (value) => {
	            this._operand = value;
	            this._state.p = (this._state.p + 1) & 0xffff;
	            return this._predicate(this._state.flags) ? this._result.read(this._firstDummyRead, this._state.p) : null;
	        };
	        this._firstDummyRead = (value) => {
	            this._target = (this._state.p + (this._operand & 0x80 ? this._operand - 256 : this._operand)) & 0xffff;
	            if ((this._target & 0xff00) === (this._state.p & 0xff00)) {
	                this._state.p = this._target;
	                return null;
	            }
	            return this._result.read(this._secondDummyRead, (this._state.p & 0xff00) | (this._target & 0x00ff)).poll(true);
	        };
	        this._secondDummyRead = (value) => {
	            this._state.p = this._target;
	            return null;
	        };
	        this._target = 0;
	        this._operand = 0;
	        this._result = new ResultImpl();
	        this._state = state;
	        this._predicate = predicate;
	        freezeImmutables(this);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Branch.prototype, "reset", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Branch.prototype, "_fetchTarget", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Branch.prototype, "_firstDummyRead", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Branch.prototype, "_secondDummyRead", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Branch.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], Branch.prototype, "_state", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Function)
	], Branch.prototype, "_predicate", void 0);
	const branch = (state, predicate) => new Branch(state, predicate);

	class Jsr {
	    constructor(state) {
	        this.reset = () => this._result.read(this._fetchPcl, this._state.p);
	        this._fetchPcl = (value) => {
	            this._addressLo = value;
	            this._state.p = (this._state.p + 1) & 0xffff;
	            return this._result.read(this._dummyStackRead, 0x0100 + this._state.s);
	        };
	        this._dummyStackRead = () => this._result.write(this._pushPch, 0x0100 + this._state.s, this._state.p >>> 8);
	        this._pushPch = () => {
	            this._state.s = (this._state.s - 1) & 0xff;
	            return this._result.write(this._pushPcl, 0x0100 + this._state.s, this._state.p & 0xff);
	        };
	        this._pushPcl = () => {
	            this._state.s = (this._state.s - 1) & 0xff;
	            return this._result.read(this._fetchPch, this._state.p);
	        };
	        this._fetchPch = (value) => {
	            this._state.p = this._addressLo | (value << 8);
	            return null;
	        };
	        this._addressLo = 0;
	        this._result = new ResultImpl();
	        this._state = state;
	        freezeImmutables(this);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Jsr.prototype, "_fetchPcl", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Jsr.prototype, "_dummyStackRead", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Jsr.prototype, "_pushPch", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Jsr.prototype, "_pushPcl", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Jsr.prototype, "_fetchPch", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Jsr.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], Jsr.prototype, "_state", void 0);
	const jsr = (state) => new Jsr(state);

	class ReadModifyWrite {
	    constructor(state, operation) {
	        this.reset = (address) => {
	            this._address = address;
	            return this._result.read(this._read, address);
	        };
	        this._read = (value) => {
	            this._operand = value;
	            return this._result.write(this._dummyWrite, this._address, this._operand);
	        };
	        this._dummyWrite = (value) => this._result.write(this._write, this._address, this._operation(this._operand, this._state));
	        this._write = () => null;
	        this._result = new ResultImpl();
	        this._state = state;
	        this._operation = operation;
	        freezeImmutables(this);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], ReadModifyWrite.prototype, "reset", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], ReadModifyWrite.prototype, "_read", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], ReadModifyWrite.prototype, "_dummyWrite", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], ReadModifyWrite.prototype, "_write", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], ReadModifyWrite.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], ReadModifyWrite.prototype, "_state", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Function)
	], ReadModifyWrite.prototype, "_operation", void 0);
	const readModifyWrite = (state, operation) => new ReadModifyWrite(state, operation);

	class Rts {
	    constructor(state) {
	        this.reset = () => this._result.read(this._dummyOperandRead, this._state.p);
	        this._dummyOperandRead = () => this._result.read(this._dummyStackRead, 0x0100 + this._state.s);
	        this._dummyStackRead = () => {
	            this._state.s = (this._state.s + 1) & 0xff;
	            return this._result.read(this._popPcl, 0x0100 + this._state.s);
	        };
	        this._popPcl = (value) => {
	            this._state.p = (this._state.p & 0xff00) | value;
	            this._state.s = (this._state.s + 1) & 0xff;
	            return this._result.read(this._popPch, 0x0100 + this._state.s);
	        };
	        this._popPch = (value) => {
	            this._state.p = (this._state.p & 0xff) | (value << 8);
	            return this._result.read(this._incrementP, this._state.p);
	        };
	        this._incrementP = () => {
	            this._state.p = (this._state.p + 1) & 0xffff;
	            return null;
	        };
	        this._result = new ResultImpl();
	        this._state = state;
	        freezeImmutables(this);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Rts.prototype, "reset", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Rts.prototype, "_dummyOperandRead", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Rts.prototype, "_dummyStackRead", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Rts.prototype, "_popPcl", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Rts.prototype, "_popPch", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Rts.prototype, "_incrementP", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Rts.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], Rts.prototype, "_state", void 0);
	const rts = (state) => new Rts(state);

	class NullaryOneCycle {
	    constructor(state, operation) {
	        this.reset = () => this._result.read(this._executeOperation, this._state.p).poll(true);
	        this._executeOperation = () => {
	            this._operation(this._state);
	            return null;
	        };
	        this._result = new ResultImpl();
	        this._state = state;
	        this._operation = operation;
	        freezeImmutables(this);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], NullaryOneCycle.prototype, "reset", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], NullaryOneCycle.prototype, "_executeOperation", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], NullaryOneCycle.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], NullaryOneCycle.prototype, "_state", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Function)
	], NullaryOneCycle.prototype, "_operation", void 0);
	const nullaryOneCycle = (state, operation) => new NullaryOneCycle(state, operation);

	class Pull {
	    constructor(state, operation) {
	        this.reset = () => this._result.read(this._dummyRead, this._state.p).poll(true);
	        this._dummyRead = () => this._result.read(this._incrementS, 0x0100 + this._state.s);
	        this._incrementS = () => {
	            this._state.s = (this._state.s + 1) & 0xff;
	            return this._result.read(this._pull, 0x0100 + this._state.s);
	        };
	        this._pull = (value) => (this._operation(this._state, value), null);
	        this._result = new ResultImpl();
	        this._state = state;
	        this._operation = operation;
	        freezeImmutables(this);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Pull.prototype, "reset", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Pull.prototype, "_dummyRead", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Pull.prototype, "_incrementS", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Pull.prototype, "_pull", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Pull.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], Pull.prototype, "_state", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Function)
	], Pull.prototype, "_operation", void 0);
	const pull = (state, operation) => new Pull(state, operation);

	class Push {
	    constructor(state, operation) {
	        this.reset = () => this._result.read(this._dummyRead, this._state.p);
	        this._dummyRead = () => this._result.write(this._push, 0x0100 + this._state.s, this._operation(this._state));
	        this._push = () => {
	            this._state.s = (this._state.s - 1) & 0xff;
	            return null;
	        };
	        this._result = new ResultImpl();
	        this._state = state;
	        this._operation = operation;
	        freezeImmutables(this);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Push.prototype, "reset", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Push.prototype, "_dummyRead", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Push.prototype, "_push", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Push.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], Push.prototype, "_state", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Function)
	], Push.prototype, "_operation", void 0);
	const push = (state, operation) => new Push(state, operation);

	class Rti {
	    constructor(state) {
	        this.reset = () => this._result.read(this._dummyOperandRead, this._state.p);
	        this._dummyOperandRead = () => this._result.read(this._dummyStackRead, 0x0100 + this._state.s);
	        this._dummyStackRead = () => {
	            this._state.s = (this._state.s + 1) & 0xff;
	            return this._result.read(this._popP, 0x0100 + this._state.s);
	        };
	        this._popP = (value) => {
	            this._state.flags = (value | 32) & ~16;
	            this._state.s = (this._state.s + 1) & 0xff;
	            return this._result.read(this._popPcl, 0x0100 + this._state.s);
	        };
	        this._popPcl = (value) => {
	            this._state.p = (this._state.p & 0xff00) | value;
	            this._state.s = (this._state.s + 1) & 0xff;
	            return this._result.read(this._popPch, 0x0100 + this._state.s);
	        };
	        this._popPch = (value) => {
	            this._state.p = (this._state.p & 0xff) | (value << 8);
	            return null;
	        };
	        this._result = new ResultImpl();
	        this._state = state;
	        freezeImmutables(this);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Rti.prototype, "reset", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Rti.prototype, "_dummyOperandRead", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Rti.prototype, "_dummyStackRead", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Rti.prototype, "_popP", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Rti.prototype, "_popPcl", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Rti.prototype, "_popPch", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Rti.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], Rti.prototype, "_state", void 0);
	const rti = (state) => new Rti(state);

	class Write {
	    constructor(state, operation) {
	        this.reset = (operand) => this._result.write(() => null, operand, this._operation(this._state));
	        this._result = new ResultImpl();
	        this._state = state;
	        this._operation = operation;
	        freezeImmutables(this);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Write.prototype, "reset", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Write.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], Write.prototype, "_state", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Function)
	], Write.prototype, "_operation", void 0);
	const write = (state, operation) => new Write(state, operation);

	function setFlagsNZ(operand, state) {
	    state.flags =
	        (state.flags & ~(128 | 2)) |
	            (operand & 0x80) |
	            (operand ? 0 : 2);
	}
	function genRmw(operand, state, operation) {
	    const result = operation(operand);
	    setFlagsNZ(result, state);
	    return result;
	}
	function genNullary(state, operation) {
	    setFlagsNZ(operation(state), state);
	}
	function genUnary(operand, state, operation) {
	    setFlagsNZ(operation(operand, state), state);
	    return null;
	}
	function adc(operand, state) {
	    if (state.flags & 8) {
	        const d0 = (operand & 0x0f) + (state.a & 0x0f) + (state.flags & 1), d1 = (operand >>> 4) + (state.a >>> 4) + (d0 > 9 ? 1 : 0);
	        state.a = d0 % 10 | (d1 % 10 << 4);
	        state.flags =
	            (state.flags & ~(128 | 2 | 1)) |
	                (state.a & 0x80) |
	                (state.a ? 0 : 2) |
	                (d1 > 9 ? 1 : 0);
	    }
	    else {
	        const sum = state.a + operand + (state.flags & 1), result = sum & 0xff;
	        state.flags =
	            (state.flags &
	                ~(128 | 2 | 1 | 64)) |
	                (result & 0x80) |
	                (result ? 0 : 2) |
	                (sum >>> 8) |
	                ((~(operand ^ state.a) & (result ^ operand) & 0x80) >>> 1);
	        state.a = result;
	    }
	    return null;
	}
	function aslImmediate(state) {
	    const old = state.a;
	    state.a = (state.a << 1) & 0xff;
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (state.a & 0x80) |
	            (state.a ? 0 : 2) |
	            (old >>> 7);
	}
	function aslRmw(operand, state) {
	    const result = (operand << 1) & 0xff;
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (result & 0x80) |
	            (result ? 0 : 2) |
	            (operand >>> 7);
	    return result;
	}
	function bit(operand, state) {
	    state.flags =
	        (state.flags & ~(128 | 64 | 2)) |
	            (operand & (128 | 64)) |
	            (operand & state.a ? 0 : 2);
	    return null;
	}
	function cmp(operand, state, getRegister) {
	    const diff = getRegister(state) + (~operand & 0xff) + 1;
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (diff & 0x80) |
	            (diff & 0xff ? 0 : 2) |
	            (diff >>> 8);
	}
	function sbc(operand, state) {
	    if (state.flags & 8) {
	        const d0 = (state.a & 0x0f) - (operand & 0x0f) - (~state.flags & 1), d1 = (state.a >>> 4) - (operand >>> 4) - (d0 < 0 ? 1 : 0);
	        state.a = (d0 < 0 ? 10 + d0 : d0) | ((d1 < 0 ? 10 + d1 : d1) << 4);
	        state.flags =
	            (state.flags & ~(128 | 2 | 1)) |
	                (state.a & 0x80) |
	                (state.a ? 0 : 2) |
	                (d1 < 0 ? 0 : 1);
	    }
	    else {
	        operand = ~operand & 0xff;
	        const sum = state.a + operand + (state.flags & 1), result = sum & 0xff;
	        state.flags =
	            (state.flags &
	                ~(128 | 2 | 1 | 64)) |
	                (result & 0x80) |
	                (result ? 0 : 2) |
	                (sum >>> 8) |
	                ((~(operand ^ state.a) & (result ^ operand) & 0x80) >>> 1);
	        state.a = result;
	    }
	    return null;
	}
	function lsrImmediate(state) {
	    const old = state.a;
	    state.a = state.a >>> 1;
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (state.a & 0x80) |
	            (state.a ? 0 : 2) |
	            (old & 1);
	}
	function lsrRmw(operand, state) {
	    const result = operand >>> 1;
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (result & 0x80) |
	            (result ? 0 : 2) |
	            (operand & 1);
	    return result;
	}
	function rolImmediate(state) {
	    const old = state.a;
	    state.a = ((state.a << 1) & 0xff) | (state.flags & 1);
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (state.a & 0x80) |
	            (state.a ? 0 : 2) |
	            (old >>> 7);
	}
	function rolRmw(operand, state) {
	    const result = ((operand << 1) & 0xff) | (state.flags & 1);
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (result & 0x80) |
	            (result ? 0 : 2) |
	            (operand >>> 7);
	    return result;
	}
	function rorImmediate(state) {
	    const old = state.a;
	    state.a = (state.a >>> 1) | ((state.flags & 1) << 7);
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (state.a & 0x80) |
	            (state.a ? 0 : 2) |
	            (old & 1);
	}
	function rorRmw(operand, state) {
	    const result = (operand >>> 1) | ((state.flags & 1) << 7);
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (result & 0x80) |
	            (result ? 0 : 2) |
	            (operand & 1);
	    return result;
	}
	function arr(operand, state) {
	    state.a = ((state.a & operand) >>> 1) | (state.flags & 1 ? 0x80 : 0);
	    state.flags =
	        (state.flags & ~(1 | 128 | 2 | 64)) |
	            ((state.a & 0x40) >>> 6) |
	            (state.a ? 0 : 2) |
	            (state.a & 0x80) |
	            ((state.a & 0x40) ^ ((state.a & 0x20) << 1));
	}
	function alr(operand, state) {
	    const i = state.a & operand;
	    state.a = i >>> 1;
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (state.a & 0x80) |
	            (state.a ? 0 : 2) |
	            (i & 1);
	    return null;
	}
	function dcp(operand, state) {
	    const result = (operand + 0xff) & 0xff;
	    const diff = state.a + (~result & 0xff) + 1;
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (diff & 0x80) |
	            (diff & 0xff ? 0 : 2) |
	            (diff >>> 8);
	    return result;
	}
	function axs(operand, state) {
	    const value = (state.a & state.x) + (~operand & 0xff) + 1;
	    state.x = value & 0xff;
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (state.x & 0x80) |
	            (state.x & 0xff ? 0 : 2) |
	            (value >>> 8);
	    return null;
	}
	function rra(operand, state) {
	    const result = (operand >>> 1) | ((state.flags & 1) << 7);
	    state.flags = (state.flags & ~1) | (operand & 1);
	    adc(result, state);
	    return result;
	}
	function rla(operand, state) {
	    const result = ((operand << 1) & 0xff) | (state.flags & 1);
	    state.flags = (state.flags & ~1) | (operand >>> 7);
	    setFlagsNZ((state.a &= result), state);
	    return result;
	}
	function slo(operand, state) {
	    state.flags = (state.flags & ~1) | (operand >>> 7);
	    const result = (operand << 1) & 0xff;
	    state.a = state.a | result;
	    setFlagsNZ(state.a, state);
	    return result;
	}
	function aax(state) {
	    const result = state.a & state.x;
	    setFlagsNZ(result, state);
	    return result;
	}
	function isc(operand, state) {
	    const result = (operand + 1) & 0xff;
	    sbc(result, state);
	    return result;
	}
	function aac(operand, state) {
	    state.a &= operand;
	    setFlagsNZ(state.a, state);
	    state.flags = (state.flags & ~1) | ((state.a & 0x80) >>> 7);
	    return null;
	}

	class Indirect {
	    constructor(state, next = () => null) {
	        this.reset = () => this._result.read(this._fetchAddressLo, this._state.p);
	        this._fetchAddressLo = (value) => {
	            this._address = value;
	            this._state.p = (this._state.p + 1) & 0xffff;
	            return this._result.read(this._fetchAddressHi, this._state.p);
	        };
	        this._fetchAddressHi = (value) => {
	            this._address |= value << 8;
	            this._state.p = (this._state.p + 1) & 0xffff;
	            return this._result.read(this._fetchLo, this._address);
	        };
	        this._fetchLo = (value) => {
	            this._operand = value;
	            if ((this._address & 0xff) === 0xff) {
	                this._address &= 0xff00;
	            }
	            else {
	                this._address = (this._address + 1) & 0xffff;
	            }
	            return this._result.read(this._fetchHi, this._address);
	        };
	        this._fetchHi = (value) => {
	            this._operand |= value << 8;
	            return this._next(this._operand, this._state);
	        };
	        this._operand = 0;
	        this._address = 0;
	        this._result = new ResultImpl();
	        this._state = state;
	        this._next = next;
	        freezeImmutables(this);
	    }
	}
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Indirect.prototype, "reset", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Indirect.prototype, "_fetchAddressLo", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Indirect.prototype, "_fetchAddressHi", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Indirect.prototype, "_fetchLo", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Indirect.prototype, "_fetchHi", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Object)
	], Indirect.prototype, "_result", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", CpuInterface.State)
	], Indirect.prototype, "_state", void 0);
	__decorate([
	    Immutable,
	    __metadata("design:type", Function)
	], Indirect.prototype, "_next", void 0);
	const indirect = (state, next) => new Indirect(state, next);

	class Compiler {
	    constructor(_state) {
	        this._state = _state;
	    }
	    compile(op) {
	        const instruction = Instruction.opcodes[op];
	        switch (instruction.operation) {
	            case 0:
	                return this._createAddressing(instruction.addressingMode, adc, {
	                    deref: true
	                });
	            case 1:
	                return this._createAddressing(instruction.addressingMode, (o, s) => genUnary(o, s, (operand, state) => (state.a = state.a & operand)), {
	                    deref: true
	                });
	            case 2:
	                return instruction.addressingMode === 0
	                    ? nullaryOneCycle(this._state, aslImmediate)
	                    : this._createAddressing(instruction.addressingMode, readModifyWrite(this._state, aslRmw).reset, { writeOp: true });
	            case 6:
	                return this._createAddressing(instruction.addressingMode, bit, {
	                    deref: true
	                });
	            case 10:
	                return brk(this._state);
	            case 17:
	                return this._createAddressing(instruction.addressingMode, (o, s) => (cmp(o, s, state => state.a), null), {
	                    deref: true
	                });
	            case 18:
	                return this._createAddressing(instruction.addressingMode, (o, s) => (cmp(o, s, state => state.x), null), {
	                    deref: true
	                });
	            case 19:
	                return this._createAddressing(instruction.addressingMode, (o, s) => (cmp(o, s, state => state.y), null), {
	                    deref: true
	                });
	            case 20:
	                return this._createAddressing(instruction.addressingMode, readModifyWrite(this._state, (s, o) => genRmw(s, o, x => (x - 1) & 0xff)).reset, {
	                    writeOp: true
	                });
	            case 21:
	                return nullaryOneCycle(this._state, s => genNullary(s, state => (state.x = (state.x - 1) & 0xff)));
	            case 22:
	                return nullaryOneCycle(this._state, s => genNullary(s, state => (state.y = (state.y - 1) & 0xff)));
	            case 24:
	                return this._createAddressing(instruction.addressingMode, readModifyWrite(this._state, (s, o) => genRmw(s, o, x => (x + 1) & 0xff)).reset, {
	                    writeOp: true
	                });
	            case 25:
	                return nullaryOneCycle(this._state, s => genNullary(s, state => (state.x = (state.x + 1) & 0xff)));
	            case 26:
	                return nullaryOneCycle(this._state, s => genNullary(s, state => (state.y = (state.y + 1) & 0xff)));
	            case 23:
	                return this._createAddressing(instruction.addressingMode, (o, s) => genUnary(o, s, (operand, state) => (state.a = state.a ^ operand)), {
	                    deref: true
	                });
	            case 27:
	                return this._createAddressing(instruction.addressingMode, (o, s) => ((s.p = o), null));
	            case 28:
	                return jsr(this._state);
	            case 29:
	                return this._createAddressing(instruction.addressingMode, (o, s) => genUnary(o, s, (operand, state) => (state.a = operand)), {
	                    deref: true
	                });
	            case 30:
	                return this._createAddressing(instruction.addressingMode, (o, s) => genUnary(o, s, (operand, state) => (state.x = operand)), {
	                    deref: true
	                });
	            case 31:
	                return this._createAddressing(instruction.addressingMode, (o, s) => genUnary(o, s, (operand, state) => (state.y = operand)), {
	                    deref: true
	                });
	            case 32:
	                return instruction.addressingMode === 0
	                    ? nullaryOneCycle(this._state, lsrImmediate)
	                    : this._createAddressing(instruction.addressingMode, readModifyWrite(this._state, lsrRmw).reset, { writeOp: true });
	            case 33:
	                return nullaryOneCycle(this._state, () => undefined);
	            case 34:
	                return this._createAddressing(instruction.addressingMode, (o, s) => genUnary(o, s, (operand, state) => (state.a |= operand)), { deref: true });
	            case 35:
	                return push(this._state, s => s.a);
	            case 36:
	                return push(this._state, s => s.flags | 16);
	            case 37:
	                return pull(this._state, (s, o) => genNullary(s, state => (state.a = o)));
	            case 38:
	                return pull(this._state, (s, o) => (s.flags = (o | 32) & ~16));
	            case 39:
	                return instruction.addressingMode === 0
	                    ? nullaryOneCycle(this._state, rolImmediate)
	                    : this._createAddressing(instruction.addressingMode, readModifyWrite(this._state, rolRmw).reset, { writeOp: true });
	            case 40:
	                return instruction.addressingMode === 0
	                    ? nullaryOneCycle(this._state, rorImmediate)
	                    : this._createAddressing(instruction.addressingMode, readModifyWrite(this._state, rorRmw).reset, { writeOp: true });
	            case 41:
	                return rti(this._state);
	            case 42:
	                return rts(this._state);
	            case 43:
	                return this._createAddressing(instruction.addressingMode, sbc, {
	                    deref: true
	                });
	            case 48:
	                return this._createAddressing(instruction.addressingMode, write(this._state, s => s.x).reset, {
	                    writeOp: true
	                });
	            case 49:
	                return this._createAddressing(instruction.addressingMode, write(this._state, s => s.y).reset, {
	                    writeOp: true
	                });
	            case 50:
	                return nullaryOneCycle(this._state, s => genNullary(s, state => (state.x = state.a)));
	            case 51:
	                return nullaryOneCycle(this._state, s => genNullary(s, state => (state.y = state.a)));
	            case 52:
	                return nullaryOneCycle(this._state, s => genNullary(s, state => (state.x = state.s)));
	            case 53:
	                return nullaryOneCycle(this._state, s => genNullary(s, state => (state.a = state.x)));
	            case 54:
	                return nullaryOneCycle(this._state, s => (s.s = s.x));
	            case 55:
	                return nullaryOneCycle(this._state, s => genNullary(s, state => (state.a = state.y)));
	            case 3:
	                return branch(this._state, flags => (flags & 1) === 0);
	            case 4:
	                return branch(this._state, flags => (flags & 1) > 0);
	            case 8:
	                return branch(this._state, flags => (flags & 2) === 0);
	            case 5:
	                return branch(this._state, flags => (flags & 2) > 0);
	            case 9:
	                return branch(this._state, flags => (flags & 128) === 0);
	            case 7:
	                return branch(this._state, flags => (flags & 128) > 0);
	            case 11:
	                return branch(this._state, flags => (flags & 64) === 0);
	            case 12:
	                return branch(this._state, flags => (flags & 64) > 0);
	            case 44:
	                return nullaryOneCycle(this._state, s => (s.flags |= 1));
	            case 45:
	                return nullaryOneCycle(this._state, s => (s.flags |= 8));
	            case 46:
	                return nullaryOneCycle(this._state, s => (s.flags |= 4));
	            case 47:
	                return this._createAddressing(instruction.addressingMode, write(this._state, s => s.a).reset, {
	                    writeOp: true
	                });
	            case 13:
	                return nullaryOneCycle(this._state, s => (s.flags &= ~1));
	            case 14:
	                return nullaryOneCycle(this._state, s => (s.flags &= ~8));
	            case 15:
	                return nullaryOneCycle(this._state, s => (s.flags &= ~4));
	            case 16:
	                return nullaryOneCycle(this._state, s => (s.flags &= ~64));
	            case 56:
	            case 57:
	                return this._createAddressing(instruction.addressingMode, () => null, { deref: true });
	            case 67:
	                return this._createAddressing(instruction.addressingMode, aac);
	            case 64:
	                return this._createAddressing(instruction.addressingMode, write(this._state, aax).reset, {
	                    writeOp: true
	                });
	            case 58:
	                return this._createAddressing(instruction.addressingMode, alr, {
	                    deref: true
	                });
	            case 62:
	                return this._createAddressing(instruction.addressingMode, (o, s) => (arr(o, s), null), {
	                    deref: true
	                });
	            case 59:
	                return this._createAddressing(instruction.addressingMode, axs, {
	                    deref: true
	                });
	            case 68:
	                return this._createAddressing(instruction.addressingMode, (o, s) => genUnary(o, s, (operand, state) => (state.x = state.a = state.a & operand)), {
	                    deref: true
	                });
	            case 60:
	                return this._createAddressing(instruction.addressingMode, readModifyWrite(this._state, dcp).reset, {
	                    writeOp: true
	                });
	            case 66:
	                return this._createAddressing(instruction.addressingMode, readModifyWrite(this._state, isc).reset, {
	                    writeOp: true
	                });
	            case 61:
	                return this._createAddressing(instruction.addressingMode, (o, s) => genUnary(o, s, (operand, state) => (state.a = state.x = operand)), {
	                    deref: true
	                });
	            case 65:
	                return this._createAddressing(instruction.addressingMode, (o, s) => genUnary(o, s, (operand, state) => (state.s = state.x = state.a = state.s & operand)), { deref: true });
	            case 70:
	                return this._createAddressing(instruction.addressingMode, readModifyWrite(this._state, rla).reset, {
	                    writeOp: true
	                });
	            case 69:
	                return this._createAddressing(instruction.addressingMode, readModifyWrite(this._state, rra).reset, {
	                    writeOp: true
	                });
	            case 63:
	                return this._createAddressing(instruction.addressingMode, readModifyWrite(this._state, slo).reset, {
	                    writeOp: true
	                });
	            default:
	                return null;
	        }
	    }
	    _createAddressing(addressingMode, next, { deref = false, writeOp = false } = {}) {
	        if (deref && addressingMode !== 1) {
	            next = dereference(this._state, next).reset;
	        }
	        switch (addressingMode) {
	            case 1:
	                return immediate(this._state, next);
	            case 2:
	                return zeroPage(this._state, next);
	            case 3:
	                return absolute(this._state, next);
	            case 6:
	                return zeroPageX(this._state, next);
	            case 9:
	                return zeroPageY(this._state, next);
	            case 7:
	                return absoluteX(this._state, next, writeOp);
	            case 10:
	                return absoluteY(this._state, next, writeOp);
	            case 8:
	                return indexedIndirectX(this._state, next);
	            case 11:
	                return indirectIndexedY(this._state, next, writeOp);
	            case 4:
	                return indirect(this._state, next);
	            default:
	                throw new Error(`invalid addressing mode ${addressingMode}`);
	        }
	    }
	}

	class StateMachineCpu {
	    constructor(_bus, _rng) {
	        this._bus = _bus;
	        this._rng = _rng;
	        this.executionState = 0;
	        this.state = new CpuInterface.State();
	        this._invalidInstructionCallback = null;
	        this._interruptPending = false;
	        this._nmiPending = false;
	        this._halt = false;
	        this._pollInterruptsAfterLastInstruction = false;
	        this._lastInstructionPointer = 0;
	        this._operations = new Array(255);
	        this._opBoot = boot(this.state);
	        this._opIrq = irq(this.state);
	        this._opNmi = nmi(this.state);
	        const compiler = new Compiler(this.state);
	        for (let op = 0; op < 256; op++) {
	            this._operations[op] = compiler.compile(op);
	        }
	        this.reset();
	    }
	    reset() {
	        this.state.a = this._rng ? this._rng.int(0xff) : 0;
	        this.state.x = this._rng ? this._rng.int(0xff) : 0;
	        this.state.y = this._rng ? this._rng.int(0xff) : 0;
	        this.state.s = 0xfd;
	        this.state.p = this._rng ? this._rng.int(0xffff) : 0;
	        this.state.flags =
	            (this._rng ? this._rng.int(0xff) : 0) | 4 | 32 | 16;
	        this.state.irq = false;
	        this.state.nmi = false;
	        this.executionState = 0;
	        this._interruptPending = false;
	        this._nmiPending = false;
	        this._halt = false;
	        this._lastResult = this._opBoot.reset(undefined);
	        this._lastInstructionPointer = 0;
	        return this;
	    }
	    setInterrupt(i) {
	        this._interruptPending = i;
	        return this;
	    }
	    isInterrupt() {
	        return this._interruptPending;
	    }
	    nmi() {
	        this._nmiPending = true;
	        return this;
	    }
	    halt() {
	        this._halt = true;
	        return this;
	    }
	    resume() {
	        this._halt = false;
	        return this;
	    }
	    isHalt() {
	        return this._halt;
	    }
	    setInvalidInstructionCallback(callback) {
	        this._invalidInstructionCallback = callback;
	        return this;
	    }
	    getInvalidInstructionCallback() {
	        return this._invalidInstructionCallback;
	    }
	    getLastInstructionPointer() {
	        return this._lastInstructionPointer;
	    }
	    cycle() {
	        if (this._halt && (!this._lastResult || this._lastResult.cycleType === 0)) {
	            return this;
	        }
	        if (this.executionState === 1) {
	            this._fetch();
	            return this;
	        }
	        let value;
	        switch (this._lastResult.cycleType) {
	            case 0:
	                value = this._bus.read(this._lastResult.address);
	                break;
	            case 1:
	                value = this._lastResult.value;
	                this._bus.write(this._lastResult.address, value);
	                break;
	            default:
	                throw new Error('invalid cycle type');
	        }
	        if (this._lastResult.pollInterrupts) {
	            this._pollInterrupts();
	            this._lastResult.pollInterrupts = false;
	            this._pollInterruptsAfterLastInstruction = false;
	        }
	        this._lastResult = this._lastResult.nextStep(value);
	        if (this._lastResult === null) {
	            this.executionState = 1;
	        }
	        return this;
	    }
	    _fetch() {
	        if (this._pollInterruptsAfterLastInstruction) {
	            this._pollInterrupts();
	        }
	        this._lastInstructionPointer = this.state.p;
	        let operation;
	        const opcode = this._bus.read(this.state.p);
	        if (this.state.nmi) {
	            operation = this._opNmi;
	            this._pollInterruptsAfterLastInstruction = false;
	        }
	        else if (this.state.irq) {
	            operation = this._opIrq;
	            this._pollInterruptsAfterLastInstruction = false;
	        }
	        else {
	            operation = this._operations[opcode];
	            this.state.p = (this.state.p + 1) & 0xffff;
	            this._pollInterruptsAfterLastInstruction = true;
	        }
	        if (!operation) {
	            if (this._invalidInstructionCallback) {
	                this._invalidInstructionCallback(this);
	            }
	            return;
	        }
	        this.executionState = 2;
	        this._lastResult = operation.reset(undefined);
	    }
	    _pollInterrupts() {
	        this.state.irq = false;
	        if (this._nmiPending) {
	            this.state.nmi = true;
	            this._nmiPending = false;
	            return;
	        }
	        if (this._interruptPending && !this.state.nmi && !(this.state.flags & 4)) {
	            this.state.irq = true;
	        }
	    }
	}

	function restoreFlagsFromStack(state, bus) {
	    state.s = (state.s + 0x01) & 0xff;
	    state.flags = (bus.read(0x0100 + state.s) | 32) & ~16;
	}
	function setFlagsNZ$1(state, operand) {
	    state.flags =
	        (state.flags & ~(128 | 2)) |
	            (operand & 0x80) |
	            (operand ? 0 : 2);
	}
	function opAdc(state, bus, operand) {
	    if (state.flags & 8) {
	        const d0 = (operand & 0x0f) + (state.a & 0x0f) + (state.flags & 1), d1 = (operand >>> 4) + (state.a >>> 4) + (d0 > 9 ? 1 : 0);
	        state.a = d0 % 10 | (d1 % 10 << 4);
	        state.flags =
	            (state.flags & ~(128 | 2 | 1)) |
	                (state.a & 0x80) |
	                (state.a ? 0 : 2) |
	                (d1 > 9 ? 1 : 0);
	    }
	    else {
	        const sum = state.a + operand + (state.flags & 1), result = sum & 0xff;
	        state.flags =
	            (state.flags &
	                ~(128 | 2 | 1 | 64)) |
	                (result & 0x80) |
	                (result ? 0 : 2) |
	                (sum >>> 8) |
	                ((~(operand ^ state.a) & (result ^ operand) & 0x80) >>> 1);
	        state.a = result;
	    }
	}
	function opAnd(state, bus, operand) {
	    state.a &= operand;
	    setFlagsNZ$1(state, state.a);
	}
	function opAslAcc(state) {
	    const old = state.a;
	    state.a = (state.a << 1) & 0xff;
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (state.a & 0x80) |
	            (state.a ? 0 : 2) |
	            (old >>> 7);
	}
	function opAslMem(state, bus, operand) {
	    const old = bus.read(operand), value = (old << 1) & 0xff;
	    bus.write(operand, value);
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (value & 0x80) |
	            (value ? 0 : 2) |
	            (old >>> 7);
	}
	function opBit(state, bus, operand) {
	    state.flags =
	        (state.flags & ~(128 | 64 | 2)) |
	            (operand & (128 | 64)) |
	            (operand & state.a ? 0 : 2);
	}
	function opBrk(state, bus) {
	    const nextOpAddr = (state.p + 1) & 0xffff;
	    let vector = 0xfffe;
	    if (state.nmi) {
	        vector = 0xfffa;
	        state.nmi = false;
	    }
	    state.nmi = state.irq = false;
	    bus.write(state.s + 0x0100, (nextOpAddr >>> 8) & 0xff);
	    state.s = (state.s + 0xff) & 0xff;
	    bus.write(state.s + 0x0100, nextOpAddr & 0xff);
	    state.s = (state.s + 0xff) & 0xff;
	    bus.write(state.s + 0x0100, state.flags | 16);
	    state.s = (state.s + 0xff) & 0xff;
	    state.flags |= 4;
	    state.p = bus.readWord(vector);
	}
	function opClc(state) {
	    state.flags &= ~1;
	}
	function opCld(state) {
	    state.flags &= ~8;
	}
	function opCli(state) {
	    state.flags &= ~4;
	}
	function opClv(state) {
	    state.flags &= ~64;
	}
	function opCmp(state, bus, operand) {
	    const diff = state.a + (~operand & 0xff) + 1;
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (diff & 0x80) |
	            (diff & 0xff ? 0 : 2) |
	            (diff >>> 8);
	}
	function opCpx(state, bus, operand) {
	    const diff = state.x + (~operand & 0xff) + 1;
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (diff & 0x80) |
	            (diff & 0xff ? 0 : 2) |
	            (diff >>> 8);
	}
	function opCpy(state, bus, operand) {
	    const diff = state.y + (~operand & 0xff) + 1;
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (diff & 0x80) |
	            (diff & 0xff ? 0 : 2) |
	            (diff >>> 8);
	}
	function opDec(state, bus, operand) {
	    const value = (bus.read(operand) + 0xff) & 0xff;
	    bus.write(operand, value);
	    setFlagsNZ$1(state, value);
	}
	function opDex(state) {
	    state.x = (state.x + 0xff) & 0xff;
	    setFlagsNZ$1(state, state.x);
	}
	function opEor(state, bus, operand) {
	    state.a = state.a ^ operand;
	    setFlagsNZ$1(state, state.a);
	}
	function opDey(state) {
	    state.y = (state.y + 0xff) & 0xff;
	    setFlagsNZ$1(state, state.y);
	}
	function opInc(state, bus, operand) {
	    const value = (bus.read(operand) + 1) & 0xff;
	    bus.write(operand, value);
	    setFlagsNZ$1(state, value);
	}
	function opInx(state) {
	    state.x = (state.x + 0x01) & 0xff;
	    setFlagsNZ$1(state, state.x);
	}
	function opIny(state) {
	    state.y = (state.y + 0x01) & 0xff;
	    setFlagsNZ$1(state, state.y);
	}
	function opJmp(state, bus, operand) {
	    state.p = operand;
	}
	function opJsr(state, bus, operand) {
	    const returnPtr = (state.p + 1) & 0xffff, addrLo = bus.read(state.p);
	    bus.read(0x0100 + state.s);
	    bus.write(0x0100 + state.s, returnPtr >>> 8);
	    state.s = (state.s + 0xff) & 0xff;
	    bus.write(0x0100 + state.s, returnPtr & 0xff);
	    state.s = (state.s + 0xff) & 0xff;
	    state.p = addrLo | (bus.read((state.p + 1) & 0xffff) << 8);
	}
	function opLda(state, bus, operand, addressingMode) {
	    state.a = addressingMode === 1 ? operand : bus.read(operand);
	    setFlagsNZ$1(state, state.a);
	}
	function opLdx(state, bus, operand, addressingMode) {
	    state.x = addressingMode === 1 ? operand : bus.read(operand);
	    setFlagsNZ$1(state, state.x);
	}
	function opLdy(state, bus, operand, addressingMode) {
	    state.y = addressingMode === 1 ? operand : bus.read(operand);
	    setFlagsNZ$1(state, state.y);
	}
	function opLsrAcc(state) {
	    const old = state.a;
	    state.a = state.a >>> 1;
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (state.a & 0x80) |
	            (state.a ? 0 : 2) |
	            (old & 1);
	}
	function opLsrMem(state, bus, operand) {
	    const old = bus.read(operand), value = old >>> 1;
	    bus.write(operand, value);
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (value & 0x80) |
	            (value ? 0 : 2) |
	            (old & 1);
	}
	function opNop() { }
	function opOra(state, bus, operand) {
	    state.a |= operand;
	    setFlagsNZ$1(state, state.a);
	}
	function opPhp(state, bus) {
	    bus.write(0x0100 + state.s, state.flags | 16);
	    state.s = (state.s + 0xff) & 0xff;
	}
	function opPlp(state, bus) {
	    restoreFlagsFromStack(state, bus);
	}
	function opPha(state, bus) {
	    bus.write(0x0100 + state.s, state.a);
	    state.s = (state.s + 0xff) & 0xff;
	}
	function opPla(state, bus) {
	    state.s = (state.s + 0x01) & 0xff;
	    state.a = bus.read(0x0100 + state.s);
	    setFlagsNZ$1(state, state.a);
	}
	function opRolAcc(state) {
	    const old = state.a;
	    state.a = ((state.a << 1) & 0xff) | (state.flags & 1);
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (state.a & 0x80) |
	            (state.a ? 0 : 2) |
	            (old >>> 7);
	}
	function opRolMem(state, bus, operand) {
	    const old = bus.read(operand), value = ((old << 1) & 0xff) | (state.flags & 1);
	    bus.write(operand, value);
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (value & 0x80) |
	            (value ? 0 : 2) |
	            (old >>> 7);
	}
	function opRorAcc(state) {
	    const old = state.a;
	    state.a = (state.a >>> 1) | ((state.flags & 1) << 7);
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (state.a & 0x80) |
	            (state.a ? 0 : 2) |
	            (old & 1);
	}
	function opRorMem(state, bus, operand) {
	    const old = bus.read(operand), value = (old >>> 1) | ((state.flags & 1) << 7);
	    bus.write(operand, value);
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (value & 0x80) |
	            (value ? 0 : 2) |
	            (old & 1);
	}
	function opRti(state, bus) {
	    let returnPtr;
	    restoreFlagsFromStack(state, bus);
	    state.s = (state.s + 1) & 0xff;
	    returnPtr = bus.read(0x0100 + state.s);
	    state.s = (state.s + 1) & 0xff;
	    returnPtr |= bus.read(0x0100 + state.s) << 8;
	    state.p = returnPtr;
	}
	function opRts(state, bus) {
	    let returnPtr;
	    bus.read(0x0100 + state.s);
	    state.s = (state.s + 1) & 0xff;
	    returnPtr = bus.read(0x0100 + state.s);
	    state.s = (state.s + 1) & 0xff;
	    returnPtr += bus.read(0x0100 + state.s) << 8;
	    state.p = (returnPtr + 1) & 0xffff;
	}
	function opSbc(state, bus, operand) {
	    if (state.flags & 8) {
	        const d0 = (state.a & 0x0f) - (operand & 0x0f) - (~state.flags & 1), d1 = (state.a >>> 4) - (operand >>> 4) - (d0 < 0 ? 1 : 0);
	        state.a = (d0 < 0 ? 10 + d0 : d0) | ((d1 < 0 ? 10 + d1 : d1) << 4);
	        state.flags =
	            (state.flags & ~(128 | 2 | 1)) |
	                (state.a & 0x80) |
	                (state.a ? 0 : 2) |
	                (d1 < 0 ? 0 : 1);
	    }
	    else {
	        operand = ~operand & 0xff;
	        const sum = state.a + operand + (state.flags & 1), result = sum & 0xff;
	        state.flags =
	            (state.flags &
	                ~(128 | 2 | 1 | 64)) |
	                (result & 0x80) |
	                (result ? 0 : 2) |
	                (sum >>> 8) |
	                ((~(operand ^ state.a) & (result ^ operand) & 0x80) >>> 1);
	        state.a = result;
	    }
	}
	function opSec(state) {
	    state.flags |= 1;
	}
	function opSed(state) {
	    state.flags |= 8;
	}
	function opSei(state) {
	    state.flags |= 4;
	}
	function opSta(state, bus, operand) {
	    bus.write(operand, state.a);
	}
	function opStx(state, bus, operand) {
	    bus.write(operand, state.x);
	}
	function opSty(state, bus, operand) {
	    bus.write(operand, state.y);
	}
	function opTax(state) {
	    state.x = state.a;
	    setFlagsNZ$1(state, state.a);
	}
	function opTay(state) {
	    state.y = state.a;
	    setFlagsNZ$1(state, state.a);
	}
	function opTsx(state) {
	    state.x = state.s;
	    setFlagsNZ$1(state, state.x);
	}
	function opTxa(state) {
	    state.a = state.x;
	    setFlagsNZ$1(state, state.a);
	}
	function opTxs(state) {
	    state.s = state.x;
	}
	function opTya(state) {
	    state.a = state.y;
	    setFlagsNZ$1(state, state.a);
	}
	function opAlr(state, bus, operand) {
	    const i = state.a & operand;
	    state.a = i >>> 1;
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (state.a & 0x80) |
	            (state.a ? 0 : 2) |
	            (i & 1);
	}
	function opAxs(state, bus, operand) {
	    const value = (state.a & state.x) + (~operand & 0xff) + 1;
	    state.x = value & 0xff;
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (state.x & 0x80) |
	            (state.x & 0xff ? 0 : 2) |
	            (value >>> 8);
	}
	function opDcp(state, bus, operand) {
	    const value = (bus.read(operand) + 0xff) & 0xff;
	    bus.write(operand, value);
	    const diff = state.a + (~value & 0xff) + 1;
	    state.flags =
	        (state.flags & ~(128 | 2 | 1)) |
	            (diff & 0x80) |
	            (diff & 0xff ? 0 : 2) |
	            (diff >>> 8);
	}
	function opLax(state, bus, operand) {
	    state.a = operand;
	    state.x = operand;
	    setFlagsNZ$1(state, operand);
	}
	function opArr(state, bus, operand) {
	    state.a = ((state.a & operand) >>> 1) | (state.flags & 1 ? 0x80 : 0);
	    state.flags =
	        (state.flags & ~(1 | 128 | 2 | 64)) |
	            ((state.a & 0x40) >>> 6) |
	            (state.a ? 0 : 2) |
	            (state.a & 0x80) |
	            ((state.a & 0x40) ^ ((state.a & 0x20) << 1));
	}
	function opSlo(state, bus, operand) {
	    let value = bus.read(operand);
	    state.flags = (state.flags & ~1) | (value >>> 7);
	    value = (value << 1) & 0xff;
	    bus.write(operand, value);
	    state.a = state.a | value;
	    setFlagsNZ$1(state, state.a);
	}
	function opAax(state, bus, operand) {
	    const value = state.x & state.a;
	    bus.write(operand, value);
	    setFlagsNZ$1(state, value);
	}
	function opLar(state, bus, operand) {
	    state.s = state.a = state.x = state.s & operand;
	    setFlagsNZ$1(state, state.a);
	}
	function opIsc(state, bus, operand) {
	    const value = (bus.read(operand) + 1) & 0xff;
	    bus.write(operand, value);
	    opSbc(state, bus, value);
	}
	function opAac(state, bus, operand) {
	    state.a &= operand;
	    setFlagsNZ$1(state, state.a);
	    state.flags = (state.flags & ~1) | ((state.a & 0x80) >>> 7);
	}
	function opAtx(state, bus, operand) {
	    state.a &= operand;
	    state.x = state.a;
	    setFlagsNZ$1(state, state.a);
	}
	function opRra(state, bus, operand) {
	    const old = bus.read(operand), value = (old >>> 1) | ((state.flags & 1) << 7);
	    bus.write(operand, value);
	    state.flags = (state.flags & ~1) | (old & 1);
	    opAdc(state, bus, value);
	}
	function opRla(state, bus, operand) {
	    const old = bus.read(operand), value = ((old << 1) & 0xff) | (state.flags & 1);
	    bus.write(operand, value);
	    state.flags = (state.flags & ~1) | (old >>> 7);
	    opAnd(state, bus, value);
	}

	function opBoot(state, bus) {
	    state.p = bus.readWord(0xfffc);
	}
	function dispatchInterrupt(state, bus, vector) {
	    const nextOpAddr = state.p;
	    if (state.nmi) {
	        vector = 0xfffa;
	    }
	    state.nmi = state.irq = false;
	    bus.write(state.s + 0x0100, (nextOpAddr >>> 8) & 0xff);
	    state.s = (state.s + 0xff) & 0xff;
	    bus.write(state.s + 0x0100, nextOpAddr & 0xff);
	    state.s = (state.s + 0xff) & 0xff;
	    bus.write(state.s + 0x0100, state.flags & ~16);
	    state.s = (state.s + 0xff) & 0xff;
	    state.flags |= 4;
	    state.p = bus.readWord(vector);
	}
	function opIrq(state, bus) {
	    dispatchInterrupt(state, bus, 0xfffe);
	}
	function opNmi(state, bus) {
	    dispatchInterrupt(state, bus, 0xfffa);
	}
	class BatchedAccessCpu {
	    constructor(_bus, _rng) {
	        this._bus = _bus;
	        this._rng = _rng;
	        this.executionState = 0;
	        this.state = new CpuInterface.State();
	        this._opCycles = 0;
	        this._instructionCallback = null;
	        this._invalidInstructionCallback = null;
	        this._interruptPending = false;
	        this._nmiPending = false;
	        this._interuptCheck = 0;
	        this._halted = false;
	        this._operand = 0;
	        this._lastInstructionPointer = 0;
	        this._currentAddressingMode = 12;
	        this._dereference = false;
	        this.reset();
	    }
	    setInterrupt(irq) {
	        this._interruptPending = irq;
	        return this;
	    }
	    isInterrupt() {
	        return this._interruptPending;
	    }
	    nmi() {
	        this._nmiPending = true;
	        return this;
	    }
	    halt() {
	        this._halted = true;
	        return this;
	    }
	    resume() {
	        this._halted = false;
	        return this;
	    }
	    isHalt() {
	        return this._halted;
	    }
	    setInvalidInstructionCallback(callback) {
	        this._invalidInstructionCallback = callback;
	        return this;
	    }
	    getInvalidInstructionCallback() {
	        return this._invalidInstructionCallback;
	    }
	    getLastInstructionPointer() {
	        return this._lastInstructionPointer;
	    }
	    reset() {
	        this.state.a = this._rng ? this._rng.int(0xff) : 0;
	        this.state.x = this._rng ? this._rng.int(0xff) : 0;
	        this.state.y = this._rng ? this._rng.int(0xff) : 0;
	        this.state.s = 0xfd;
	        this.state.p = this._rng ? this._rng.int(0xffff) : 0;
	        this.state.flags =
	            (this._rng ? this._rng.int(0xff) : 0) | 4 | 32 | 16;
	        this.state.irq = false;
	        this.state.nmi = false;
	        this.executionState = 0;
	        this._opCycles = 7;
	        this._interruptPending = false;
	        this._nmiPending = false;
	        this._instructionCallback = opBoot;
	        return this;
	    }
	    cycle() {
	        if (this._halted) {
	            return this;
	        }
	        switch (this.executionState) {
	            case 0:
	            case 2:
	                if (--this._opCycles === 0) {
	                    if (this._dereference) {
	                        this._operand = this._bus.read(this._operand);
	                    }
	                    if (this._interuptCheck === 1) {
	                        this._checkForInterrupts();
	                    }
	                    this._instructionCallback(this.state, this._bus, this._operand, this._currentAddressingMode);
	                    this.executionState = 1;
	                    if (this._interuptCheck === 0) {
	                        this._checkForInterrupts();
	                    }
	                }
	                break;
	            case 1:
	                if (this.state.nmi) {
	                    this._instructionCallback = opNmi;
	                    this._opCycles = 6;
	                    this.state.nmi = this.state.irq = false;
	                    this._interuptCheck = 1;
	                    this.executionState = 2;
	                    return this;
	                }
	                if (this.state.irq) {
	                    this._instructionCallback = opIrq;
	                    this._opCycles = 6;
	                    this.state.nmi = this.state.irq = false;
	                    this._interuptCheck = 1;
	                    this.executionState = 2;
	                    return this;
	                }
	                this._fetch();
	                break;
	        }
	        return this;
	    }
	    _fetch() {
	        const instruction = Instruction.opcodes[this._bus.read(this.state.p)];
	        let addressingMode = instruction.addressingMode, dereference = false, slowIndexedAccess = false;
	        this._lastInstructionPointer = this.state.p;
	        this._currentAddressingMode = addressingMode;
	        this._interuptCheck = 0;
	        switch (instruction.operation) {
	            case 0:
	                this._opCycles = 0;
	                this._instructionCallback = opAdc;
	                dereference = true;
	                break;
	            case 1:
	                this._opCycles = 0;
	                this._instructionCallback = opAnd;
	                dereference = true;
	                break;
	            case 2:
	                if (addressingMode === 0) {
	                    this._opCycles = 1;
	                    this._instructionCallback = opAslAcc;
	                }
	                else {
	                    this._opCycles = 3;
	                    this._instructionCallback = opAslMem;
	                    slowIndexedAccess = true;
	                }
	                break;
	            case 3:
	                if (this.state.flags & 1) {
	                    addressingMode = 0;
	                    this._instructionCallback = opNop;
	                    this.state.p = (this.state.p + 1) & 0xffff;
	                    this._opCycles = 1;
	                }
	                else {
	                    this._instructionCallback = opJmp;
	                    this._opCycles = 0;
	                }
	                break;
	            case 4:
	                if (this.state.flags & 1) {
	                    this._instructionCallback = opJmp;
	                    this._opCycles = 0;
	                }
	                else {
	                    addressingMode = 0;
	                    this._instructionCallback = opNop;
	                    this.state.p = (this.state.p + 1) & 0xffff;
	                    this._opCycles = 1;
	                }
	                break;
	            case 5:
	                if (this.state.flags & 2) {
	                    this._instructionCallback = opJmp;
	                    this._opCycles = 0;
	                }
	                else {
	                    addressingMode = 0;
	                    this._instructionCallback = opNop;
	                    this.state.p = (this.state.p + 1) & 0xffff;
	                    this._opCycles = 1;
	                }
	                break;
	            case 6:
	                this._opCycles = 0;
	                this._instructionCallback = opBit;
	                dereference = true;
	                break;
	            case 7:
	                if (this.state.flags & 128) {
	                    this._instructionCallback = opJmp;
	                    this._opCycles = 0;
	                }
	                else {
	                    addressingMode = 0;
	                    this._instructionCallback = opNop;
	                    this.state.p = (this.state.p + 1) & 0xffff;
	                    this._opCycles = 1;
	                }
	                break;
	            case 8:
	                if (this.state.flags & 2) {
	                    addressingMode = 0;
	                    this._instructionCallback = opNop;
	                    this.state.p = (this.state.p + 1) & 0xffff;
	                    this._opCycles = 1;
	                }
	                else {
	                    this._instructionCallback = opJmp;
	                    this._opCycles = 0;
	                }
	                break;
	            case 9:
	                if (this.state.flags & 128) {
	                    addressingMode = 0;
	                    this._instructionCallback = opNop;
	                    this.state.p = (this.state.p + 1) & 0xffff;
	                    this._opCycles = 1;
	                }
	                else {
	                    this._instructionCallback = opJmp;
	                    this._opCycles = 0;
	                }
	                break;
	            case 11:
	                if (this.state.flags & 64) {
	                    addressingMode = 0;
	                    this._instructionCallback = opNop;
	                    this.state.p = (this.state.p + 1) & 0xffff;
	                    this._opCycles = 1;
	                }
	                else {
	                    this._instructionCallback = opJmp;
	                    this._opCycles = 0;
	                }
	                break;
	            case 12:
	                if (this.state.flags & 64) {
	                    this._instructionCallback = opJmp;
	                    this._opCycles = 0;
	                }
	                else {
	                    addressingMode = 0;
	                    this._instructionCallback = opNop;
	                    this.state.p = (this.state.p + 1) & 0xffff;
	                    this._opCycles = 1;
	                }
	                break;
	            case 10:
	                this._opCycles = 6;
	                this._instructionCallback = opBrk;
	                this._interuptCheck = 1;
	                break;
	            case 13:
	                this._opCycles = 1;
	                this._instructionCallback = opClc;
	                break;
	            case 14:
	                this._opCycles = 1;
	                this._instructionCallback = opCld;
	                break;
	            case 15:
	                this._opCycles = 1;
	                this._instructionCallback = opCli;
	                this._interuptCheck = 1;
	                break;
	            case 16:
	                this._opCycles = 1;
	                this._instructionCallback = opClv;
	                break;
	            case 17:
	                this._opCycles = 0;
	                this._instructionCallback = opCmp;
	                dereference = true;
	                break;
	            case 18:
	                this._opCycles = 0;
	                this._instructionCallback = opCpx;
	                dereference = true;
	                break;
	            case 19:
	                this._opCycles = 0;
	                this._instructionCallback = opCpy;
	                dereference = true;
	                break;
	            case 20:
	                this._opCycles = 3;
	                this._instructionCallback = opDec;
	                slowIndexedAccess = true;
	                break;
	            case 21:
	                this._opCycles = 1;
	                this._instructionCallback = opDex;
	                break;
	            case 22:
	                this._opCycles = 1;
	                this._instructionCallback = opDey;
	                break;
	            case 23:
	                this._opCycles = 0;
	                this._instructionCallback = opEor;
	                dereference = true;
	                break;
	            case 24:
	                this._opCycles = 3;
	                this._instructionCallback = opInc;
	                slowIndexedAccess = true;
	                break;
	            case 25:
	                this._opCycles = 1;
	                this._instructionCallback = opInx;
	                break;
	            case 26:
	                this._opCycles = 1;
	                this._instructionCallback = opIny;
	                break;
	            case 27:
	                this._opCycles = 0;
	                this._instructionCallback = opJmp;
	                break;
	            case 28:
	                this._opCycles = 5;
	                this._instructionCallback = opJsr;
	                break;
	            case 29:
	                this._opCycles = addressingMode === 1 ? 0 : 1;
	                this._instructionCallback = opLda;
	                break;
	            case 30:
	                this._opCycles = addressingMode === 1 ? 0 : 1;
	                this._instructionCallback = opLdx;
	                break;
	            case 31:
	                this._opCycles = addressingMode === 1 ? 0 : 1;
	                this._instructionCallback = opLdy;
	                break;
	            case 32:
	                if (addressingMode === 0) {
	                    this._opCycles = 1;
	                    this._instructionCallback = opLsrAcc;
	                }
	                else {
	                    this._opCycles = 3;
	                    this._instructionCallback = opLsrMem;
	                    slowIndexedAccess = true;
	                }
	                break;
	            case 33:
	                this._opCycles = 1;
	                this._instructionCallback = opNop;
	                break;
	            case 56:
	            case 57:
	                this._opCycles = 0;
	                dereference = true;
	                this._instructionCallback = opNop;
	                break;
	            case 34:
	                this._opCycles = 0;
	                this._instructionCallback = opOra;
	                dereference = true;
	                break;
	            case 36:
	                this._opCycles = 2;
	                this._instructionCallback = opPhp;
	                break;
	            case 35:
	                this._opCycles = 2;
	                this._instructionCallback = opPha;
	                break;
	            case 37:
	                this._opCycles = 3;
	                this._instructionCallback = opPla;
	                break;
	            case 38:
	                this._opCycles = 3;
	                this._instructionCallback = opPlp;
	                this._interuptCheck = 1;
	                break;
	            case 39:
	                if (addressingMode === 0) {
	                    this._opCycles = 1;
	                    this._instructionCallback = opRolAcc;
	                }
	                else {
	                    this._opCycles = 3;
	                    this._instructionCallback = opRolMem;
	                    slowIndexedAccess = true;
	                }
	                break;
	            case 40:
	                if (addressingMode === 0) {
	                    this._opCycles = 1;
	                    this._instructionCallback = opRorAcc;
	                }
	                else {
	                    this._opCycles = 3;
	                    this._instructionCallback = opRorMem;
	                    slowIndexedAccess = true;
	                }
	                break;
	            case 41:
	                this._opCycles = 5;
	                this._instructionCallback = opRti;
	                break;
	            case 42:
	                this._opCycles = 5;
	                this._instructionCallback = opRts;
	                break;
	            case 43:
	                this._opCycles = 0;
	                this._instructionCallback = opSbc;
	                dereference = true;
	                break;
	            case 44:
	                this._opCycles = 1;
	                this._instructionCallback = opSec;
	                break;
	            case 45:
	                this._opCycles = 1;
	                this._instructionCallback = opSed;
	                break;
	            case 46:
	                this._opCycles = 1;
	                this._instructionCallback = opSei;
	                this._interuptCheck = 1;
	                break;
	            case 47:
	                this._opCycles = 1;
	                this._instructionCallback = opSta;
	                slowIndexedAccess = true;
	                break;
	            case 48:
	                this._opCycles = 1;
	                this._instructionCallback = opStx;
	                slowIndexedAccess = true;
	                break;
	            case 49:
	                this._opCycles = 1;
	                this._instructionCallback = opSty;
	                slowIndexedAccess = true;
	                break;
	            case 50:
	                this._opCycles = 1;
	                this._instructionCallback = opTax;
	                break;
	            case 51:
	                this._opCycles = 1;
	                this._instructionCallback = opTay;
	                break;
	            case 52:
	                this._opCycles = 1;
	                this._instructionCallback = opTsx;
	                break;
	            case 53:
	                this._opCycles = 1;
	                this._instructionCallback = opTxa;
	                break;
	            case 54:
	                this._opCycles = 1;
	                this._instructionCallback = opTxs;
	                break;
	            case 55:
	                this._opCycles = 1;
	                this._instructionCallback = opTya;
	                break;
	            case 62:
	                this._opCycles = 0;
	                this._instructionCallback = opArr;
	                break;
	            case 58:
	                this._opCycles = 0;
	                this._instructionCallback = opAlr;
	                break;
	            case 59:
	                this._opCycles = 0;
	                this._instructionCallback = opAxs;
	                break;
	            case 60:
	                this._opCycles = 3;
	                this._instructionCallback = opDcp;
	                slowIndexedAccess = true;
	                break;
	            case 61:
	                this._opCycles = 0;
	                this._instructionCallback = opLax;
	                dereference = true;
	                break;
	            case 63:
	                this._opCycles = 3;
	                this._instructionCallback = opSlo;
	                slowIndexedAccess = true;
	                dereference = false;
	                break;
	            case 64:
	                this._opCycles = 1;
	                this._instructionCallback = opAax;
	                break;
	            case 65:
	                this._opCycles = 0;
	                this._instructionCallback = opLar;
	                dereference = true;
	                break;
	            case 66:
	                this._opCycles = 3;
	                this._instructionCallback = opIsc;
	                slowIndexedAccess = true;
	                break;
	            case 67:
	                this._opCycles = 0;
	                this._instructionCallback = opAac;
	                break;
	            case 68:
	                this._opCycles = 0;
	                this._instructionCallback = opAtx;
	                break;
	            case 69:
	                this._opCycles = 3;
	                dereference = false;
	                slowIndexedAccess = true;
	                this._instructionCallback = opRra;
	                break;
	            case 70:
	                this._opCycles = 3;
	                dereference = false;
	                slowIndexedAccess = true;
	                this._instructionCallback = opRla;
	                break;
	            default:
	                if (this._invalidInstructionCallback) {
	                    this._invalidInstructionCallback(this);
	                }
	                return;
	        }
	        this.state.p = (this.state.p + 1) & 0xffff;
	        let value, base;
	        switch (addressingMode) {
	            case 1:
	                this._operand = this._bus.read(this.state.p);
	                dereference = false;
	                this.state.p = (this.state.p + 1) & 0xffff;
	                this._opCycles++;
	                break;
	            case 2:
	                this._operand = this._bus.read(this.state.p);
	                this.state.p = (this.state.p + 1) & 0xffff;
	                this._opCycles++;
	                break;
	            case 3:
	                this._operand = this._bus.readWord(this.state.p);
	                this.state.p = (this.state.p + 2) & 0xffff;
	                this._opCycles += 2;
	                break;
	            case 4:
	                value = this._bus.readWord(this.state.p);
	                if ((value & 0xff) === 0xff) {
	                    this._operand = this._bus.read(value) + (this._bus.read(value & 0xff00) << 8);
	                }
	                else {
	                    this._operand = this._bus.readWord(value);
	                }
	                this.state.p = (this.state.p + 2) & 0xffff;
	                this._opCycles += 4;
	                break;
	            case 5:
	                value = this._bus.read(this.state.p);
	                value = value & 0x80 ? -(~(value - 1) & 0xff) : value;
	                this._operand = (this.state.p + value + 0x10001) & 0xffff;
	                this.state.p = (this.state.p + 1) & 0xffff;
	                this._opCycles += (this._operand & 0xff00) !== (this.state.p & 0xff00) ? 3 : 2;
	                break;
	            case 6:
	                base = this._bus.read(this.state.p);
	                this._bus.read(base);
	                this._operand = (base + this.state.x) & 0xff;
	                this.state.p = (this.state.p + 1) & 0xffff;
	                this._opCycles += 2;
	                break;
	            case 7:
	                value = this._bus.readWord(this.state.p);
	                this._operand = (value + this.state.x) & 0xffff;
	                if ((this._operand & 0xff00) !== (value & 0xff00)) {
	                    this._bus.read((value & 0xff00) | (this._operand & 0xff));
	                }
	                this._opCycles += slowIndexedAccess || (this._operand & 0xff00) !== (value & 0xff00) ? 3 : 2;
	                this.state.p = (this.state.p + 2) & 0xffff;
	                break;
	            case 9:
	                base = this._bus.read(this.state.p);
	                this._bus.read(base);
	                this._operand = (base + this.state.y) & 0xff;
	                this.state.p = (this.state.p + 1) & 0xffff;
	                this._opCycles += 2;
	                break;
	            case 10:
	                value = this._bus.readWord(this.state.p);
	                this._operand = (value + this.state.y) & 0xffff;
	                if ((this._operand & 0xff00) !== (value & 0xff00)) {
	                    this._bus.read((value & 0xff00) | (this._operand & 0xff));
	                }
	                this._opCycles += slowIndexedAccess || (this._operand & 0xff00) !== (value & 0xff00) ? 3 : 2;
	                this.state.p = (this.state.p + 2) & 0xffff;
	                break;
	            case 8:
	                base = this._bus.read(this.state.p);
	                this._bus.read(base);
	                value = (base + this.state.x) & 0xff;
	                if (value === 0xff) {
	                    this._operand = this._bus.read(0xff) + (this._bus.read(0x00) << 8);
	                }
	                else {
	                    this._operand = this._bus.readWord(value);
	                }
	                this._opCycles += 4;
	                this.state.p = (this.state.p + 1) & 0xffff;
	                break;
	            case 11:
	                value = this._bus.read(this.state.p);
	                if (value === 0xff) {
	                    value = this._bus.read(0xff) + (this._bus.read(0x00) << 8);
	                }
	                else {
	                    value = this._bus.readWord(value);
	                }
	                this._operand = (value + this.state.y) & 0xffff;
	                if ((this._operand & 0xff00) !== (value & 0xff00)) {
	                    this._bus.read((value & 0xff00) | (this._operand & 0xff));
	                }
	                this._opCycles += slowIndexedAccess || (value & 0xff00) !== (this._operand & 0xff00) ? 4 : 3;
	                this.state.p = (this.state.p + 1) & 0xffff;
	                break;
	        }
	        this._dereference = dereference;
	        if (dereference) {
	            this._opCycles++;
	        }
	        this.executionState = 2;
	    }
	    _checkForInterrupts() {
	        if (this._nmiPending) {
	            this.state.irq = false;
	            this.state.nmi = true;
	            this._nmiPending = false;
	        }
	        if (this._interruptPending && !this.state.nmi && !(this.state.flags & 4)) {
	            this.state.irq = true;
	        }
	    }
	}

	class Factory {
	    constructor(_type) {
	        this._type = _type;
	    }
	    create(bus, rng) {
	        switch (this._type) {
	            case Factory.Type.stateMachine:
	                return new StateMachineCpu(bus, rng);
	            case Factory.Type.batchedAccess:
	                return new BatchedAccessCpu(bus, rng);
	            default:
	                throw new Error('invalid CPU type');
	        }
	    }
	}
	(function (Factory) {
	    let Type;
	    (function (Type) {
	        Type[Type["stateMachine"] = 0] = "stateMachine";
	        Type[Type["batchedAccess"] = 1] = "batchedAccess";
	    })(Type = Factory.Type || (Factory.Type = {}));
	})(Factory || (Factory = {}));
	var CpuFactory = Factory;

	var Config;
	(function (Config) {
	    function create(config = {}) {
	        return Object.assign({ tvMode: 0, enableAudio: true, randomSeed: -1, emulatePaddles: true, frameStart: -1, pcmAudio: false, cpuType: CpuFactory.Type.stateMachine }, config);
	    }
	    Config.create = create;
	    function getClockHz(config) {
	        switch (config.tvMode) {
	            case 0:
	                return 262 * 228 * 60;
	            case 1:
	            case 2:
	                return 312 * 228 * 50;
	        }
	    }
	    Config.getClockHz = getClockHz;
	})(Config || (Config = {}));

	const encodingsString = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', encodings = new Uint8Array(256);
	(function (__init) {
	    let i;
	    for (i = 0; i < 256; i++) {
	        encodings[i] = 255;
	    }
	    for (i = 0; i < 64; i++) {
	        encodings[encodingsString.charCodeAt(i)] = i;
	    }
	    encodings['='.charCodeAt(0)] = 0;
	})();
	function decodeChar(data, idx) {
	    const value = encodings[data.charCodeAt(idx)];
	    if (value > 63) {
	        throw new Error('invalid base64 character "' + data[idx] + '" at index ' + idx);
	    }
	    return value;
	}
	function decodeNibble(data, idx) {
	    return ((decodeChar(data, idx) << 18) +
	        (decodeChar(data, idx + 1) << 12) +
	        (decodeChar(data, idx + 2) << 6) +
	        decodeChar(data, idx + 3));
	}
	function getPadding(data) {
	    let padding = 0, idx = data.length - 1;
	    while (idx >= 0 && data[idx--] === '=') {
	        padding++;
	    }
	    return padding;
	}
	function decode(data) {
	    if (data.length % 4 !== 0) {
	        throw new Error('invalid base64 data --- char count mismatch');
	    }
	    const nibbles = data.length / 4, decodedSize = nibbles * 3 - getPadding(data), decoded = new Uint8Array(decodedSize);
	    let idx = 0;
	    for (let i = 0; i < nibbles; i++) {
	        const nibble = decodeNibble(data, i * 4);
	        for (let j = 0; j < 3 && idx < decodedSize; j++) {
	            decoded[idx++] = (nibble >>> (8 * (2 - j))) & 0xff;
	        }
	    }
	    return decoded;
	}

	const FREQUENCY_DIVISIORS = decode('AQEPAQEBAQEBAQEBAwMDAQ==');
	const POLY0 = new Int8Array([1]);
	const POLY1 = new Int8Array([1, 1]);
	const POLY2 = new Int8Array([16, 15]);
	const POLY4 = decode('AQICAQEBBAM=');
	const POLY5 = decode('AQIBAQICBQQCAQMBAQEBBA==');
	const POLY9 = decode('AQQBAwIEAQIDAgEBAQEBAQIEAgEEAQECAgEDAgEDAQEBBAEBAQECAQECBgECAgECAQIBAQIBBg' +
	    'IBAgIBAQEBAgICAgcCAwICAQEBAwIBAQIBAQcBAQMBAQIDAwEBAQICAQECAgQDBQEDAQEFAgEB' +
	    'AQIBAgEDAQIFAQECAQEBBQEBAQEBAQEBBgEBAQIBAQEBBAIBAQMBAwYDAgMBAQIBAgQBAQEDAQ' +
	    'EBAQMBAgEEAgIDBAEBBAECAQICAgEBBAMBBAQJBQQBBQMBAQMCAgIBBQECAQEBAgMBAgEBAwQC' +
	    'BQICAQIDAQEBAQECAQMDAwIBAgEBAQEBAwMBAgIDAQMBCA==');
	const POLY68 = decode('BQYEBQoFAwcECgYDBgQJBg==');
	const POLY465 = decode('AgMCAQQBBgoCBAIBAQQFCQMDBAEBAQgFBQUEAQEBCAQCCAMDAQEHBAIHBQEDAQcEAQQIAgEDBA' +
	    'cBAwcDAgEGBgICBAUDAgYGAQMDAgUDBwMEAwICAgUJAwEFAwECAgsFAQUDAQECDAUBAgUCAQEM' +
	    'BgECBQECAQoGAwICBAECBgo=');
	const POLYS = [
	    POLY0,
	    POLY4,
	    POLY4,
	    POLY465,
	    POLY1,
	    POLY1,
	    POLY2,
	    POLY5,
	    POLY9,
	    POLY5,
	    POLY2,
	    POLY0,
	    POLY1,
	    POLY1,
	    POLY2,
	    POLY68
	];
	class ToneGenerator {
	    constructor(_config) {
	        this._config = _config;
	    }
	    setConfig(config) {
	        this._config = config;
	    }
	    getKey(tone, frequency) {
	        if (POLYS[tone] === POLY1 && FREQUENCY_DIVISIORS[tone] * (frequency + 1) === 1) {
	            return 0;
	        }
	        return (tone << 5) | frequency;
	    }
	    getBuffer(key) {
	        const tone = (key >>> 5) & 0x0f, frequency = key & 0x1f;
	        const poly = POLYS[tone];
	        let length = 0;
	        for (let i = 0; i < poly.length; i++) {
	            length += poly[i];
	        }
	        length = length * FREQUENCY_DIVISIORS[tone] * (frequency + 1);
	        const content = new Float32Array(length);
	        const sampleRate = Config.getClockHz(this._config) / 114;
	        let f = 0;
	        let count = 0;
	        let offset = 0;
	        let state = true;
	        for (let i = 0; i < length; i++) {
	            f++;
	            if (f === FREQUENCY_DIVISIORS[tone] * (frequency + 1)) {
	                f = 0;
	                count++;
	                if (count === poly[offset]) {
	                    offset++;
	                    count = 0;
	                    if (poly.length === offset) {
	                        offset = 0;
	                    }
	                }
	                state = !(offset & 0x01);
	            }
	            content[i] = state ? 1 : -1;
	        }
	        return new AudioOutputBuffer(content, sampleRate);
	    }
	}

	class WaveformAudio {
	    constructor(_config) {
	        this._config = _config;
	        this.bufferChanged = new lib_1();
	        this.volumeChanged = new lib_1();
	        this.stop = new lib_1();
	        this._volume = -1;
	        this._tone = -1;
	        this._frequency = -1;
	        this._active = false;
	        this._toneGenerator = null;
	        this._toneGenerator = new ToneGenerator(this._config);
	        this.reset();
	    }
	    reset() {
	        this._volume = -1;
	        this._tone = -1;
	        this._frequency = -1;
	    }
	    audc(value) {
	        value &= 0x0f;
	        if (value === this._tone) {
	            return;
	        }
	        this._tone = value;
	        this._dispatchBufferChanged();
	    }
	    audf(value) {
	        value &= 0x1f;
	        if (value === this._frequency) {
	            return;
	        }
	        this._frequency = value;
	        this._dispatchBufferChanged();
	    }
	    audv(value) {
	        value &= 0x0f;
	        if (value === this._volume) {
	            return;
	        }
	        this._volume = value / 15;
	        this.volumeChanged.dispatch(this._volume);
	    }
	    setActive(active) {
	        this._active = active;
	        if (active) {
	            this._dispatchBufferChanged();
	        }
	        else {
	            this.stop.dispatch(undefined);
	        }
	    }
	    getVolume() {
	        return this._volume >= 0 ? this._volume : 0;
	    }
	    getBuffer(key) {
	        return this._toneGenerator.getBuffer(key);
	    }
	    _getKey() {
	        return this._toneGenerator.getKey(this._tone, this._frequency);
	    }
	    _dispatchBufferChanged() {
	        if (this._active && this.bufferChanged.hasHandlers) {
	            this.bufferChanged.dispatch(this._getKey());
	        }
	    }
	}

	class PCMChannel {
	    constructor() {
	        this._audv = 0;
	        this._audc = 0;
	        this._audf = 0;
	        this._clkEnable = false;
	        this._noiseFeedback = false;
	        this._noiseCounterBit4 = false;
	        this._pulseCounterHold = false;
	        this._divCounter = 0;
	        this._noiseCounter = 0;
	        this._pulseCounter = 0;
	        this.reset();
	    }
	    reset() {
	        this._audc = this._audf = this._audv = 0;
	        this._clkEnable = false;
	        this._noiseFeedback = false;
	        this._noiseCounterBit4 = false;
	        this._pulseCounterHold = false;
	        this._divCounter = 0;
	        this._noiseCounter = 0;
	        this._pulseCounter = 0;
	    }
	    phase0() {
	        if (this._clkEnable) {
	            this._noiseCounterBit4 = !!(this._noiseCounter & 0x01);
	            switch (this._audc & 0x03) {
	                case 0x00:
	                case 0x01:
	                    this._pulseCounterHold = false;
	                    break;
	                case 0x02:
	                    this._pulseCounterHold = (this._noiseCounter & 0x1e) !== 0x02;
	                    break;
	                case 0x03:
	                    this._pulseCounterHold = !this._noiseCounterBit4;
	                    break;
	            }
	            switch (this._audc & 0x03) {
	                case 0x00:
	                    this._noiseFeedback =
	                        !!((this._pulseCounter ^ this._noiseCounter) & 0x01) ||
	                            !(this._noiseCounter !== 0 || this._pulseCounter !== 0x0a) ||
	                            !(this._audc & 0x0c);
	                    break;
	                default:
	                    this._noiseFeedback =
	                        !!((this._noiseCounter & 0x04 ? 1 : 0) ^ (this._noiseCounter & 0x01)) ||
	                            this._noiseCounter === 0;
	                    break;
	            }
	        }
	        this._clkEnable = this._divCounter === this._audf;
	        if (this._divCounter === this._audf || this._divCounter === 0x1f) {
	            this._divCounter = 0;
	        }
	        else {
	            this._divCounter++;
	        }
	    }
	    phase1() {
	        let pulseFeedback = false;
	        if (this._clkEnable) {
	            switch (this._audc >>> 2) {
	                case 0x00:
	                    pulseFeedback =
	                        !!((this._pulseCounter & 0x02 ? 1 : 0) ^ (this._pulseCounter & 0x01)) &&
	                            this._pulseCounter !== 0x0a &&
	                            !!(this._audc & 0x03);
	                    break;
	                case 0x01:
	                    pulseFeedback = !(this._pulseCounter & 0x08);
	                    break;
	                case 0x02:
	                    pulseFeedback = !this._noiseCounterBit4;
	                    break;
	                case 0x03:
	                    pulseFeedback = !(!!(this._pulseCounter & 0x02) || !(this._pulseCounter & 0x0e));
	                    break;
	            }
	            this._noiseCounter >>>= 1;
	            if (this._noiseFeedback) {
	                this._noiseCounter |= 0x10;
	            }
	            if (!this._pulseCounterHold) {
	                this._pulseCounter = ~(this._pulseCounter >>> 1) & 0x07;
	                if (pulseFeedback) {
	                    this._pulseCounter |= 0x08;
	                }
	            }
	        }
	        return (this._pulseCounter & 0x01) * this._audv;
	    }
	    audc(value) {
	        this._audc = value & 0x0f;
	    }
	    audf(value) {
	        this._audf = value & 0x1f;
	    }
	    audv(value) {
	        this._audv = value & 0x0f;
	    }
	}

	const R_MAX = 30;
	const R = 1;
	const VOL_MAX = 0x1e;
	const mixingTable = new Float32Array(VOL_MAX + 1);
	(function (__init) {
	    for (let vol = 0; vol <= VOL_MAX; vol++) {
	        mixingTable[vol] = vol / VOL_MAX * (R_MAX + R * VOL_MAX) / (R_MAX + R * vol);
	    }
	})();
	class PCMAudio {
	    constructor(_config) {
	        this._config = _config;
	        this.newFrame = new lib_1();
	        this.togglePause = new lib_1();
	        this._currentOutputBuffer = null;
	        this._bufferIndex = 0;
	        this._sampleRate = 0;
	        this._counter = 0;
	        this._isActive = false;
	        this._channel0 = new PCMChannel();
	        this._channel1 = new PCMChannel();
	        this._sampleRate = (this._config.tvMode === 0 ? 60 * 262 : 50 * 312) * 2;
	        this._frameSize = (this._config.tvMode === 0 ? 262 : 312) * 4;
	        this.reset();
	    }
	    getChannels() {
	        return [
	            {
	                audv: value => this._channel0.audv(value),
	                audc: value => this._channel0.audc(value),
	                audf: value => this._channel0.audf(value),
	                reset: () => this.reset(),
	                setActive: active => this.setActive(active)
	            },
	            {
	                audv: value => this._channel1.audv(value),
	                audc: value => this._channel1.audc(value),
	                audf: value => this._channel1.audf(value),
	                reset: () => undefined,
	                setActive: () => undefined
	            }
	        ];
	    }
	    reset() {
	        this._bufferIndex = 0;
	        this._counter = 0;
	        this._channel0.reset();
	        this._channel1.reset();
	    }
	    tick() {
	        switch (this._counter) {
	            case 9:
	            case 81:
	                this._channel0.phase0();
	                this._channel1.phase0();
	                break;
	            case 37:
	            case 149:
	                this._currentOutputBuffer.getContent()[this._bufferIndex++] =
	                    mixingTable[this._channel0.phase1() + this._channel1.phase1()];
	                if (this._bufferIndex === this._currentOutputBuffer.getLength()) {
	                    this._dispatchBuffer();
	                }
	                break;
	        }
	        if (++this._counter === 228) {
	            this._counter = 0;
	        }
	    }
	    isPaused() {
	        return !this._isActive;
	    }
	    setActive(isActive) {
	        if (isActive === this._isActive) {
	            return;
	        }
	        this._isActive = isActive;
	        this.togglePause.dispatch(!isActive);
	    }
	    getSampleRate() {
	        return this._sampleRate;
	    }
	    getFrameSize() {
	        return this._frameSize;
	    }
	    setFrameBufferFactory(factory) {
	        this._bufferFactory = factory;
	        if (!this._currentOutputBuffer && factory) {
	            this._currentOutputBuffer = factory();
	            this._bufferIndex = 0;
	        }
	    }
	    _dispatchBuffer() {
	        this.newFrame.dispatch(this._currentOutputBuffer);
	        this._currentOutputBuffer = this._bufferFactory ? this._bufferFactory() : null;
	        this._bufferIndex = 0;
	    }
	}

	const decodes0 = new Uint8Array(160), decodes1 = new Uint8Array(160), decodes2 = new Uint8Array(160), decodes3 = new Uint8Array(160), decodes4 = new Uint8Array(160), decodes6 = new Uint8Array(160);
	const decodesMissile = [
	    decodes0,
	    decodes1,
	    decodes2,
	    decodes3,
	    decodes4,
	    decodes0,
	    decodes6,
	    decodes0
	];
	const decodesPlayer = [
	    decodes0,
	    decodes1,
	    decodes2,
	    decodes3,
	    decodes4,
	    decodes0,
	    decodes6,
	    decodes0
	];
	[decodes0, decodes1, decodes2, decodes3, decodes4, decodes6].forEach(decodes => {
	    for (let i = 0; i < 160; i++) {
	        decodes[i] = 0;
	    }
	    decodes[156] = 1;
	});
	decodes1[12] = 1;
	decodes2[28] = 1;
	decodes3[12] = decodes3[28] = 1;
	decodes4[60] = 1;
	decodes6[28] = decodes6[60] = 1;

	class Missile {
	    constructor(_collisionMask, _flushLineCache) {
	        this._collisionMask = _collisionMask;
	        this._flushLineCache = _flushLineCache;
	        this.color = 0xffffffff;
	        this.collision = 0;
	        this._enabled = false;
	        this._enam = false;
	        this._resmp = -1;
	        this._hmmClocks = 0;
	        this._counter = 0;
	        this._moving = false;
	        this._width = 1;
	        this._effectiveWidth = 0;
	        this._lastMovementTick = 0;
	        this._rendering = false;
	        this._renderCounter = -4;
	        this._widths = new Uint8Array([1, 2, 4, 8]);
	        this.reset();
	    }
	    reset() {
	        this.color = 0xffffffff;
	        this._width = 1;
	        this._enabled = false;
	        this._counter = 0;
	        this._rendering = false;
	        this._renderCounter = -4;
	        this._moving = false;
	        this._hmmClocks = 0;
	        this._decodes = decodesMissile[0];
	        this._resmp = -1;
	        this._enam = false;
	        this._effectiveWidth = 0;
	        this._lastMovementTick = 0;
	    }
	    enam(value) {
	        const enam = (value & 2) > 0, enabled = enam && this._resmp === 0;
	        if (enam !== this._enam || enabled !== this._enabled) {
	            this._flushLineCache();
	        }
	        this._enam = enam;
	        this._enabled = enabled;
	    }
	    hmm(value) {
	        this._hmmClocks = (value >>> 4) ^ 0x8;
	    }
	    resm(counter, hblank) {
	        this._counter = counter;
	        if (this._rendering) {
	            if (this._renderCounter < 0) {
	                this._renderCounter = -4 + (counter - 157);
	            }
	            else {
	                switch (this._width) {
	                    case 8:
	                        this._renderCounter = counter - 157 + (this._renderCounter >= 4 ? 4 : 0);
	                        break;
	                    case 4:
	                        this._renderCounter = counter - 157;
	                        break;
	                    case 2:
	                        if (hblank) {
	                            this._rendering = this._renderCounter > 1;
	                        }
	                        else if (this._renderCounter === 0) {
	                            this._renderCounter++;
	                        }
	                        break;
	                    default:
	                        if (hblank) {
	                            this._rendering = this._renderCounter > 0;
	                        }
	                        break;
	                }
	            }
	        }
	    }
	    resmp(value, player) {
	        const resmp = value & 0x02;
	        if (resmp === this._resmp) {
	            return;
	        }
	        this._flushLineCache();
	        this._resmp = resmp;
	        if (resmp) {
	            this._enabled = false;
	        }
	        else {
	            this._enabled = this._enam;
	            this._counter = player.getRespClock();
	        }
	    }
	    nusiz(value) {
	        this._width = this._widths[(value & 0x30) >>> 4];
	        this._decodes = decodesMissile[value & 0x07];
	        if (this._rendering && this._renderCounter >= this._width) {
	            this._rendering = false;
	        }
	    }
	    startMovement() {
	        this._moving = true;
	    }
	    movementTick(clock, apply) {
	        this._lastMovementTick = this._counter;
	        if (clock === this._hmmClocks) {
	            this._moving = false;
	        }
	        if (this._moving && apply) {
	            this.tick(false);
	        }
	        return this._moving;
	    }
	    tick(isReceivingHclock) {
	        this.collision = this._rendering && this._renderCounter >= 0 && this._enabled ? 0 : this._collisionMask;
	        const starfieldEffect = this._moving && isReceivingHclock;
	        if (this._decodes[this._counter] && !this._resmp) {
	            const starfieldDelta = (this._counter - this._lastMovementTick + 160) % 4;
	            this._rendering = true;
	            this._renderCounter = -4;
	            if (starfieldEffect && starfieldDelta === 3 && this._width < 4) {
	                this._renderCounter++;
	            }
	            switch (starfieldDelta) {
	                case 3:
	                    this._effectiveWidth = this._width === 1 ? 2 : this._width;
	                    break;
	                case 2:
	                    this._effectiveWidth = 0;
	                    break;
	                default:
	                    this._effectiveWidth = this._width;
	                    break;
	            }
	        }
	        else if (this._rendering && ++this._renderCounter >= (starfieldEffect ? this._effectiveWidth : this._width)) {
	            this._rendering = false;
	        }
	        if (++this._counter >= 160) {
	            this._counter = 0;
	        }
	    }
	    getPixel(colorIn) {
	        return this.collision ? colorIn : this.color;
	    }
	    setColor(color) {
	        if (color !== this.color && this._enabled) {
	            this._flushLineCache();
	        }
	        this.color = color;
	    }
	}

	class Playfield {
	    constructor(_collisionMask, _flushLineCache) {
	        this._collisionMask = _collisionMask;
	        this._flushLineCache = _flushLineCache;
	        this.collision = 0;
	        this._colorLeft = 0;
	        this._colorRight = 0;
	        this._color = 0;
	        this._colorP0 = 0;
	        this._colorP1 = 0;
	        this._colorMode = 0;
	        this._pattern = 0;
	        this._refp = false;
	        this._reflected = false;
	        this._pf0 = 0;
	        this._pf1 = 0;
	        this._pf2 = 0;
	        this._x = 0;
	        this.reset();
	    }
	    reset() {
	        this._pattern = 0;
	        this._reflected = false;
	        this._refp = false;
	        this._pf0 = 0;
	        this._pf1 = 0;
	        this._pf2 = 0;
	        this._color = 0;
	        this._colorP0 = 0;
	        this._colorP1 = 0;
	        this._colorMode = 0;
	        this._applyColors();
	    }
	    pf0(value) {
	        if (this._pf0 === value >>> 4) {
	            return;
	        }
	        this._flushLineCache();
	        this._pf0 = value >>> 4;
	        this._pattern = (this._pattern & 0x000ffff0) | this._pf0;
	    }
	    pf1(value) {
	        if (this._pf1 === value) {
	            return;
	        }
	        this._flushLineCache();
	        this._pf1 = value;
	        this._pattern =
	            (this._pattern & 0x000ff00f) |
	                ((value & 0x80) >>> 3) |
	                ((value & 0x40) >>> 1) |
	                ((value & 0x20) << 1) |
	                ((value & 0x10) << 3) |
	                ((value & 0x08) << 5) |
	                ((value & 0x04) << 7) |
	                ((value & 0x02) << 9) |
	                ((value & 0x01) << 11);
	    }
	    pf2(value) {
	        if (this._pf2 === value) {
	            return;
	        }
	        this._flushLineCache();
	        this._pf2 = value;
	        this._pattern = (this._pattern & 0x00000fff) | ((value & 0xff) << 12);
	    }
	    ctrlpf(value) {
	        const reflected = (value & 0x01) > 0, colorMode = (value & 0x06) === 0x02 ? 1 : 0;
	        if (reflected === this._reflected && colorMode === this._colorMode) {
	            return;
	        }
	        this._flushLineCache();
	        this._reflected = reflected;
	        this._colorMode = colorMode;
	        this._applyColors();
	    }
	    setColor(color) {
	        if (color !== this._color && this._colorMode === 0) {
	            this._flushLineCache();
	        }
	        this._color = color;
	        this._applyColors();
	    }
	    setColorP0(color) {
	        if (color !== this._colorP0 && this._colorMode === 1) {
	            this._flushLineCache();
	        }
	        this._colorP0 = color;
	        this._applyColors();
	    }
	    setColorP1(color) {
	        if (color !== this._colorP1 && this._colorMode === 1) {
	            this._flushLineCache();
	        }
	        this._colorP1 = color;
	        this._applyColors();
	    }
	    tick(x) {
	        this._x = x;
	        if (x === 80 || x === 0) {
	            this._refp = this._reflected;
	        }
	        if (x & 0x03) {
	            return;
	        }
	        let currentPixel;
	        if (this._pattern === 0) {
	            currentPixel = 0;
	        }
	        else if (x < 80) {
	            currentPixel = this._pattern & (1 << (x >>> 2));
	        }
	        else if (this._refp) {
	            currentPixel = this._pattern & (1 << (39 - (x >>> 2)));
	        }
	        else {
	            currentPixel = this._pattern & (1 << ((x >>> 2) - 20));
	        }
	        this.collision = currentPixel ? 0 : this._collisionMask;
	    }
	    getPixel(colorIn) {
	        if (!this.collision) {
	            return this._x < 80 ? this._colorLeft : this._colorRight;
	        }
	        return colorIn;
	    }
	    _applyColors() {
	        switch (this._colorMode) {
	            case 0:
	                this._colorLeft = this._colorRight = this._color;
	                break;
	            case 1:
	                this._colorLeft = this._colorP0;
	                this._colorRight = this._colorP1;
	                break;
	        }
	    }
	}

	class Player {
	    constructor(_collisionMask, _flushLineCache) {
	        this._collisionMask = _collisionMask;
	        this._flushLineCache = _flushLineCache;
	        this.color = 0xffffffff;
	        this.collision = 0;
	        this._hmmClocks = 0;
	        this._counter = 0;
	        this._moving = false;
	        this._divider = 1;
	        this._dividerPending = 1;
	        this._dividerChangeCounter = -1;
	        this._sampleCounter = 0;
	        this._rendering = false;
	        this._renderCounter = -5;
	        this._renderCounterTripPoint = 0;
	        this._patternNew = 0;
	        this._patternOld = 0;
	        this._pattern = 0;
	        this._reflected = false;
	        this._delaying = false;
	        this.reset();
	    }
	    reset() {
	        this.color = 0xffffffff;
	        this.collision = 0;
	        this._hmmClocks = 0;
	        this._counter = 0;
	        this._moving = false;
	        this._rendering = false;
	        this._renderCounter = -5;
	        this._decodes = decodesPlayer[0];
	        this._patternNew = 0;
	        this._patternOld = 0;
	        this._pattern = 0;
	        this._reflected = false;
	        this._delaying = false;
	        this._sampleCounter = 0;
	        this._dividerPending = 0;
	        this._dividerChangeCounter = -1;
	        this._setDivider(1);
	    }
	    grp(pattern) {
	        if (pattern === this._patternNew) {
	            return;
	        }
	        this._patternNew = pattern;
	        if (!this._delaying) {
	            this._flushLineCache();
	            this._updatePattern();
	        }
	    }
	    hmp(value) {
	        this._hmmClocks = (value >>> 4) ^ 0x8;
	    }
	    nusiz(value, hblank) {
	        const masked = value & 0x07;
	        switch (masked) {
	            case 5:
	                this._dividerPending = 2;
	                break;
	            case 7:
	                this._dividerPending = 4;
	                break;
	            default:
	                this._dividerPending = 1;
	        }
	        const oldDecodes = this._decodes;
	        this._decodes = decodesPlayer[masked];
	        if (this._decodes !== oldDecodes &&
	            this._rendering &&
	            this._renderCounter - -5 < 2 &&
	            !this._decodes[(this._counter - this._renderCounter + -5 + 159) % 160]) {
	            this._rendering = false;
	        }
	        if (this._dividerPending === this._divider) {
	            return;
	        }
	        if (!this._rendering) {
	            this._setDivider(this._dividerPending);
	            return;
	        }
	        const delta = this._renderCounter - -5;
	        switch ((this._divider << 4) | this._dividerPending) {
	            case 0x12:
	            case 0x14:
	                if (hblank) {
	                    if (delta < 4) {
	                        this._setDivider(this._dividerPending);
	                    }
	                    else {
	                        this._dividerChangeCounter = delta < 5 ? 1 : 0;
	                    }
	                }
	                else {
	                    if (delta < 3) {
	                        this._setDivider(this._dividerPending);
	                    }
	                    else {
	                        this._dividerChangeCounter = 1;
	                    }
	                }
	                break;
	            case 0x21:
	            case 0x41:
	                if (delta < (hblank ? 4 : 3)) {
	                    this._setDivider(this._dividerPending);
	                }
	                else if (delta < (hblank ? 6 : 5)) {
	                    this._setDivider(this._dividerPending);
	                    this._renderCounter--;
	                }
	                else {
	                    this._dividerChangeCounter = hblank ? 0 : 1;
	                }
	                break;
	            case 0x42:
	            case 0x24:
	                if (this._renderCounter < 1 || (hblank && this._renderCounter % this._divider === 1)) {
	                    this._setDivider(this._dividerPending);
	                }
	                else {
	                    this._dividerChangeCounter = this._divider - (this._renderCounter - 1) % this._divider;
	                }
	                break;
	            default:
	                throw new Error('cannot happen');
	        }
	    }
	    resp(counter) {
	        this._counter = counter;
	        if (this._rendering && this._renderCounter - -5 < 4) {
	            this._renderCounter = -5 + (counter - 157);
	        }
	    }
	    refp(value) {
	        const oldReflected = this._reflected;
	        this._reflected = (value & 0x08) > 0;
	        if (this._reflected !== oldReflected) {
	            this._flushLineCache();
	            this._updatePattern();
	        }
	    }
	    vdelp(value) {
	        const oldDelaying = this._delaying;
	        this._delaying = (value & 0x01) > 0;
	        if (this._delaying !== oldDelaying) {
	            this._flushLineCache();
	            this._updatePattern();
	        }
	    }
	    startMovement() {
	        this._moving = true;
	    }
	    movementTick(clock, apply) {
	        if (clock === this._hmmClocks) {
	            this._moving = false;
	        }
	        if (this._moving && apply) {
	            this.tick();
	        }
	        return this._moving;
	    }
	    tick() {
	        this.collision =
	            this._rendering &&
	                this._renderCounter >= this._renderCounterTripPoint &&
	                this._pattern & (1 << this._sampleCounter)
	                ? 0
	                : this._collisionMask;
	        if (this._decodes[this._counter]) {
	            this._rendering = true;
	            this._renderCounter = -5;
	            this._sampleCounter = 0;
	        }
	        else if (this._rendering) {
	            this._renderCounter++;
	            switch (this._divider) {
	                case 1:
	                    if (this._renderCounter > 0) {
	                        this._sampleCounter++;
	                    }
	                    if (this._renderCounter >= 0 &&
	                        this._dividerChangeCounter >= 0 &&
	                        this._dividerChangeCounter-- === 0) {
	                        this._setDivider(this._dividerPending);
	                    }
	                    break;
	                default:
	                    if (this._renderCounter > 1 && (this._renderCounter - 1) % this._divider === 0) {
	                        this._sampleCounter++;
	                    }
	                    if (this._renderCounter > 0 &&
	                        this._dividerChangeCounter >= 0 &&
	                        this._dividerChangeCounter-- === 0) {
	                        this._setDivider(this._dividerPending);
	                    }
	                    break;
	            }
	            if (this._sampleCounter > 7) {
	                this._rendering = false;
	            }
	        }
	        if (++this._counter >= 160) {
	            this._counter = 0;
	        }
	    }
	    getPixel(colorIn) {
	        return this.collision ? colorIn : this.color;
	    }
	    shufflePatterns() {
	        const oldPatternOld = this._patternOld;
	        this._patternOld = this._patternNew;
	        if (this._delaying && oldPatternOld !== this._patternOld) {
	            this._flushLineCache();
	            this._updatePattern();
	        }
	    }
	    getRespClock() {
	        switch (this._divider) {
	            case 1:
	                return (this._counter - 5 + 160) % 160;
	            case 2:
	                return (this._counter - 9 + 160) % 160;
	            case 4:
	                return (this._counter - 12 + 160) % 160;
	            default:
	                throw new Error(`cannot happen: invalid divider ${this._divider}`);
	        }
	    }
	    setColor(color) {
	        if (color !== this.color && this._pattern) {
	            this._flushLineCache();
	        }
	        this.color = color;
	    }
	    _updatePattern() {
	        this._pattern = this._delaying ? this._patternOld : this._patternNew;
	        if (!this._reflected) {
	            this._pattern =
	                ((this._pattern & 0x01) << 7) |
	                    ((this._pattern & 0x02) << 5) |
	                    ((this._pattern & 0x04) << 3) |
	                    ((this._pattern & 0x08) << 1) |
	                    ((this._pattern & 0x10) >>> 1) |
	                    ((this._pattern & 0x20) >>> 3) |
	                    ((this._pattern & 0x40) >>> 5) |
	                    ((this._pattern & 0x80) >>> 7);
	        }
	    }
	    _setDivider(divider) {
	        this._divider = divider;
	        this._renderCounterTripPoint = divider === 1 ? 0 : 1;
	    }
	}

	class Ball {
	    constructor(_collisionMask, _flushLineCache) {
	        this._collisionMask = _collisionMask;
	        this._flushLineCache = _flushLineCache;
	        this.color = 0xffffffff;
	        this.collision = 0;
	        this._enabledOld = false;
	        this._enabledNew = false;
	        this._enabled = false;
	        this._hmmClocks = 0;
	        this._counter = 0;
	        this._moving = false;
	        this._width = 1;
	        this._effectiveWidth = 0;
	        this._lastMovementTick = 0;
	        this._rendering = false;
	        this._renderCounter = -4;
	        this._widths = new Uint8Array([1, 2, 4, 8]);
	        this._delaying = false;
	        this.reset();
	    }
	    reset() {
	        this.color = 0xffffffff;
	        this.collision = 0;
	        this._width = 1;
	        this._enabledOld = false;
	        this._enabledNew = false;
	        this._enabled = false;
	        this._counter = 0;
	        this._rendering = false;
	        this._renderCounter = -4;
	        this._moving = false;
	        this._hmmClocks = 0;
	        this._delaying = false;
	        this._effectiveWidth = 0;
	        this._lastMovementTick = 0;
	    }
	    enabl(value) {
	        const enabledNewOldValue = this._enabledNew;
	        this._enabledNew = (value & 2) > 0;
	        if (enabledNewOldValue !== this._enabledNew && !this._delaying) {
	            this._flushLineCache();
	            this._updateEnabled();
	        }
	    }
	    hmbl(value) {
	        this._hmmClocks = (value >>> 4) ^ 0x8;
	    }
	    resbl(counter) {
	        this._counter = counter;
	        this._rendering = true;
	        this._renderCounter = -4 + (counter - 157);
	    }
	    ctrlpf(value) {
	        const width = this._widths[(value & 0x30) >>> 4];
	        if (width !== this._width) {
	            this._flushLineCache();
	        }
	        this._width = width;
	    }
	    vdelbl(value) {
	        const oldDelaying = this._delaying;
	        this._delaying = (value & 0x01) > 0;
	        if (oldDelaying !== this._delaying) {
	            this._flushLineCache();
	            this._updateEnabled();
	        }
	    }
	    startMovement() {
	        this._moving = true;
	    }
	    movementTick(clock, apply) {
	        this._lastMovementTick = this._counter;
	        if (clock === this._hmmClocks) {
	            this._moving = false;
	        }
	        if (this._moving && apply) {
	            this.tick(false);
	        }
	        return this._moving;
	    }
	    tick(isReceivingHclock) {
	        this.collision = this._rendering && this._renderCounter >= 0 && this._enabled ? 0 : this._collisionMask;
	        const starfieldEffect = this._moving && isReceivingHclock;
	        if (this._counter === 156) {
	            const starfieldDelta = (this._counter - this._lastMovementTick + 160) % 4;
	            this._rendering = true;
	            this._renderCounter = -4;
	            if (starfieldEffect && starfieldDelta === 3 && this._width < 4) {
	                this._renderCounter++;
	            }
	            switch (starfieldDelta) {
	                case 3:
	                    this._effectiveWidth = this._width === 1 ? 2 : this._width;
	                    break;
	                case 2:
	                    this._effectiveWidth = 0;
	                    break;
	                default:
	                    this._effectiveWidth = this._width;
	                    break;
	            }
	        }
	        else if (this._rendering && ++this._renderCounter >= (starfieldEffect ? this._effectiveWidth : this._width)) {
	            this._rendering = false;
	        }
	        if (++this._counter >= 160) {
	            this._counter = 0;
	        }
	    }
	    getPixel(colorIn) {
	        return this.collision ? colorIn : this.color;
	    }
	    shuffleStatus() {
	        const oldEnabledOld = this._enabledOld;
	        this._enabledOld = this._enabledNew;
	        if (this._delaying && this._enabledOld !== oldEnabledOld) {
	            this._flushLineCache();
	            this._updateEnabled();
	        }
	    }
	    setColor(color) {
	        if (color !== this.color && this._enabled) {
	            this._flushLineCache();
	        }
	        this.color = color;
	    }
	    _updateEnabled() {
	        this._enabled = this._delaying ? this._enabledOld : this._enabledNew;
	    }
	}

	class LatchedInput {
	    constructor(_switch) {
	        this._switch = _switch;
	        this._modeLatched = false;
	        this._latchedValue = 0;
	        this.reset();
	    }
	    reset() {
	        this._modeLatched = false;
	        this._latchedValue = 0;
	    }
	    vblank(value) {
	        if (value & 0x40) {
	            this._modeLatched = true;
	        }
	        else {
	            this._modeLatched = false;
	            this._latchedValue = 0x80;
	        }
	    }
	    inpt() {
	        let value = this._switch.read() ? 0 : 0x80;
	        if (this._modeLatched) {
	            this._latchedValue &= value;
	            value = this._latchedValue;
	        }
	        return value;
	    }
	}

	const C = 68e-9, RPOT = 1e6, R0 = 1.8e3, U = 5, LINES_FULL = 380;
	class PaddleReader {
	    constructor(clockFreq, _paddle) {
	        this._paddle = _paddle;
	        this._uThresh = 0;
	        this._u = 0;
	        this._dumped = false;
	        this._value = 0.5;
	        this._timestamp = 0;
	        this._cpuTimeProvider = null;
	        this._uThresh = U * (1 - Math.exp(-LINES_FULL * 228 / clockFreq / (RPOT + R0) / C));
	        this._paddle.valueChanged.addHandler((value) => {
	            this._updateValue();
	            this._value = value;
	        });
	        this.reset();
	    }
	    setCpuTimeProvider(provider) {
	        this._cpuTimeProvider = provider;
	        this._timestamp = this._cpuTimeProvider();
	    }
	    reset() {
	        this._u = 0;
	        this._value = this._paddle.getValue();
	        this._dumped = false;
	        this._timestamp = this._cpuTimeProvider ? this._cpuTimeProvider() : 0;
	    }
	    vblank(value) {
	        const oldValue = this._dumped;
	        if (value & 0x80) {
	            this._dumped = true;
	            this._u = 0;
	        }
	        else if (oldValue) {
	            this._dumped = false;
	            this._timestamp = this._cpuTimeProvider();
	        }
	    }
	    inpt() {
	        this._updateValue();
	        const state = this._dumped ? false : this._u >= this._uThresh;
	        return state ? 0x80 : 0;
	    }
	    _updateValue() {
	        if (this._dumped) {
	            return;
	        }
	        const timestamp = this._cpuTimeProvider();
	        this._u =
	            U * (1 - (1 - this._u / U) * Math.exp(-(timestamp - this._timestamp) / (this._value * RPOT + R0) / C));
	        this._timestamp = timestamp;
	    }
	}

	class FrameManager {
	    constructor(_config) {
	        this._config = _config;
	        this.newFrame = new lib_1();
	        this.vblank = false;
	        this.surfaceBuffer = null;
	        this._vblankLines = 0;
	        this._kernelLines = 0;
	        this._overscanLines = 0;
	        this._linesWithoutVsync = 0;
	        this._state = 0;
	        this._vsync = false;
	        this._lineInState = 0;
	        this._surfaceFactory = null;
	        this._surface = null;
	        this._frameStart = -1;
	        switch (this._config.tvMode) {
	            case 0:
	                this._vblankLines = 40;
	                this._kernelLines = 192;
	                this._overscanLines = 30;
	                break;
	            case 1:
	            case 2:
	                this._vblankLines = 48;
	                this._kernelLines = 228;
	                this._overscanLines = 36;
	                break;
	            default:
	                throw new Error(`invalid tv mode ${this._config.tvMode}`);
	        }
	        this._frameStart = this._config.frameStart;
	        this.reset();
	    }
	    reset() {
	        this.vblank = false;
	        this.surfaceBuffer = null;
	        this._linesWithoutVsync = 0;
	        this._state = 0;
	        this._vsync = false;
	        this._lineInState = 0;
	        this._surface = null;
	    }
	    nextLine() {
	        if (!this._surfaceFactory) {
	            return;
	        }
	        this._lineInState++;
	        switch (this._state) {
	            case 0:
	            case 1:
	                if (++this._linesWithoutVsync > 150) {
	                    this._setState(2);
	                }
	                break;
	            case 2:
	                if (this._frameStart >= 0) {
	                    if (this._lineInState > this._frameStart) {
	                        this._startFrame();
	                    }
	                }
	                else {
	                    if (this._lineInState >=
	                        (this.vblank ? this._vblankLines : this._vblankLines - 10)) {
	                        this._startFrame();
	                    }
	                }
	                break;
	            case 3:
	                if (this._lineInState >= this._kernelLines + 20) {
	                    this._finalizeFrame();
	                }
	                break;
	            case 4:
	                if (this._lineInState >= this._overscanLines - 20) {
	                    this._setState(0);
	                }
	                break;
	        }
	    }
	    isRendering() {
	        return this._state === 3 && !!this._surface;
	    }
	    setVblank(vblank) {
	        if (this._surfaceFactory) {
	            this.vblank = vblank;
	        }
	    }
	    setVsync(vsync) {
	        if (!this._surfaceFactory || vsync === this._vsync) {
	            return;
	        }
	        this._vsync = vsync;
	        switch (this._state) {
	            case 0:
	                this._linesWithoutVsync = 0;
	            case 2:
	            case 4:
	                if (vsync) {
	                    this._setState(1);
	                }
	                break;
	            case 1:
	                if (!vsync) {
	                    this._setState(2);
	                }
	                break;
	            case 3:
	                if (vsync) {
	                    this._finalizeFrame();
	                }
	                break;
	        }
	    }
	    getHeight() {
	        return this._kernelLines + 20;
	    }
	    setSurfaceFactory(factory) {
	        this._surfaceFactory = factory;
	    }
	    getCurrentLine() {
	        return this._state === 3 ? this._lineInState : 0;
	    }
	    getDebugState() {
	        return `${this._getReadableState()}, line = ${this._lineInState}, ` + `vblank = ${this.vblank ? '1' : '0'}`;
	    }
	    _getReadableState() {
	        switch (this._state) {
	            case 0:
	                return `wait for vsync start`;
	            case 1:
	                return `wait for vsync end`;
	            case 2:
	                return `wait for frame start`;
	            case 3:
	                return `frame`;
	            case 4:
	                return `overscan`;
	        }
	    }
	    _startFrame() {
	        this._setState(3);
	        this._surface = this._surfaceFactory();
	        this.surfaceBuffer = this._surface.getBuffer();
	    }
	    _finalizeFrame() {
	        if (this._state !== 3) {
	            throw new Error(`finalize frame in invalid state ${this._state}`);
	        }
	        this.newFrame.dispatch(this._surface);
	        this._setState(4);
	    }
	    _setState(newState) {
	        this._state = newState;
	        this._lineInState = 0;
	    }
	}

	class DelayQueue {
	    constructor(_length, size) {
	        this._length = _length;
	        this._nextIndex = 0;
	        this._indices = new Uint8Array(0xff);
	        this._queue = new Array(this._length);
	        for (let i = 0; i < this._length; i++) {
	            this._queue[i] = new QueueEntry(size);
	        }
	    }
	    reset() {
	        for (let i = 0; i < this._length; i++) {
	            this._queue[i].nextIndex = 0;
	        }
	    }
	    push(address, value, delay) {
	        if (delay >= this._length) {
	            throw new Error('delay exceeds queue length');
	        }
	        const currentIndex = this._indices[address];
	        if (currentIndex < this._length) {
	            this._queue[currentIndex].remove(address);
	        }
	        const index = (this._nextIndex + delay) % this._length;
	        this._queue[index].push(address, value);
	        this._indices[address] = index;
	        return this;
	    }
	    execute(handler, scope) {
	        const entry = this._queue[this._nextIndex];
	        this._nextIndex = (this._nextIndex + 1) % this._length;
	        for (let i = 0; i < entry.nextIndex; i++) {
	            handler(entry.addresses[i], entry.values[i], scope);
	            this._indices[entry.addresses[i]] = 0xff;
	        }
	        entry.nextIndex = 0;
	    }
	}
	class QueueEntry {
	    constructor(size) {
	        this.size = size;
	        this.nextIndex = 0;
	        this.addresses = new Uint8Array(size);
	        this.values = new Uint8Array(size);
	    }
	    push(address, value) {
	        if (this.nextIndex >= this.size) {
	            throw new Error('delay queue overflow');
	        }
	        this.addresses[this.nextIndex] = address;
	        this.values[this.nextIndex] = value;
	        this.nextIndex++;
	    }
	    remove(address) {
	        let i;
	        for (i = 0; i < this.nextIndex; i++) {
	            if (this.addresses[i] === address) {
	                break;
	            }
	        }
	        if (i < this.nextIndex) {
	            this.addresses[i] = this.addresses[this.nextIndex - 1];
	            this.values[i] = this.values[this.nextIndex - 1];
	            this.nextIndex--;
	        }
	    }
	}

	const NTSC = new Uint32Array([
	    0xff000000,
	    0xff4a4a4a,
	    0xff6f6f6f,
	    0xff8e8e8e,
	    0xffaaaaaa,
	    0xffc0c0c0,
	    0xffd6d6d6,
	    0xffececec,
	    0xff004848,
	    0xff0f6969,
	    0xff1d8686,
	    0xff2aa2a2,
	    0xff35bbbb,
	    0xff40d2d2,
	    0xff4ae8e8,
	    0xff54fcfc,
	    0xff002c7c,
	    0xff114890,
	    0xff2162a2,
	    0xff307ab4,
	    0xff3d90c3,
	    0xff4aa4d2,
	    0xff55b7df,
	    0xff60c8ec,
	    0xff001c90,
	    0xff1539a3,
	    0xff2853b5,
	    0xff3a6cc6,
	    0xff4a82d5,
	    0xff5997e3,
	    0xff67aaf0,
	    0xff74bcfc,
	    0xff000094,
	    0xff1a1aa7,
	    0xff3232b8,
	    0xff4848c8,
	    0xff5c5cd6,
	    0xff6f6fe4,
	    0xff8080f0,
	    0xff9090fc,
	    0xff640084,
	    0xff7a1997,
	    0xff8f30a8,
	    0xffa246b8,
	    0xffb359c6,
	    0xffc36cd4,
	    0xffd27ce0,
	    0xffe08cec,
	    0xff840050,
	    0xff9a1968,
	    0xffad307d,
	    0xffc04692,
	    0xffd059a4,
	    0xffe06cb5,
	    0xffee7cc5,
	    0xfffc8cd4,
	    0xff900014,
	    0xffa31a33,
	    0xffb5324e,
	    0xffc64868,
	    0xffd55c7f,
	    0xffe36f95,
	    0xfff080a9,
	    0xfffc90bc,
	    0xff940000,
	    0xffa71a18,
	    0xffb8322d,
	    0xffc84842,
	    0xffd65c54,
	    0xffe46f65,
	    0xfff08075,
	    0xfffc9084,
	    0xff881c00,
	    0xff9d3b18,
	    0xffb0572d,
	    0xffc27242,
	    0xffd28a54,
	    0xffe1a065,
	    0xffefb575,
	    0xfffcc884,
	    0xff643000,
	    0xff805018,
	    0xff986d2d,
	    0xffb08842,
	    0xffc5a054,
	    0xffd9b765,
	    0xffebcc75,
	    0xfffce084,
	    0xff304000,
	    0xff4e6218,
	    0xff69812d,
	    0xff829e42,
	    0xff99b854,
	    0xffaed165,
	    0xffc2e775,
	    0xffd4fc84,
	    0xff004400,
	    0xff1a661a,
	    0xff328432,
	    0xff48a048,
	    0xff5cba5c,
	    0xff6fd26f,
	    0xff80e880,
	    0xff90fc90,
	    0xff003c14,
	    0xff185f35,
	    0xff2d7e52,
	    0xff429c6e,
	    0xff54b787,
	    0xff65d09e,
	    0xff75e7b4,
	    0xff84fcc8,
	    0xff003830,
	    0xff165950,
	    0xff2b766d,
	    0xff3e9288,
	    0xff4faba0,
	    0xff5fc2b7,
	    0xff6ed8cc,
	    0xff7cece0,
	    0xff002c48,
	    0xff144d69,
	    0xff266a86,
	    0xff3886a2,
	    0xff479fbb,
	    0xff56b6d2,
	    0xff63cce8,
	    0xff70e0fc
	]);
	const PAL = new Uint32Array([
	    0xff000000,
	    0xff2b2b2b,
	    0xff525252,
	    0xff767676,
	    0xff979797,
	    0xffb6b6b6,
	    0xffd2d2d2,
	    0xffececec,
	    0xff000000,
	    0xff2b2b2b,
	    0xff525252,
	    0xff767676,
	    0xff979797,
	    0xffb6b6b6,
	    0xffd2d2d2,
	    0xffececec,
	    0xff005880,
	    0xff1a7196,
	    0xff3287ab,
	    0xff489cbe,
	    0xff5cafcf,
	    0xff6fc0df,
	    0xff80d1ee,
	    0xff90e0fc,
	    0xff005c44,
	    0xff1a795e,
	    0xff329376,
	    0xff48ac8c,
	    0xff5cc2a0,
	    0xff6fd7b3,
	    0xff80eac4,
	    0xff90fcd4,
	    0xff003470,
	    0xff1a5189,
	    0xff326ba0,
	    0xff4884b6,
	    0xff5c9ac9,
	    0xff6fafdc,
	    0xff80c2ec,
	    0xff90d4fc,
	    0xff146400,
	    0xff35801a,
	    0xff529832,
	    0xff6eb048,
	    0xff87c55c,
	    0xff9ed96f,
	    0xffb4eb80,
	    0xffc8fc90,
	    0xff140070,
	    0xff351a89,
	    0xff5232a0,
	    0xff6e48b6,
	    0xff875cc9,
	    0xff9e6fdc,
	    0xffb480ec,
	    0xffc890fc,
	    0xff5c5c00,
	    0xff76761a,
	    0xff8e8e32,
	    0xffa4a448,
	    0xffb8b85c,
	    0xffcbcb6f,
	    0xffdcdc80,
	    0xffecec90,
	    0xff5c0070,
	    0xff741a84,
	    0xff893296,
	    0xff9e48a8,
	    0xffb05cb7,
	    0xffc16fc6,
	    0xffd180d3,
	    0xffe090e0,
	    0xff703c00,
	    0xff895a19,
	    0xffa0752f,
	    0xffb68e44,
	    0xffc9a557,
	    0xffdcba68,
	    0xffecce79,
	    0xfffce088,
	    0xff700058,
	    0xff891a6e,
	    0xffa03283,
	    0xffb64896,
	    0xffc95ca7,
	    0xffdc6fb7,
	    0xffec80c6,
	    0xfffc90d4,
	    0xff702000,
	    0xff893f19,
	    0xffa05a2f,
	    0xffb67444,
	    0xffc98b57,
	    0xffdca168,
	    0xffecb579,
	    0xfffcc888,
	    0xff800034,
	    0xff961a4a,
	    0xffab325f,
	    0xffbe4872,
	    0xffcf5c83,
	    0xffdf6f93,
	    0xffee80a2,
	    0xfffc90b0,
	    0xff880000,
	    0xff9d1a1a,
	    0xffb03232,
	    0xffc24848,
	    0xffd25c5c,
	    0xffe16f6f,
	    0xffef8080,
	    0xfffc9090,
	    0xff000000,
	    0xff2b2b2b,
	    0xff525252,
	    0xff767676,
	    0xff979797,
	    0xffb6b6b6,
	    0xffd2d2d2,
	    0xffececec,
	    0xff000000,
	    0xff2b2b2b,
	    0xff525252,
	    0xff767676,
	    0xff979797,
	    0xffb6b6b6,
	    0xffd2d2d2,
	    0xffececec
	]);
	const SECAM = new Uint32Array([
	    0xff000000,
	    0xffff2121,
	    0xff793cf0,
	    0xffff50ff,
	    0xff00ff7f,
	    0xffffff7f,
	    0xff3fffff,
	    0xffffffff,
	    0xff000000,
	    0xffff2121,
	    0xff793cf0,
	    0xffff50ff,
	    0xff00ff7f,
	    0xffffff7f,
	    0xff3fffff,
	    0xffffffff,
	    0xff000000,
	    0xffff2121,
	    0xff793cf0,
	    0xffff50ff,
	    0xff00ff7f,
	    0xffffff7f,
	    0xff3fffff,
	    0xffffffff,
	    0xff000000,
	    0xffff2121,
	    0xff793cf0,
	    0xffff50ff,
	    0xff00ff7f,
	    0xffffff7f,
	    0xff3fffff,
	    0xffffffff,
	    0xff000000,
	    0xffff2121,
	    0xff793cf0,
	    0xffff50ff,
	    0xff00ff7f,
	    0xffffff7f,
	    0xff3fffff,
	    0xffffffff,
	    0xff000000,
	    0xffff2121,
	    0xff793cf0,
	    0xffff50ff,
	    0xff00ff7f,
	    0xffffff7f,
	    0xff3fffff,
	    0xffffffff,
	    0xff000000,
	    0xffff2121,
	    0xff793cf0,
	    0xffff50ff,
	    0xff00ff7f,
	    0xffffff7f,
	    0xff3fffff,
	    0xffffffff,
	    0xff000000,
	    0xffff2121,
	    0xff793cf0,
	    0xffff50ff,
	    0xff00ff7f,
	    0xffffff7f,
	    0xff3fffff,
	    0xffffffff,
	    0xff000000,
	    0xffff2121,
	    0xff793cf0,
	    0xffff50ff,
	    0xff00ff7f,
	    0xffffff7f,
	    0xff3fffff,
	    0xffffffff,
	    0xff000000,
	    0xffff2121,
	    0xff793cf0,
	    0xffff50ff,
	    0xff00ff7f,
	    0xffffff7f,
	    0xff3fffff,
	    0xffffffff,
	    0xff000000,
	    0xffff2121,
	    0xff793cf0,
	    0xffff50ff,
	    0xff00ff7f,
	    0xffffff7f,
	    0xff3fffff,
	    0xffffffff,
	    0xff000000,
	    0xffff2121,
	    0xff793cf0,
	    0xffff50ff,
	    0xff00ff7f,
	    0xffffff7f,
	    0xff3fffff,
	    0xffffffff,
	    0xff000000,
	    0xffff2121,
	    0xff793cf0,
	    0xffff50ff,
	    0xff00ff7f,
	    0xffffff7f,
	    0xff3fffff,
	    0xffffffff,
	    0xff000000,
	    0xffff2121,
	    0xff793cf0,
	    0xffff50ff,
	    0xff00ff7f,
	    0xffffff7f,
	    0xff3fffff,
	    0xffffffff,
	    0xff000000,
	    0xffff2121,
	    0xff793cf0,
	    0xffff50ff,
	    0xff00ff7f,
	    0xffffff7f,
	    0xff3fffff,
	    0xffffffff,
	    0xff000000,
	    0xffff2121,
	    0xff793cf0,
	    0xffff50ff,
	    0xff00ff7f,
	    0xffffff7f,
	    0xff3fffff,
	    0xffffffff
	]);

	class Tia {
	    constructor(_config, joystick0, joystick1, paddles) {
	        this._config = _config;
	        this.newFrame = new lib_1();
	        this.trap = new lib_1();
	        this._cpu = null;
	        this._bus = null;
	        this._delayQueue = new DelayQueue(10, 20);
	        this._hstate = 0;
	        this._hctr = 0;
	        this._collisionUpdateRequired = false;
	        this._movementClock = 0;
	        this._movementInProgress = false;
	        this._extendedHblank = false;
	        this._xDelta = 0;
	        this._linesSinceChange = 0;
	        this._maxLinesTotal = 0;
	        this._colorBk = 0xff000000;
	        this._priority = 0;
	        this._collisionMask = 0;
	        this._player0 = new Player(31744, () => this._flushLineCache());
	        this._player1 = new Player(17344, () => this._flushLineCache());
	        this._missile0 = new Missile(8760, () => this._flushLineCache());
	        this._missile1 = new Missile(4390, () => this._flushLineCache());
	        this._playfield = new Playfield(1099, () => this._flushLineCache());
	        this._ball = new Ball(2197, () => this._flushLineCache());
	        this._waveformAudio = new Array(2);
	        this._pcmAudio = null;
	        this._audio = new Array(2);
	        this._frameManager = new FrameManager(this._config);
	        this._frameManager.newFrame.addHandler(Tia._onNewFrame, this);
	        this._palette = this._getPalette(this._config);
	        this._input0 = new LatchedInput(joystick0.getFire());
	        this._input1 = new LatchedInput(joystick1.getFire());
	        this._pcmAudio = new PCMAudio(this._config);
	        const pcmChannels = this._pcmAudio.getChannels();
	        for (let i = 0; i < 2; i++) {
	            this._waveformAudio[i] = new WaveformAudio(this._config);
	            this._audio[i] = this._config.pcmAudio ? pcmChannels[i] : this._waveformAudio[i];
	        }
	        const clockFreq = this._getClockFreq(this._config);
	        this._paddles = new Array(4);
	        for (let i = 0; i < 4; i++) {
	            this._paddles[i] = new PaddleReader(clockFreq, paddles[i]);
	        }
	        this.reset();
	    }
	    reset() {
	        this._hctr = 0;
	        this._movementInProgress = false;
	        this._extendedHblank = false;
	        this._movementClock = 0;
	        this._priority = 0;
	        this._hstate = 0;
	        this._collisionMask = 0;
	        this._colorBk = 0xff000000;
	        this._linesSinceChange = 0;
	        this._collisionUpdateRequired = false;
	        this._maxLinesTotal = 0;
	        this._xDelta = 0;
	        this._delayQueue.reset();
	        this._frameManager.reset();
	        this._missile0.reset();
	        this._missile1.reset();
	        this._player0.reset();
	        this._player1.reset();
	        this._playfield.reset();
	        this._ball.reset();
	        this._audio[0].reset();
	        this._audio[1].reset();
	        this._input0.reset();
	        this._input1.reset();
	        for (let i = 0; i < 4; i++) {
	            this._paddles[i].reset();
	        }
	        if (this._cpu) {
	            this._cpu.resume();
	        }
	    }
	    setCpu(cpu) {
	        this._cpu = cpu;
	        return this;
	    }
	    setCpuTimeProvider(provider) {
	        for (let i = 0; i < 4; i++) {
	            this._paddles[i].setCpuTimeProvider(provider);
	        }
	        return this;
	    }
	    getWidth() {
	        return 160;
	    }
	    getHeight() {
	        return this._frameManager.getHeight();
	    }
	    setSurfaceFactory(factory) {
	        this._frameManager.setSurfaceFactory(factory);
	        return this;
	    }
	    getWaveformChannel(i) {
	        return this._waveformAudio[i];
	    }
	    getPCMChannel() {
	        return this._pcmAudio;
	    }
	    setAudioEnabled(state) {
	        this._audio[0].setActive(state && this._config.enableAudio);
	        this._audio[1].setActive(state && this._config.enableAudio);
	    }
	    read(address) {
	        const lastDataBusValue = this._bus.getLastDataBusValue();
	        let result;
	        switch (address & 0x0f) {
	            case 8:
	                result = (this._config.emulatePaddles ? this._paddles[0].inpt() : 0) | (lastDataBusValue & 0x40);
	                break;
	            case 9:
	                result = (this._config.emulatePaddles ? this._paddles[1].inpt() : 0) | (lastDataBusValue & 0x40);
	                break;
	            case 10:
	                result = (this._config.emulatePaddles ? this._paddles[2].inpt() : 0) | (lastDataBusValue & 0x40);
	                break;
	            case 11:
	                result = (this._config.emulatePaddles ? this._paddles[3].inpt() : 0) | (lastDataBusValue & 0x40);
	                break;
	            case 12:
	                result = this._input0.inpt() | (lastDataBusValue & 0x40);
	                break;
	            case 13:
	                result = this._input1.inpt() | (lastDataBusValue & 0x40);
	                break;
	            case 0:
	                result =
	                    (this._collisionMask & 8760 & 31744 ? 0x40 : 0) |
	                        (this._collisionMask & 8760 & 17344 ? 0x80 : 0);
	                break;
	            case 1:
	                result =
	                    (this._collisionMask & 4390 & 17344 ? 0x40 : 0) |
	                        (this._collisionMask & 4390 & 31744 ? 0x80 : 0);
	                break;
	            case 2:
	                result =
	                    (this._collisionMask & 31744 & 2197 ? 0x40 : 0) |
	                        (this._collisionMask & 31744 & 1099 ? 0x80 : 0);
	                break;
	            case 3:
	                result =
	                    (this._collisionMask & 17344 & 2197 ? 0x40 : 0) |
	                        (this._collisionMask & 17344 & 1099 ? 0x80 : 0);
	                break;
	            case 4:
	                result =
	                    (this._collisionMask & 8760 & 2197 ? 0x40 : 0) |
	                        (this._collisionMask & 8760 & 1099 ? 0x80 : 0);
	                break;
	            case 5:
	                result =
	                    (this._collisionMask & 4390 & 2197 ? 0x40 : 0) |
	                        (this._collisionMask & 4390 & 1099 ? 0x80 : 0);
	                break;
	            case 7:
	                result =
	                    (this._collisionMask & 8760 & 4390 ? 0x40 : 0) |
	                        (this._collisionMask & 31744 & 17344 ? 0x80 : 0);
	                break;
	            case 6:
	                result = this._collisionMask & 2197 & 1099 ? 0x80 : 0;
	                break;
	            default:
	                result = 0;
	                break;
	        }
	        return (result & 0xc0) | (lastDataBusValue & 0x3f);
	    }
	    peek(address) {
	        return this.read(address);
	    }
	    write(address, value) {
	        let v = 0;
	        switch (address & 0x3f) {
	            case 2:
	                this._cpu.halt();
	                break;
	            case 3:
	                this._flushLineCache();
	                this._rsync();
	                break;
	            case 0:
	                this._frameManager.setVsync((value & 0x02) > 0);
	                break;
	            case 1:
	                this._input0.vblank(value);
	                this._input1.vblank(value);
	                for (let i = 0; i < 4; i++) {
	                    this._paddles[i].vblank(value);
	                }
	                this._delayQueue.push(1, value, 1);
	                break;
	            case 29:
	                this._delayQueue.push(29, value, 1);
	                break;
	            case 30:
	                this._delayQueue.push(30, value, 1);
	                break;
	            case 34:
	                this._delayQueue.push(34, value, 2);
	                break;
	            case 35:
	                this._delayQueue.push(35, value, 2);
	                break;
	            case 18:
	                this._flushLineCache();
	                this._missile0.resm(this._resxCounter(), this._hstate === 0);
	                break;
	            case 19:
	                this._flushLineCache();
	                this._missile1.resm(this._resxCounter(), this._hstate === 0);
	                break;
	            case 40:
	                this._missile0.resmp(value, this._player0);
	                break;
	            case 41:
	                this._missile1.resmp(value, this._player1);
	                break;
	            case 43:
	                this._delayQueue.push(43, value, 2);
	                break;
	            case 4:
	                this._flushLineCache();
	                this._missile0.nusiz(value);
	                this._player0.nusiz(value, this._hstate === 0);
	                break;
	            case 5:
	                this._flushLineCache();
	                this._missile1.nusiz(value);
	                this._player1.nusiz(value, this._hstate === 0);
	                break;
	            case 42:
	                this._delayQueue.push(42, value, 6);
	                break;
	            case 9:
	                this._flushLineCache();
	                this._colorBk = this._palette[(value & 0xff) >>> 1];
	                break;
	            case 6:
	                v = this._palette[(value & 0xff) >>> 1];
	                this._missile0.setColor(v);
	                this._player0.setColor(v);
	                this._playfield.setColorP0(v);
	                break;
	            case 7:
	                v = this._palette[(value & 0xff) >>> 1];
	                this._missile1.setColor(v);
	                this._player1.setColor(v);
	                this._playfield.setColorP1(v);
	                break;
	            case 13:
	                this._delayQueue.push(13, value, 2);
	                break;
	            case 14:
	                this._delayQueue.push(14, value, 2);
	                break;
	            case 15:
	                this._delayQueue.push(15, value, 2);
	                break;
	            case 10:
	                this._setPriority(value);
	                this._playfield.ctrlpf(value);
	                this._ball.ctrlpf(value);
	                break;
	            case 8:
	                this._flushLineCache();
	                v = this._palette[(value & 0xff) >>> 1];
	                this._playfield.setColor(v);
	                this._ball.color = v;
	                break;
	            case 27:
	                this._delayQueue
	                    .push(27, value, 1)
	                    .push(241, 0, 1);
	                break;
	            case 28:
	                this._delayQueue
	                    .push(28, value, 1)
	                    .push(240, 0, 1)
	                    .push(242, 0, 1);
	                break;
	            case 16:
	                this._flushLineCache();
	                this._player0.resp(this._resxCounter());
	                break;
	            case 17:
	                this._flushLineCache();
	                this._player1.resp(this._resxCounter());
	                break;
	            case 11:
	                this._delayQueue.push(11, value, 1);
	                break;
	            case 12:
	                this._delayQueue.push(12, value, 1);
	                break;
	            case 32:
	                this._delayQueue.push(32, value, 2);
	                break;
	            case 33:
	                this._delayQueue.push(33, value, 2);
	                break;
	            case 37:
	                this._player0.vdelp(value);
	                break;
	            case 38:
	                this._player1.vdelp(value);
	                break;
	            case 31:
	                this._delayQueue.push(31, value, 1);
	                break;
	            case 36:
	                this._delayQueue.push(36, value, 2);
	                break;
	            case 20:
	                this._flushLineCache();
	                this._ball.resbl(this._resxCounter());
	                break;
	            case 39:
	                this._ball.vdelbl(value);
	                break;
	            case 44:
	                this._flushLineCache();
	                this._collisionMask = 0;
	                break;
	            case 21:
	                this._audio[0].audc(value);
	                break;
	            case 22:
	                this._audio[1].audc(value);
	                break;
	            case 23:
	                this._audio[0].audf(value);
	                break;
	            case 24:
	                this._audio[1].audf(value);
	                break;
	            case 25:
	                this._audio[0].audv(value);
	                break;
	            case 26:
	                this._audio[1].audv(value);
	                break;
	        }
	    }
	    getDebugState() {
	        return ('' +
	            `hclock: ${this._hctr}   line: ${this._frameManager.getCurrentLine()}\n` +
	            this._frameManager.getDebugState());
	    }
	    setBus(bus) {
	        this._bus = bus;
	        return this;
	    }
	    cycle() {
	        this._delayQueue.execute(Tia._delayedWrite, this);
	        this._collisionUpdateRequired = false;
	        if (this._linesSinceChange < 2) {
	            this._tickMovement();
	            if (this._hstate === 0) {
	                this._tickHblank();
	            }
	            else {
	                this._tickHframe();
	            }
	            if (this._collisionUpdateRequired && !this._frameManager.vblank) {
	                this._updateCollision();
	            }
	        }
	        else {
	            if (this._hctr === 0) {
	                this._cpu.resume();
	            }
	        }
	        if (++this._hctr >= 228) {
	            this._nextLine();
	        }
	        if (this._config.pcmAudio) {
	            this._pcmAudio.tick();
	        }
	    }
	    static _delayedWrite(address, value, self) {
	        switch (address) {
	            case 1:
	                self._flushLineCache();
	                self._frameManager.setVblank((value & 0x02) > 0);
	                break;
	            case 42:
	                self._flushLineCache();
	                self._movementClock = 0;
	                self._movementInProgress = true;
	                if (!self._extendedHblank) {
	                    self._clearHmoveComb();
	                    self._extendedHblank = true;
	                }
	                self._missile0.startMovement();
	                self._missile1.startMovement();
	                self._player0.startMovement();
	                self._player1.startMovement();
	                self._ball.startMovement();
	                break;
	            case 13:
	                self._playfield.pf0(value);
	                break;
	            case 14:
	                self._playfield.pf1(value);
	                break;
	            case 15:
	                self._playfield.pf2(value);
	                break;
	            case 27:
	                self._player0.grp(value);
	                break;
	            case 28:
	                self._player1.grp(value);
	                break;
	            case 240:
	                self._player0.shufflePatterns();
	                break;
	            case 241:
	                self._player1.shufflePatterns();
	                break;
	            case 32:
	                self._player0.hmp(value);
	                break;
	            case 33:
	                self._player1.hmp(value);
	                break;
	            case 34:
	                self._missile0.hmm(value);
	                break;
	            case 35:
	                self._missile1.hmm(value);
	                break;
	            case 36:
	                self._ball.hmbl(value);
	                break;
	            case 43:
	                self._missile0.hmm(0);
	                self._missile1.hmm(0);
	                self._player0.hmp(0);
	                self._player1.hmp(0);
	                self._ball.hmbl(0);
	                break;
	            case 11:
	                self._player0.refp(value);
	                break;
	            case 12:
	                self._player1.refp(value);
	                break;
	            case 242:
	                self._ball.shuffleStatus();
	                break;
	            case 31:
	                self._ball.enabl(value);
	                break;
	            case 29:
	                self._missile0.enam(value);
	                break;
	            case 30:
	                self._missile1.enam(value);
	                break;
	        }
	    }
	    static _onNewFrame(surface, self) {
	        const linesTotal = self._frameManager.getCurrentLine();
	        if (linesTotal > self._maxLinesTotal) {
	            self._maxLinesTotal = linesTotal;
	        }
	        if (linesTotal < self._maxLinesTotal) {
	            const buffer = surface.getBuffer(), base = 160 * linesTotal, boundary = self._maxLinesTotal * 160;
	            for (let i = base; i < boundary; i++) {
	                buffer[i] = 0xff000000;
	            }
	        }
	        self.newFrame.dispatch(surface);
	    }
	    _tickMovement() {
	        if (!this._movementInProgress) {
	            return;
	        }
	        if ((this._hctr & 0x3) === 0) {
	            const apply = this._hstate === 0;
	            let m = false;
	            const movementCounter = this._movementClock > 15 ? 0 : this._movementClock;
	            m = this._missile0.movementTick(movementCounter, apply) || m;
	            m = this._missile1.movementTick(movementCounter, apply) || m;
	            m = this._player0.movementTick(movementCounter, apply) || m;
	            m = this._player1.movementTick(movementCounter, apply) || m;
	            m = this._ball.movementTick(movementCounter, apply) || m;
	            this._movementInProgress = m;
	            this._collisionUpdateRequired = m;
	            this._movementClock++;
	        }
	    }
	    _tickHblank() {
	        switch (this._hctr) {
	            case 0:
	                this._extendedHblank = false;
	                this._cpu.resume();
	                break;
	            case 67:
	                if (!this._extendedHblank) {
	                    this._hstate = 1;
	                }
	                break;
	            case 75:
	                if (this._extendedHblank) {
	                    this._hstate = 1;
	                }
	                break;
	        }
	        if (this._extendedHblank && this._hctr > 67) {
	            this._playfield.tick(this._hctr - 68 + this._xDelta);
	        }
	    }
	    _tickHframe() {
	        const y = this._frameManager.getCurrentLine(), x = this._hctr - 68 + this._xDelta;
	        this._collisionUpdateRequired = true;
	        this._playfield.tick(x);
	        this._tickSprites();
	        if (this._frameManager.isRendering()) {
	            this._renderPixel(x, y);
	        }
	    }
	    _tickSprites() {
	        this._missile0.tick(true);
	        this._missile1.tick(true);
	        this._player0.tick();
	        this._player1.tick();
	        this._ball.tick(true);
	    }
	    _nextLine() {
	        if (this._linesSinceChange >= 2) {
	            this._cloneLastLine();
	        }
	        this._hctr = 0;
	        this._playfield.tick(0);
	        if (!this._movementInProgress) {
	            this._linesSinceChange++;
	        }
	        this._hstate = 0;
	        this._xDelta = 0;
	        this._frameManager.nextLine();
	        if (this._frameManager.isRendering() && this._frameManager.getCurrentLine() === 0) {
	            this._flushLineCache();
	        }
	    }
	    _cloneLastLine() {
	        const y = this._frameManager.getCurrentLine();
	        if (!this._frameManager.isRendering() || y === 0) {
	            return;
	        }
	        const delta = y * 160, prevDelta = (y - 1) * 160;
	        for (let x = 0; x < 160; x++) {
	            this._frameManager.surfaceBuffer[delta + x] = this._frameManager.surfaceBuffer[prevDelta + x];
	        }
	    }
	    _getPalette(config) {
	        switch (config.tvMode) {
	            case 0:
	                return NTSC;
	            case 1:
	                return PAL;
	            case 2:
	                return SECAM;
	            default:
	                throw new Error('invalid TV mode');
	        }
	    }
	    _getClockFreq(config) {
	        return config.tvMode === 0
	            ? 60 * 228 * 262
	            : 50 * 228 * 312;
	    }
	    _renderPixel(x, y) {
	        if (this._frameManager.vblank) {
	            this._frameManager.surfaceBuffer[y * 160 + x] = 0xff000000;
	            return;
	        }
	        let color = this._colorBk;
	        switch (this._priority) {
	            case 0:
	                color = this._playfield.getPixel(color);
	                color = this._ball.getPixel(color);
	                color = this._missile1.getPixel(color);
	                color = this._player1.getPixel(color);
	                color = this._missile0.getPixel(color);
	                color = this._player0.getPixel(color);
	                break;
	            case 1:
	                color = this._missile1.getPixel(color);
	                color = this._player1.getPixel(color);
	                color = this._missile0.getPixel(color);
	                color = this._player0.getPixel(color);
	                color = this._playfield.getPixel(color);
	                color = this._ball.getPixel(color);
	                break;
	            case 2:
	                color = this._ball.getPixel(color);
	                color = this._missile1.getPixel(color);
	                color = this._player1.getPixel(color);
	                color = this._playfield.getPixel(color);
	                color = this._missile0.getPixel(color);
	                color = this._player0.getPixel(color);
	                break;
	            default:
	                throw new Error('invalid priority');
	        }
	        this._frameManager.surfaceBuffer[y * 160 + x] = color;
	    }
	    _updateCollision() {
	        this._collisionMask |=
	            ~this._player0.collision &
	                ~this._player1.collision &
	                ~this._missile0.collision &
	                ~this._missile1.collision &
	                ~this._ball.collision &
	                ~this._playfield.collision;
	    }
	    _clearHmoveComb() {
	        if (this._frameManager.isRendering() && this._hstate === 0) {
	            const offset = this._frameManager.getCurrentLine() * 160;
	            for (let i = 0; i < 8; i++) {
	                this._frameManager.surfaceBuffer[offset + i] = 0xff000000;
	            }
	        }
	    }
	    _resxCounter() {
	        return this._hstate === 0
	            ? this._hctr >= 73
	                ? 158
	                : 159
	            : 157;
	    }
	    _rsync() {
	        const x = this._hctr > 68 ? this._hctr - 68 : 0;
	        this._xDelta = 157 - x;
	        if (this._frameManager.isRendering()) {
	            const y = this._frameManager.getCurrentLine(), base = y * 160 + x, boundary = base + (y + 1) * 160;
	            for (let i = base; i < boundary; i++) {
	                this._frameManager.surfaceBuffer[i] = 0xff000000;
	            }
	        }
	        this._hctr = 225;
	    }
	    _setPriority(value) {
	        const priority = value & 0x04 ? 1 : value & 0x02 ? 2 : 0;
	        if (priority !== this._priority) {
	            this._flushLineCache();
	            this._priority = priority;
	        }
	    }
	    _flushLineCache() {
	        const wasCaching = this._linesSinceChange >= 2;
	        this._linesSinceChange = 0;
	        if (wasCaching) {
	            const rewindCycles = this._hctr;
	            for (this._hctr = 0; this._hctr < rewindCycles; this._hctr++) {
	                if (this._hstate === 0) {
	                    this._tickHblank();
	                }
	                else {
	                    this._tickHframe();
	                }
	            }
	        }
	    }
	}
	(function (Tia) {
	    class TrapPayload {
	        constructor(reason, tia, message) {
	            this.reason = reason;
	            this.tia = tia;
	            this.message = message;
	        }
	    }
	    Tia.TrapPayload = TrapPayload;
	})(Tia || (Tia = {}));

	class Switch {
	    constructor(_state = false) {
	        this._state = _state;
	        this.stateChanged = new lib_1();
	        this.beforeRead = new lib_1();
	    }
	    read() {
	        this.beforeRead.dispatch(this);
	        return this._state;
	    }
	    peek() {
	        return this._state;
	    }
	    toggle(state) {
	        if (this._state === state) {
	            return;
	        }
	        this._state = state;
	        this.stateChanged.dispatch(state);
	    }
	}

	class ControlPanel {
	    constructor() {
	        this._selectSwitch = new Switch();
	        this._resetButton = new Switch();
	        this._colorSwitch = new Switch();
	        this._difficutlyP0 = new Switch();
	        this._difficutlyP1 = new Switch();
	    }
	    getSelectSwitch() {
	        return this._selectSwitch;
	    }
	    getResetButton() {
	        return this._resetButton;
	    }
	    getColorSwitch() {
	        return this._colorSwitch;
	    }
	    getDifficultySwitchP0() {
	        return this._difficutlyP0;
	    }
	    getDifficultySwitchP1() {
	        return this._difficutlyP1;
	    }
	}

	class DigitalJoystick {
	    constructor() {
	        this._left = new Switch();
	        this._right = new Switch();
	        this._up = new Switch();
	        this._down = new Switch();
	        this._fire = new Switch();
	    }
	    getLeft() {
	        return this._left;
	    }
	    getRight() {
	        return this._right;
	    }
	    getUp() {
	        return this._up;
	    }
	    getDown() {
	        return this._down;
	    }
	    getFire() {
	        return this._fire;
	    }
	}

	class Paddle {
	    constructor() {
	        this.valueChanged = new lib_1();
	        this._fireSwitch = new Switch();
	        this._value = 0.5;
	    }
	    setValue(value) {
	        this._value = value;
	        this.valueChanged.dispatch(value);
	    }
	    getValue() {
	        return this._value;
	    }
	    getFire() {
	        return this._fireSwitch;
	    }
	}

	var alea = createCommonjsModule(function (module) {
	// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
	// http://baagoe.com/en/RandomMusings/javascript/
	// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
	// Original work is under MIT license -

	// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.



	(function(global, module, define) {

	function Alea(seed) {
	  var me = this, mash = Mash();

	  me.next = function() {
	    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
	    me.s0 = me.s1;
	    me.s1 = me.s2;
	    return me.s2 = t - (me.c = t | 0);
	  };

	  // Apply the seeding algorithm from Baagoe.
	  me.c = 1;
	  me.s0 = mash(' ');
	  me.s1 = mash(' ');
	  me.s2 = mash(' ');
	  me.s0 -= mash(seed);
	  if (me.s0 < 0) { me.s0 += 1; }
	  me.s1 -= mash(seed);
	  if (me.s1 < 0) { me.s1 += 1; }
	  me.s2 -= mash(seed);
	  if (me.s2 < 0) { me.s2 += 1; }
	  mash = null;
	}

	function copy(f, t) {
	  t.c = f.c;
	  t.s0 = f.s0;
	  t.s1 = f.s1;
	  t.s2 = f.s2;
	  return t;
	}

	function impl(seed, opts) {
	  var xg = new Alea(seed),
	      state = opts && opts.state,
	      prng = xg.next;
	  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; };
	  prng.double = function() {
	    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
	  };
	  prng.quick = prng;
	  if (state) {
	    if (typeof(state) == 'object') copy(state, xg);
	    prng.state = function() { return copy(xg, {}); };
	  }
	  return prng;
	}

	function Mash() {
	  var n = 0xefc8249d;

	  var mash = function(data) {
	    data = String(data);
	    for (var i = 0; i < data.length; i++) {
	      n += data.charCodeAt(i);
	      var h = 0.02519603282416938 * n;
	      n = h >>> 0;
	      h -= n;
	      h *= n;
	      n = h >>> 0;
	      h -= n;
	      n += h * 0x100000000; // 2^32
	    }
	    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
	  };

	  return mash;
	}


	if (module && module.exports) {
	  module.exports = impl;
	} else if (define && define.amd) {
	  define(function() { return impl; });
	} else {
	  this.alea = impl;
	}

	})(
	  commonjsGlobal,
	   module,    // present in node.js
	  (typeof undefined) == 'function'    // present with an AMD loader
	);
	});

	var xor128 = createCommonjsModule(function (module) {
	// A Javascript implementaion of the "xor128" prng algorithm by
	// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

	(function(global, module, define) {

	function XorGen(seed) {
	  var me = this, strseed = '';

	  me.x = 0;
	  me.y = 0;
	  me.z = 0;
	  me.w = 0;

	  // Set up generator function.
	  me.next = function() {
	    var t = me.x ^ (me.x << 11);
	    me.x = me.y;
	    me.y = me.z;
	    me.z = me.w;
	    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
	  };

	  if (seed === (seed | 0)) {
	    // Integer seed.
	    me.x = seed;
	  } else {
	    // String seed.
	    strseed += seed;
	  }

	  // Mix in string seed, then discard an initial batch of 64 values.
	  for (var k = 0; k < strseed.length + 64; k++) {
	    me.x ^= strseed.charCodeAt(k) | 0;
	    me.next();
	  }
	}

	function copy(f, t) {
	  t.x = f.x;
	  t.y = f.y;
	  t.z = f.z;
	  t.w = f.w;
	  return t;
	}

	function impl(seed, opts) {
	  var xg = new XorGen(seed),
	      state = opts && opts.state,
	      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
	  prng.double = function() {
	    do {
	      var top = xg.next() >>> 11,
	          bot = (xg.next() >>> 0) / 0x100000000,
	          result = (top + bot) / (1 << 21);
	    } while (result === 0);
	    return result;
	  };
	  prng.int32 = xg.next;
	  prng.quick = prng;
	  if (state) {
	    if (typeof(state) == 'object') copy(state, xg);
	    prng.state = function() { return copy(xg, {}); };
	  }
	  return prng;
	}

	if (module && module.exports) {
	  module.exports = impl;
	} else if (define && define.amd) {
	  define(function() { return impl; });
	} else {
	  this.xor128 = impl;
	}

	})(
	  commonjsGlobal,
	   module,    // present in node.js
	  (typeof undefined) == 'function'    // present with an AMD loader
	);
	});

	var xorwow = createCommonjsModule(function (module) {
	// A Javascript implementaion of the "xorwow" prng algorithm by
	// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

	(function(global, module, define) {

	function XorGen(seed) {
	  var me = this, strseed = '';

	  // Set up generator function.
	  me.next = function() {
	    var t = (me.x ^ (me.x >>> 2));
	    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
	    return (me.d = (me.d + 362437 | 0)) +
	       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
	  };

	  me.x = 0;
	  me.y = 0;
	  me.z = 0;
	  me.w = 0;
	  me.v = 0;

	  if (seed === (seed | 0)) {
	    // Integer seed.
	    me.x = seed;
	  } else {
	    // String seed.
	    strseed += seed;
	  }

	  // Mix in string seed, then discard an initial batch of 64 values.
	  for (var k = 0; k < strseed.length + 64; k++) {
	    me.x ^= strseed.charCodeAt(k) | 0;
	    if (k == strseed.length) {
	      me.d = me.x << 10 ^ me.x >>> 4;
	    }
	    me.next();
	  }
	}

	function copy(f, t) {
	  t.x = f.x;
	  t.y = f.y;
	  t.z = f.z;
	  t.w = f.w;
	  t.v = f.v;
	  t.d = f.d;
	  return t;
	}

	function impl(seed, opts) {
	  var xg = new XorGen(seed),
	      state = opts && opts.state,
	      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
	  prng.double = function() {
	    do {
	      var top = xg.next() >>> 11,
	          bot = (xg.next() >>> 0) / 0x100000000,
	          result = (top + bot) / (1 << 21);
	    } while (result === 0);
	    return result;
	  };
	  prng.int32 = xg.next;
	  prng.quick = prng;
	  if (state) {
	    if (typeof(state) == 'object') copy(state, xg);
	    prng.state = function() { return copy(xg, {}); };
	  }
	  return prng;
	}

	if (module && module.exports) {
	  module.exports = impl;
	} else if (define && define.amd) {
	  define(function() { return impl; });
	} else {
	  this.xorwow = impl;
	}

	})(
	  commonjsGlobal,
	   module,    // present in node.js
	  (typeof undefined) == 'function'    // present with an AMD loader
	);
	});

	var xorshift7 = createCommonjsModule(function (module) {
	// A Javascript implementaion of the "xorshift7" algorithm by
	// François Panneton and Pierre L'ecuyer:
	// "On the Xorgshift Random Number Generators"
	// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

	(function(global, module, define) {

	function XorGen(seed) {
	  var me = this;

	  // Set up generator function.
	  me.next = function() {
	    // Update xor generator.
	    var X = me.x, i = me.i, t, v;
	    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
	    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
	    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
	    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
	    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
	    X[i] = v;
	    me.i = (i + 1) & 7;
	    return v;
	  };

	  function init(me, seed) {
	    var j, w, X = [];

	    if (seed === (seed | 0)) {
	      // Seed state array using a 32-bit integer.
	      w = X[0] = seed;
	    } else {
	      // Seed state using a string.
	      seed = '' + seed;
	      for (j = 0; j < seed.length; ++j) {
	        X[j & 7] = (X[j & 7] << 15) ^
	            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
	      }
	    }
	    // Enforce an array length of 8, not all zeroes.
	    while (X.length < 8) X.push(0);
	    for (j = 0; j < 8 && X[j] === 0; ++j);
	    if (j == 8) w = X[7] = -1; else w = X[j];

	    me.x = X;
	    me.i = 0;

	    // Discard an initial 256 values.
	    for (j = 256; j > 0; --j) {
	      me.next();
	    }
	  }

	  init(me, seed);
	}

	function copy(f, t) {
	  t.x = f.x.slice();
	  t.i = f.i;
	  return t;
	}

	function impl(seed, opts) {
	  if (seed == null) seed = +(new Date);
	  var xg = new XorGen(seed),
	      state = opts && opts.state,
	      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
	  prng.double = function() {
	    do {
	      var top = xg.next() >>> 11,
	          bot = (xg.next() >>> 0) / 0x100000000,
	          result = (top + bot) / (1 << 21);
	    } while (result === 0);
	    return result;
	  };
	  prng.int32 = xg.next;
	  prng.quick = prng;
	  if (state) {
	    if (state.x) copy(state, xg);
	    prng.state = function() { return copy(xg, {}); };
	  }
	  return prng;
	}

	if (module && module.exports) {
	  module.exports = impl;
	} else if (define && define.amd) {
	  define(function() { return impl; });
	} else {
	  this.xorshift7 = impl;
	}

	})(
	  commonjsGlobal,
	   module,    // present in node.js
	  (typeof undefined) == 'function'    // present with an AMD loader
	);
	});

	var xor4096 = createCommonjsModule(function (module) {
	// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
	//
	// This fast non-cryptographic random number generator is designed for
	// use in Monte-Carlo algorithms. It combines a long-period xorshift
	// generator with a Weyl generator, and it passes all common batteries
	// of stasticial tests for randomness while consuming only a few nanoseconds
	// for each prng generated.  For background on the generator, see Brent's
	// paper: "Some long-period random number generators using shifts and xors."
	// http://arxiv.org/pdf/1004.3115v1.pdf
	//
	// Usage:
	//
	// var xor4096 = require('xor4096');
	// random = xor4096(1);                        // Seed with int32 or string.
	// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
	// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
	//
	// For nonzero numeric keys, this impelementation provides a sequence
	// identical to that by Brent's xorgens 3 implementaion in C.  This
	// implementation also provides for initalizing the generator with
	// string seeds, or for saving and restoring the state of the generator.
	//
	// On Chrome, this prng benchmarks about 2.1 times slower than
	// Javascript's built-in Math.random().

	(function(global, module, define) {

	function XorGen(seed) {
	  var me = this;

	  // Set up generator function.
	  me.next = function() {
	    var w = me.w,
	        X = me.X, i = me.i, t, v;
	    // Update Weyl generator.
	    me.w = w = (w + 0x61c88647) | 0;
	    // Update xor generator.
	    v = X[(i + 34) & 127];
	    t = X[i = ((i + 1) & 127)];
	    v ^= v << 13;
	    t ^= t << 17;
	    v ^= v >>> 15;
	    t ^= t >>> 12;
	    // Update Xor generator array state.
	    v = X[i] = v ^ t;
	    me.i = i;
	    // Result is the combination.
	    return (v + (w ^ (w >>> 16))) | 0;
	  };

	  function init(me, seed) {
	    var t, v, i, j, w, X = [], limit = 128;
	    if (seed === (seed | 0)) {
	      // Numeric seeds initialize v, which is used to generates X.
	      v = seed;
	      seed = null;
	    } else {
	      // String seeds are mixed into v and X one character at a time.
	      seed = seed + '\0';
	      v = 0;
	      limit = Math.max(limit, seed.length);
	    }
	    // Initialize circular array and weyl value.
	    for (i = 0, j = -32; j < limit; ++j) {
	      // Put the unicode characters into the array, and shuffle them.
	      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
	      // After 32 shuffles, take v as the starting w value.
	      if (j === 0) w = v;
	      v ^= v << 10;
	      v ^= v >>> 15;
	      v ^= v << 4;
	      v ^= v >>> 13;
	      if (j >= 0) {
	        w = (w + 0x61c88647) | 0;     // Weyl.
	        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
	        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
	      }
	    }
	    // We have detected all zeroes; make the key nonzero.
	    if (i >= 128) {
	      X[(seed && seed.length || 0) & 127] = -1;
	    }
	    // Run the generator 512 times to further mix the state before using it.
	    // Factoring this as a function slows the main generator, so it is just
	    // unrolled here.  The weyl generator is not advanced while warming up.
	    i = 127;
	    for (j = 4 * 128; j > 0; --j) {
	      v = X[(i + 34) & 127];
	      t = X[i = ((i + 1) & 127)];
	      v ^= v << 13;
	      t ^= t << 17;
	      v ^= v >>> 15;
	      t ^= t >>> 12;
	      X[i] = v ^ t;
	    }
	    // Storing state as object members is faster than using closure variables.
	    me.w = w;
	    me.X = X;
	    me.i = i;
	  }

	  init(me, seed);
	}

	function copy(f, t) {
	  t.i = f.i;
	  t.w = f.w;
	  t.X = f.X.slice();
	  return t;
	}
	function impl(seed, opts) {
	  if (seed == null) seed = +(new Date);
	  var xg = new XorGen(seed),
	      state = opts && opts.state,
	      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
	  prng.double = function() {
	    do {
	      var top = xg.next() >>> 11,
	          bot = (xg.next() >>> 0) / 0x100000000,
	          result = (top + bot) / (1 << 21);
	    } while (result === 0);
	    return result;
	  };
	  prng.int32 = xg.next;
	  prng.quick = prng;
	  if (state) {
	    if (state.X) copy(state, xg);
	    prng.state = function() { return copy(xg, {}); };
	  }
	  return prng;
	}

	if (module && module.exports) {
	  module.exports = impl;
	} else if (define && define.amd) {
	  define(function() { return impl; });
	} else {
	  this.xor4096 = impl;
	}

	})(
	  commonjsGlobal,                                     // window object or global
	   module,    // present in node.js
	  (typeof undefined) == 'function'    // present with an AMD loader
	);
	});

	var tychei = createCommonjsModule(function (module) {
	// A Javascript implementaion of the "Tyche-i" prng algorithm by
	// Samuel Neves and Filipe Araujo.
	// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

	(function(global, module, define) {

	function XorGen(seed) {
	  var me = this, strseed = '';

	  // Set up generator function.
	  me.next = function() {
	    var b = me.b, c = me.c, d = me.d, a = me.a;
	    b = (b << 25) ^ (b >>> 7) ^ c;
	    c = (c - d) | 0;
	    d = (d << 24) ^ (d >>> 8) ^ a;
	    a = (a - b) | 0;
	    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
	    me.c = c = (c - d) | 0;
	    me.d = (d << 16) ^ (c >>> 16) ^ a;
	    return me.a = (a - b) | 0;
	  };

	  /* The following is non-inverted tyche, which has better internal
	   * bit diffusion, but which is about 25% slower than tyche-i in JS.
	  me.next = function() {
	    var a = me.a, b = me.b, c = me.c, d = me.d;
	    a = (me.a + me.b | 0) >>> 0;
	    d = me.d ^ a; d = d << 16 ^ d >>> 16;
	    c = me.c + d | 0;
	    b = me.b ^ c; b = b << 12 ^ d >>> 20;
	    me.a = a = a + b | 0;
	    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
	    me.c = c = c + d | 0;
	    b = b ^ c;
	    return me.b = (b << 7 ^ b >>> 25);
	  }
	  */

	  me.a = 0;
	  me.b = 0;
	  me.c = 2654435769 | 0;
	  me.d = 1367130551;

	  if (seed === Math.floor(seed)) {
	    // Integer seed.
	    me.a = (seed / 0x100000000) | 0;
	    me.b = seed | 0;
	  } else {
	    // String seed.
	    strseed += seed;
	  }

	  // Mix in string seed, then discard an initial batch of 64 values.
	  for (var k = 0; k < strseed.length + 20; k++) {
	    me.b ^= strseed.charCodeAt(k) | 0;
	    me.next();
	  }
	}

	function copy(f, t) {
	  t.a = f.a;
	  t.b = f.b;
	  t.c = f.c;
	  t.d = f.d;
	  return t;
	}
	function impl(seed, opts) {
	  var xg = new XorGen(seed),
	      state = opts && opts.state,
	      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
	  prng.double = function() {
	    do {
	      var top = xg.next() >>> 11,
	          bot = (xg.next() >>> 0) / 0x100000000,
	          result = (top + bot) / (1 << 21);
	    } while (result === 0);
	    return result;
	  };
	  prng.int32 = xg.next;
	  prng.quick = prng;
	  if (state) {
	    if (typeof(state) == 'object') copy(state, xg);
	    prng.state = function() { return copy(xg, {}); };
	  }
	  return prng;
	}

	if (module && module.exports) {
	  module.exports = impl;
	} else if (define && define.amd) {
	  define(function() { return impl; });
	} else {
	  this.tychei = impl;
	}

	})(
	  commonjsGlobal,
	   module,    // present in node.js
	  (typeof undefined) == 'function'    // present with an AMD loader
	);
	});

	var require$$0 = {};

	var seedrandom = createCommonjsModule(function (module) {
	/*
	Copyright 2019 David Bau.

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	"Software"), to deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:

	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	*/

	(function (global, pool, math) {
	//
	// The following constants are related to IEEE 754 limits.
	//

	var width = 256,        // each RC4 output is 0 <= x < 256
	    chunks = 6,         // at least six RC4 outputs for each double
	    digits = 52,        // there are 52 significant digits in a double
	    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
	    startdenom = math.pow(width, chunks),
	    significance = math.pow(2, digits),
	    overflow = significance * 2,
	    mask = width - 1,
	    nodecrypto;         // node.js crypto module, initialized at the bottom.

	//
	// seedrandom()
	// This is the seedrandom function described above.
	//
	function seedrandom(seed, options, callback) {
	  var key = [];
	  options = (options == true) ? { entropy: true } : (options || {});

	  // Flatten the seed string or build one from local entropy if needed.
	  var shortseed = mixkey(flatten(
	    options.entropy ? [seed, tostring(pool)] :
	    (seed == null) ? autoseed() : seed, 3), key);

	  // Use the seed to initialize an ARC4 generator.
	  var arc4 = new ARC4(key);

	  // This function returns a random double in [0, 1) that contains
	  // randomness in every bit of the mantissa of the IEEE 754 value.
	  var prng = function() {
	    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
	        d = startdenom,                 //   and denominator d = 2 ^ 48.
	        x = 0;                          //   and no 'extra last byte'.
	    while (n < significance) {          // Fill up all significant digits by
	      n = (n + x) * width;              //   shifting numerator and
	      d *= width;                       //   denominator and generating a
	      x = arc4.g(1);                    //   new least-significant-byte.
	    }
	    while (n >= overflow) {             // To avoid rounding up, before adding
	      n /= 2;                           //   last byte, shift everything
	      d /= 2;                           //   right using integer math until
	      x >>>= 1;                         //   we have exactly the desired bits.
	    }
	    return (n + x) / d;                 // Form the number within [0, 1).
	  };

	  prng.int32 = function() { return arc4.g(4) | 0; };
	  prng.quick = function() { return arc4.g(4) / 0x100000000; };
	  prng.double = prng;

	  // Mix the randomness into accumulated entropy.
	  mixkey(tostring(arc4.S), pool);

	  // Calling convention: what to return as a function of prng, seed, is_math.
	  return (options.pass || callback ||
	      function(prng, seed, is_math_call, state) {
	        if (state) {
	          // Load the arc4 state from the given state if it has an S array.
	          if (state.S) { copy(state, arc4); }
	          // Only provide the .state method if requested via options.state.
	          prng.state = function() { return copy(arc4, {}); };
	        }

	        // If called as a method of Math (Math.seedrandom()), mutate
	        // Math.random because that is how seedrandom.js has worked since v1.0.
	        if (is_math_call) { math[rngname] = prng; return seed; }

	        // Otherwise, it is a newer calling convention, so return the
	        // prng directly.
	        else return prng;
	      })(
	  prng,
	  shortseed,
	  'global' in options ? options.global : (this == math),
	  options.state);
	}

	//
	// ARC4
	//
	// An ARC4 implementation.  The constructor takes a key in the form of
	// an array of at most (width) integers that should be 0 <= x < (width).
	//
	// The g(count) method returns a pseudorandom integer that concatenates
	// the next (count) outputs from ARC4.  Its return value is a number x
	// that is in the range 0 <= x < (width ^ count).
	//
	function ARC4(key) {
	  var t, keylen = key.length,
	      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

	  // The empty key [] is treated as [0].
	  if (!keylen) { key = [keylen++]; }

	  // Set up S using the standard key scheduling algorithm.
	  while (i < width) {
	    s[i] = i++;
	  }
	  for (i = 0; i < width; i++) {
	    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
	    s[j] = t;
	  }

	  // The "g" method returns the next (count) outputs as one number.
	  (me.g = function(count) {
	    // Using instance members instead of closure state nearly doubles speed.
	    var t, r = 0,
	        i = me.i, j = me.j, s = me.S;
	    while (count--) {
	      t = s[i = mask & (i + 1)];
	      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
	    }
	    me.i = i; me.j = j;
	    return r;
	    // For robust unpredictability, the function call below automatically
	    // discards an initial batch of values.  This is called RC4-drop[256].
	    // See http://google.com/search?q=rsa+fluhrer+response&btnI
	  })(width);
	}

	//
	// copy()
	// Copies internal state of ARC4 to or from a plain object.
	//
	function copy(f, t) {
	  t.i = f.i;
	  t.j = f.j;
	  t.S = f.S.slice();
	  return t;
	}
	//
	// flatten()
	// Converts an object tree to nested arrays of strings.
	//
	function flatten(obj, depth) {
	  var result = [], typ = (typeof obj), prop;
	  if (depth && typ == 'object') {
	    for (prop in obj) {
	      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
	    }
	  }
	  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
	}

	//
	// mixkey()
	// Mixes a string seed into a key that is an array of integers, and
	// returns a shortened string seed that is equivalent to the result key.
	//
	function mixkey(seed, key) {
	  var stringseed = seed + '', smear, j = 0;
	  while (j < stringseed.length) {
	    key[mask & j] =
	      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
	  }
	  return tostring(key);
	}

	//
	// autoseed()
	// Returns an object for autoseeding, using window.crypto and Node crypto
	// module if available.
	//
	function autoseed() {
	  try {
	    var out;
	    if (nodecrypto && (out = nodecrypto.randomBytes)) {
	      // The use of 'out' to remember randomBytes makes tight minified code.
	      out = out(width);
	    } else {
	      out = new Uint8Array(width);
	      (global.crypto || global.msCrypto).getRandomValues(out);
	    }
	    return tostring(out);
	  } catch (e) {
	    var browser = global.navigator,
	        plugins = browser && browser.plugins;
	    return [+new Date, global, plugins, global.screen, tostring(pool)];
	  }
	}

	//
	// tostring()
	// Converts an array of charcodes to a string
	//
	function tostring(a) {
	  return String.fromCharCode.apply(0, a);
	}

	//
	// When seedrandom.js is loaded, we immediately mix a few bits
	// from the built-in RNG into the entropy pool.  Because we do
	// not want to interfere with deterministic PRNG state later,
	// seedrandom will not call math.random on its own again after
	// initialization.
	//
	mixkey(math.random(), pool);

	//
	// Nodejs and AMD support: export the implementation as a module using
	// either convention.
	//
	if ( module.exports) {
	  module.exports = seedrandom;
	  // When in node.js, try using crypto package for autoseeding.
	  try {
	    nodecrypto = require$$0;
	  } catch (ex) {}
	} else {
	  // When included as a plain script, set up Math.seedrandom global.
	  math['seed' + rngname] = seedrandom;
	}


	// End anonymous scope, and pass initial values.
	})(
	  // global: `self` in browsers (including strict mode and web workers),
	  // otherwise `this` in Node and other environments
	  (typeof self !== 'undefined') ? self : commonjsGlobal,
	  [],     // pool: entropy pool starts empty
	  Math    // math: package containing random, pow, and seedrandom
	);
	});

	// A library of seedable RNGs implemented in Javascript.
	//
	// Usage:
	//
	// var seedrandom = require('seedrandom');
	// var random = seedrandom(1); // or any seed.
	// var x = random();       // 0 <= x < 1.  Every bit is random.
	// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

	// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
	// Period: ~2^116
	// Reported to pass all BigCrush tests.


	// xor128, a pure xor-shift generator by George Marsaglia.
	// Period: 2^128-1.
	// Reported to fail: MatrixRank and LinearComp.


	// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
	// Period: 2^192-2^32
	// Reported to fail: CollisionOver, SimpPoker, and LinearComp.


	// xorshift7, by François Panneton and Pierre L'ecuyer, takes
	// a different approach: it adds robustness by allowing more shifts
	// than Marsaglia's original three.  It is a 7-shift generator
	// with 256 bits, that passes BigCrush with no systmatic failures.
	// Period 2^256-1.
	// No systematic BigCrush failures reported.


	// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
	// very long period that also adds a Weyl generator. It also passes
	// BigCrush with no systematic failures.  Its long period may
	// be useful if you have many generators and need to avoid
	// collisions.
	// Period: 2^4128-2^32.
	// No systematic BigCrush failures reported.


	// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
	// number generator derived from ChaCha, a modern stream cipher.
	// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
	// Period: ~2^127
	// No systematic BigCrush failures reported.


	// The original ARC4-based prng included in this library.
	// Period: ~2^1600


	seedrandom.alea = alea;
	seedrandom.xor128 = xor128;
	seedrandom.xorwow = xorwow;
	seedrandom.xorshift7 = xorshift7;
	seedrandom.xor4096 = xor4096;
	seedrandom.tychei = tychei;

	var seedrandom$1 = seedrandom;
	var seedrandom_1 = seedrandom$1.alea;

	class SeedrandomGenerator {
	    constructor(_rng) {
	        this._rng = _rng;
	    }
	    single() {
	        return this._rng.quick();
	    }
	    double() {
	        return this._rng.double();
	    }
	    int32() {
	        return this._rng.int32();
	    }
	    int(max) {
	        return (this._rng.int32() >>> 0) % (max + 1);
	    }
	    saveState() {
	        return this._rng.state();
	    }
	}

	function createRng(seed) {
	    if (seed < 0) {
	        seed = Math.random();
	    }
	    return new SeedrandomGenerator(seedrandom_1(seed, {
	        state: true
	    }));
	}

	class Board {
	    constructor(_config, cartridge, cpuFactory) {
	        this._config = _config;
	        this.trap = new lib_1();
	        this.clock = new lib_1();
	        this.cpuClock = new lib_1();
	        this.systemReset = new lib_1();
	        this._clockMode = 1;
	        this._cpuCycles = 0;
	        this._trap = false;
	        this._audioEnabled = true;
	        this._suspended = true;
	        this._subClock = 0;
	        this._clockHz = 0;
	        this._sliceSize = 0;
	        this._timer = {
	            tick: (clocks) => this._tick(clocks),
	            start: (scheduler) => this._start(scheduler),
	            stop: () => this._stop(),
	            isRunning: () => !!this._runTask
	        };
	        this._rng = createRng(_config.randomSeed < 0 ? Math.random() : _config.randomSeed);
	        cartridge.randomize(this._rng);
	        const bus = new Bus();
	        if (typeof cpuFactory === 'undefined') {
	            cpuFactory = (_bus, rng) => new CpuFactory(_config.cpuType).create(_bus, rng);
	        }
	        const controlPanel = new ControlPanel(), joystick0 = new DigitalJoystick(), joystick1 = new DigitalJoystick(), paddles = new Array(4);
	        for (let i = 0; i < 4; i++) {
	            paddles[i] = new Paddle();
	        }
	        const cpu = cpuFactory(bus, this._rng);
	        const pia = new Pia(controlPanel, joystick0, joystick1, this._rng);
	        const tia = new Tia(_config, joystick0, joystick1, paddles);
	        cpu.setInvalidInstructionCallback(() => this._onInvalidInstruction());
	        tia.setCpu(cpu)
	            .setBus(bus)
	            .setCpuTimeProvider(() => this.getCpuTime());
	        cartridge
	            .setCpu(cpu)
	            .setBus(bus)
	            .setCpuTimeProvider(() => this.getCpuTime())
	            .setRng(this._rng);
	        pia.setBus(bus);
	        bus.setTia(tia)
	            .setPia(pia)
	            .setCartridge(cartridge);
	        this._bus = bus;
	        this._cpu = cpu;
	        this._tia = tia;
	        this._pia = pia;
	        this._cartridge = cartridge;
	        this._controlPanel = controlPanel;
	        this._joystick0 = joystick0;
	        this._joystick1 = joystick1;
	        this._paddles = paddles;
	        this._bus.event.trap.addHandler((payload) => this.triggerTrap(1, payload.message));
	        this._clockHz = Config.getClockHz(_config);
	        this._sliceSize = 228 * (_config.tvMode === 0 ? 262 : 312);
	        this.reset();
	    }
	    getCpu() {
	        return this._cpu;
	    }
	    getBus() {
	        return this._bus;
	    }
	    getVideoOutput() {
	        return this._tia;
	    }
	    getWaveformChannels() {
	        return [0, 1].map(i => this._tia.getWaveformChannel(i));
	    }
	    getPCMChannel() {
	        return this._tia.getPCMChannel();
	    }
	    getTimer() {
	        return this._timer;
	    }
	    getConfig() {
	        return this._config;
	    }
	    reset() {
	        this._cpu.reset();
	        this._tia.reset();
	        this._pia.reset();
	        this._cartridge.reset();
	        this._controlPanel.getResetButton().toggle(false);
	        this._controlPanel.getSelectSwitch().toggle(false);
	        this._controlPanel.getColorSwitch().toggle(false);
	        this._controlPanel.getDifficultySwitchP0().toggle(true);
	        this._controlPanel.getDifficultySwitchP1().toggle(true);
	        this._subClock = 0;
	        this._cpuCycles = 0;
	        this.systemReset.dispatch();
	        return this;
	    }
	    boot() {
	        let cycles = 0, cpuCycles = 0;
	        this.reset();
	        if (this._cpu.executionState !== 0) {
	            throw new Error('Already booted!');
	        }
	        while (this._cpu.executionState !== 1) {
	            this._cycle();
	            cycles++;
	            if (this._subClock === 0) {
	                cpuCycles++;
	            }
	        }
	        this.cpuClock.dispatch(cpuCycles);
	        this.clock.dispatch(cycles);
	        return this;
	    }
	    suspend() {
	        this._suspended = true;
	        this._updateAudioState();
	    }
	    resume() {
	        this._suspended = false;
	        this._updateAudioState();
	    }
	    setAudioEnabled(state) {
	        this._audioEnabled = state;
	        this._updateAudioState();
	    }
	    triggerTrap(reason, message) {
	        this._stop();
	        this._trap = true;
	        if (this.trap.hasHandlers) {
	            this.trap.dispatch(new BoardInterface.TrapPayload(reason, this, message));
	        }
	        else {
	            throw new Error(message);
	        }
	        return this;
	    }
	    getControlPanel() {
	        return this._controlPanel;
	    }
	    getJoystick0() {
	        return this._joystick0;
	    }
	    getJoystick1() {
	        return this._joystick1;
	    }
	    getBoardStateDebug() {
	        const sep = '============';
	        return ('TIA:\n' +
	            sep +
	            '\n' +
	            this._tia.getDebugState() +
	            '\n' +
	            `\n` +
	            `PIA:\n` +
	            `${sep}\n` +
	            `${this._pia.getDebugState()}\n`);
	    }
	    setClockMode(clockMode) {
	        this._clockMode = clockMode;
	        return this;
	    }
	    getClockMode() {
	        return this._clockMode;
	    }
	    getPaddle(idx) {
	        return this._paddles[idx];
	    }
	    getCpuTime() {
	        return (this._cpuCycles / Config.getClockHz(this._config)) * 3;
	    }
	    static _executeSlice(board, _timeSlice) {
	        const slice = _timeSlice ? Math.round((_timeSlice * board._clockHz) / 1000) : board._sliceSize;
	        return (board._tick(slice) / board._clockHz) * 1000;
	    }
	    _updateAudioState() {
	        this._tia.setAudioEnabled(this._audioEnabled && !this._suspended);
	    }
	    _cycle() {
	        this._tia.cycle();
	        if (this._subClock++ >= 2) {
	            this._pia.cycle();
	            this._cpu.cycle();
	            this._subClock = 0;
	        }
	    }
	    _tick(requestedCycles) {
	        let i = 0, cycles = 0, cpuCycles = 0, lastExecutionState = this._cpu.executionState;
	        this._trap = false;
	        while (i++ < requestedCycles && !this._trap) {
	            this._cycle();
	            cycles++;
	            if (this._subClock === 0) {
	                cpuCycles++;
	                this._cpuCycles++;
	            }
	            if (lastExecutionState !== this._cpu.executionState) {
	                lastExecutionState = this._cpu.executionState;
	                if (this._cpu.executionState === 1) {
	                    this._cartridge.notifyCpuCycleComplete();
	                    if (this._clockMode === 0 &&
	                        cpuCycles > 0 &&
	                        this.cpuClock.hasHandlers) {
	                        this.cpuClock.dispatch(cpuCycles);
	                        cpuCycles = 0;
	                    }
	                }
	            }
	        }
	        if (cpuCycles > 0 && this.cpuClock.hasHandlers) {
	            this.cpuClock.dispatch(cpuCycles);
	        }
	        if (cycles > 0 && this.clock.hasHandlers) {
	            this.clock.dispatch(cycles);
	        }
	        return cycles;
	    }
	    _start(scheduler) {
	        if (this._runTask) {
	            return;
	        }
	        this._runTask = scheduler.start(Board._executeSlice, this, 1000 / (this._config.tvMode === 0 ? 60 : 50));
	    }
	    _stop() {
	        if (!this._runTask) {
	            return;
	        }
	        this._runTask.stop();
	        this._runTask = undefined;
	    }
	    _onInvalidInstruction() {
	        this.triggerTrap(0, 'invalid instruction');
	    }
	}

	var CartridgeInterface;
	(function (CartridgeInterface) {
	    class TrapPayload {
	        constructor(reason, cartridge, message) {
	            this.reason = reason;
	            this.cartridge = cartridge;
	            this.message = message;
	        }
	    }
	    CartridgeInterface.TrapPayload = TrapPayload;
	})(CartridgeInterface || (CartridgeInterface = {}));

	var CartridgeInfo;
	(function (CartridgeInfo) {
	    let CartridgeType;
	    (function (CartridgeType) {
	        CartridgeType["vanilla_2k"] = "vanilla_2k";
	        CartridgeType["vanilla_4k"] = "vanilla_4k";
	        CartridgeType["bankswitch_2k_cv"] = "bankswitch_2k_cv";
	        CartridgeType["bankswitch_8k_F8"] = "bankswitch_8k_F8";
	        CartridgeType["bankswitch_8k_E0"] = "bankswitch_8k_E0";
	        CartridgeType["bankswitch_8k_3F"] = "bankswitch_8k_3F";
	        CartridgeType["bankswitch_8k_FE"] = "bankswitch_8k_FE";
	        CartridgeType["bankswitch_8k_UA"] = "bankswitch_8k_UA";
	        CartridgeType["bankswitch_8k_DPC"] = "bankswitch_8k_DPC";
	        CartridgeType["bankswitch_8k_econobanking"] = "bankswitch_8k_econobanking";
	        CartridgeType["bankswitch_8k_pp"] = "bankswitch_8k_pp";
	        CartridgeType["bankswitch_12k_FA"] = "bankswitch_12k_FA";
	        CartridgeType["bankswitch_16k_F6"] = "bankswitch_16k_F6";
	        CartridgeType["bankswitch_16k_E7"] = "bankswitch_16k_E7";
	        CartridgeType["bankswitch_FA2"] = "bankswitch_FA2";
	        CartridgeType["bankswitch_32k_F4"] = "bankswitch_32k_F4";
	        CartridgeType["bankswitch_64k_F0"] = "bankswitch_64k_F0";
	        CartridgeType["bankswitch_64k_EF"] = "bankswitch_64k_EF";
	        CartridgeType["bankswitch_3E"] = "bankswitch_3E";
	        CartridgeType["bankswitch_supercharger"] = "bankswitch_supercharger";
	        CartridgeType["bankswitch_dpc_plus"] = "bankswitch_dpc_plus";
	        CartridgeType["bankswitch_cdf"] = "bankswitch_cdf";
	        CartridgeType["unknown"] = "unknown";
	    })(CartridgeType = CartridgeInfo.CartridgeType || (CartridgeInfo.CartridgeType = {}));
	    function getAllTypes() {
	        return [
	            CartridgeType.vanilla_2k,
	            CartridgeType.vanilla_4k,
	            CartridgeType.bankswitch_2k_cv,
	            CartridgeType.bankswitch_8k_F8,
	            CartridgeType.bankswitch_8k_E0,
	            CartridgeType.bankswitch_8k_3F,
	            CartridgeType.bankswitch_8k_FE,
	            CartridgeType.bankswitch_8k_UA,
	            CartridgeType.bankswitch_8k_econobanking,
	            CartridgeType.bankswitch_8k_pp,
	            CartridgeType.bankswitch_12k_FA,
	            CartridgeType.bankswitch_8k_DPC,
	            CartridgeType.bankswitch_16k_F6,
	            CartridgeType.bankswitch_16k_E7,
	            CartridgeType.bankswitch_FA2,
	            CartridgeType.bankswitch_32k_F4,
	            CartridgeType.bankswitch_3E,
	            CartridgeType.bankswitch_64k_F0,
	            CartridgeType.bankswitch_64k_EF,
	            CartridgeType.bankswitch_supercharger,
	            CartridgeType.bankswitch_dpc_plus,
	            CartridgeType.bankswitch_cdf,
	            CartridgeType.unknown
	        ];
	    }
	    CartridgeInfo.getAllTypes = getAllTypes;
	    function describeCartridgeType(cartridgeType) {
	        switch (cartridgeType) {
	            case CartridgeType.vanilla_2k:
	                return 'plain 2k';
	            case CartridgeType.vanilla_4k:
	                return 'plain 4k';
	            case CartridgeType.bankswitch_2k_cv:
	                return '2k CommaVideo scheme';
	            case CartridgeType.bankswitch_8k_F8:
	                return 'bankswitched 8k, F8 (Atari) scheme';
	            case CartridgeType.bankswitch_8k_E0:
	                return 'bankswitched 8k, E0 (Parker Bros.) scheme';
	            case CartridgeType.bankswitch_8k_3F:
	                return 'bankswitched 8k, 3F (Tigervision) scheme';
	            case CartridgeType.bankswitch_8k_FE:
	                return 'bankswitched 8k, FE (Activision) scheme';
	            case CartridgeType.bankswitch_8k_UA:
	                return 'bankswitched 8k, UA (Pleiades) scheme';
	            case CartridgeType.bankswitch_8k_pp:
	                return 'bankswitched 8k, Pink Panther scheme';
	            case CartridgeType.bankswitch_12k_FA:
	                return 'bankswitched 12k, FA (CBS) scheme';
	            case CartridgeType.bankswitch_8k_DPC:
	                return 'bankswitched 8k + DPC';
	            case CartridgeType.bankswitch_8k_econobanking:
	                return 'bankswitched 8k, econobanking scheme';
	            case CartridgeType.bankswitch_16k_F6:
	                return 'bankswitched 16k, F6 (Atari) scheme';
	            case CartridgeType.bankswitch_16k_E7:
	                return 'bankswitched 16k, E7 (M-Network) scheme';
	            case CartridgeType.bankswitch_FA2:
	                return 'bankswitched 28k/29k, FA2 (modified CBS) scheme';
	            case CartridgeType.bankswitch_32k_F4:
	                return 'bankswitched 32k, F4 (Atari) scheme';
	            case CartridgeType.bankswitch_3E:
	                return 'bankswitched 3E (Tigervision + RAM) scheme';
	            case CartridgeType.bankswitch_64k_F0:
	                return 'bankswitched 64k, F0 (Megaboy) scheme';
	            case CartridgeType.bankswitch_64k_EF:
	                return 'bankswitched 64k, EFSC (Homestar Runner) scheme';
	            case CartridgeType.bankswitch_supercharger:
	                return 'bankswitched supercharger';
	            case CartridgeType.bankswitch_dpc_plus:
	                return 'bankswitched DPC+';
	            case CartridgeType.bankswitch_cdf:
	                return 'bankswitched CDF';
	            case CartridgeType.unknown:
	                return 'unknown';
	        }
	    }
	    CartridgeInfo.describeCartridgeType = describeCartridgeType;
	})(CartridgeInfo || (CartridgeInfo = {}));

	class AbstractCartridge {
	    constructor() {
	        this.trap = new lib_1();
	    }
	    init() {
	        return __awaiter(this, void 0, void 0, function* () { });
	    }
	    reset() { }
	    read(address) {
	        return 0;
	    }
	    peek(address) {
	        return this.read(address);
	    }
	    write(address, value) { }
	    getType() {
	        return CartridgeInfo.CartridgeType.unknown;
	    }
	    setCpu(cpu) {
	        return this;
	    }
	    setBus(bus) {
	        return this;
	    }
	    setRng(rng) {
	        return this;
	    }
	    setCpuTimeProvider(provider) {
	        return this;
	    }
	    notifyCpuCycleComplete() { }
	    randomize(rng) { }
	    triggerTrap(reason, message) {
	        if (this.trap.hasHandlers) {
	            this.trap.dispatch(new CartridgeInterface.TrapPayload(reason, this, message));
	        }
	        else {
	            throw new Error(message);
	        }
	    }
	}

	function nextPowerOfTwo(x) {
	    let v = 1;
	    while (v < x) {
	        v *= 2;
	    }
	    return v;
	}
	function padBuffer(buffer) {
	    const paddedLength = nextPowerOfTwo(buffer.length);
	    if (paddedLength === buffer.length) {
	        return buffer;
	    }
	    const paddedBuffer = new Uint8Array(paddedLength);
	    for (let i = 0; i < paddedLength; i++) {
	        paddedBuffer[paddedLength - i - 1] = i < buffer.length ? buffer[buffer.length - i - 1] : 0;
	    }
	    return paddedBuffer;
	}
	class Cartridge2k extends AbstractCartridge {
	    constructor(buffer) {
	        super();
	        this._rom = new Uint8Array(0x0800);
	        if (buffer.length > 0x0800) {
	            throw new Error(`buffer is not a 2k cartridge image: wrong length ${buffer.length}`);
	        }
	        const paddedBuffer = padBuffer(buffer);
	        for (let i = 0; i < 0x0800; i++) {
	            this._rom[i] = buffer[i % paddedBuffer.length];
	        }
	    }
	    read(address) {
	        return this._rom[address & 0x07ff];
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.vanilla_2k;
	    }
	}

	class Cartridge4k extends AbstractCartridge {
	    constructor(buffer) {
	        super();
	        this._rom = new Uint8Array(0x1000);
	        if (buffer.length !== 0x1000) {
	            console.warn(`buffer has invalid size for 4K image: ${buffer.length} bytes`);
	        }
	        const len = Math.min(0x1000, buffer.length);
	        for (let i = 0; i < 0x1000 && i < buffer.length; i++) {
	            this._rom[0x0fff - i] = buffer[len - 1 - i];
	        }
	    }
	    read(address) {
	        return this._rom[address & 0x0fff];
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.vanilla_4k;
	    }
	}

	function searchForSignatures(buffer, signatures) {
	    const candidates = [], counts = signatures.map((signature) => 0);
	    for (let i = 0; i < buffer.length; i++) {
	        for (let iCandidate = 0; iCandidate < candidates.length; iCandidate++) {
	            const candidate = candidates[iCandidate], signature = signatures[candidate.signature];
	            if (buffer[i] === signature[candidate.nextIndex]) {
	                if (++candidate.nextIndex === signature.length) {
	                    counts[candidate.signature]++;
	                    candidates.splice(iCandidate, 1);
	                    iCandidate--;
	                }
	            }
	            else {
	                candidates.splice(iCandidate, 1);
	                iCandidate--;
	            }
	        }
	        for (let iSignature = 0; iSignature < signatures.length; iSignature++) {
	            const signature = signatures[iSignature];
	            if (signature.length > 0 && buffer[i] === signature[0]) {
	                if (signature.length === 1) {
	                    counts[iSignature]++;
	                }
	                else {
	                    candidates.push({
	                        signature: iSignature,
	                        nextIndex: 1
	                    });
	                }
	            }
	        }
	    }
	    return counts;
	}
	function searchForSignature(buffer, signature) {
	    for (let i = 0; i < buffer.length; i++) {
	        let j;
	        for (j = 0; j < signature.length && (buffer[i + j] === signature[j] || signature[j] < 0); j++) { }
	        if (j === signature.length) {
	            return i;
	        }
	    }
	    return -1;
	}

	class CartridgeCV extends AbstractCartridge {
	    constructor(buffer) {
	        super();
	        this._rom = new Uint8Array(0x0800);
	        this._ram = new Uint8Array(0x0400);
	        if (buffer.length !== 0x0800) {
	            throw new Error(`buffer is not a 2k cartridge image: wrong length ${buffer.length}`);
	        }
	        for (let i = 0; i < 0x0800; i++) {
	            this._rom[i] = buffer[i];
	        }
	    }
	    static matchesBuffer(buffer) {
	        const signatureCounts = searchForSignatures(buffer, [[0x9d, 0xff, 0xf3], [0x99, 0x00, 0xf4]]);
	        return signatureCounts[0] > 0 || signatureCounts[1] > 0;
	    }
	    setBus(bus) {
	        this._bus = bus;
	        return this;
	    }
	    randomize(rng) {
	        for (let i = 0; i < 0x0400; i++) {
	            this._ram[i] = rng.int(0xff);
	        }
	    }
	    read(address) {
	        address &= 0x0fff;
	        if (address < 0x0400) {
	            return this._ram[address];
	        }
	        if (address < 0x0800) {
	            return (this._ram[address & 0x03ff] = this._bus.getLastDataBusValue());
	        }
	        return this._rom[address & 0x07ff];
	    }
	    write(address, value) {
	        address &= 0x0fff;
	        if (address >= 0x0400 && address < 0x0800) {
	            this._ram[address & 0x03ff] = value;
	        }
	    }
	    peek(address) {
	        address &= 0x0fff;
	        if (address < 0x0400) {
	            return this._ram[address];
	        }
	        if (address < 0x0800) {
	            return 0;
	        }
	        return this._rom[address & 0x07ff];
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_2k_cv;
	    }
	}

	class CartridgeF8 extends AbstractCartridge {
	    constructor(buffer, _supportSC = true) {
	        super();
	        this._supportSC = _supportSC;
	        this._bank = null;
	        this._bank0 = new Uint8Array(0x1000);
	        this._bank1 = new Uint8Array(0x1000);
	        this._hasSC = false;
	        this._saraRAM = new Uint8Array(0x80);
	        this._bus = null;
	        if (buffer.length !== 0x2000) {
	            throw new Error(`buffer is not an 8k cartridge image: wrong length ${buffer.length}`);
	        }
	        for (let i = 0; i < 0x1000; i++) {
	            this._bank0[i] = buffer[i];
	            this._bank1[i] = buffer[0x1000 + i];
	        }
	        this.reset();
	    }
	    static matchesBuffer(buffer) {
	        const signatureCounts = searchForSignatures(buffer, [[0x8d, 0xf9, 0x1f]]);
	        return signatureCounts[0] >= 2;
	    }
	    reset() {
	        this._bank = this._bank1;
	        this._hasSC = false;
	    }
	    read(address) {
	        this._access(address & 0x0fff, this._bus.getLastDataBusValue());
	        return this.peek(address);
	    }
	    peek(address) {
	        address &= 0x0fff;
	        if (this._hasSC && address >= 0x0080 && address < 0x0100) {
	            return this._saraRAM[address - 0x80];
	        }
	        return this._bank[address];
	    }
	    write(address, value) {
	        address &= 0x0fff;
	        if (address < 0x80 && this._supportSC) {
	            this._hasSC = true;
	        }
	        this._access(address, value);
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_8k_F8;
	    }
	    randomize(rng) {
	        for (let i = 0; i < this._saraRAM.length; i++) {
	            this._saraRAM[i] = rng.int(0xff);
	        }
	    }
	    setBus(bus) {
	        this._bus = bus;
	        return this;
	    }
	    _access(address, value) {
	        if (address < 0x80 && this._hasSC) {
	            this._saraRAM[address] = value & 0xff;
	            return;
	        }
	        switch (address) {
	            case 0x0ff8:
	                this._bank = this._bank0;
	                break;
	            case 0x0ff9:
	                this._bank = this._bank1;
	                break;
	        }
	    }
	}

	class CartridgeF6 extends AbstractCartridge {
	    constructor(buffer, _supportSC = true) {
	        super();
	        this._supportSC = _supportSC;
	        this._bank = null;
	        this._bank0 = new Uint8Array(0x1000);
	        this._bank1 = new Uint8Array(0x1000);
	        this._bank2 = new Uint8Array(0x1000);
	        this._bank3 = new Uint8Array(0x1000);
	        this._hasSC = false;
	        this._saraRAM = new Uint8Array(0x80);
	        this._bus = null;
	        if (buffer.length !== 0x4000) {
	            throw new Error(`buffer is not a 16k cartridge image: wrong length ${buffer.length}`);
	        }
	        for (let i = 0; i < 0x1000; i++) {
	            this._bank0[i] = buffer[i];
	            this._bank1[i] = buffer[0x1000 + i];
	            this._bank2[i] = buffer[0x2000 + i];
	            this._bank3[i] = buffer[0x3000 + i];
	        }
	        this.reset();
	    }
	    reset() {
	        this._bank = this._bank0;
	        this._hasSC = false;
	    }
	    read(address) {
	        this._access(address & 0x0fff, this._bus.getLastDataBusValue());
	        return this.peek(address);
	    }
	    peek(address) {
	        address &= 0x0fff;
	        if (this._hasSC && address >= 0x0080 && address < 0x0100) {
	            return this._saraRAM[address - 0x80];
	        }
	        return this._bank[address];
	    }
	    write(address, value) {
	        address &= 0x0fff;
	        if (address < 0x80 && this._supportSC) {
	            this._hasSC = true;
	        }
	        this._access(address, value);
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_16k_F6;
	    }
	    randomize(rng) {
	        for (let i = 0; i < this._saraRAM.length; i++) {
	            this._saraRAM[i] = rng.int(0xff);
	        }
	    }
	    setBus(bus) {
	        this._bus = bus;
	        return this;
	    }
	    _access(address, value) {
	        if (address < 0x80 && this._hasSC) {
	            this._saraRAM[address] = value & 0xff;
	            return;
	        }
	        switch (address) {
	            case 0x0ff6:
	                this._bank = this._bank0;
	                break;
	            case 0x0ff7:
	                this._bank = this._bank1;
	                break;
	            case 0x0ff8:
	                this._bank = this._bank2;
	                break;
	            case 0x0ff9:
	                this._bank = this._bank3;
	                break;
	        }
	    }
	}

	class CartridgeE0 extends AbstractCartridge {
	    constructor(buffer) {
	        super();
	        this._banks = new Array(8);
	        this._activeBanks = new Array(4);
	        if (buffer.length !== 0x2000) {
	            throw new Error(`buffer is not an 8k cartridge image: invalid length ${buffer.length}`);
	        }
	        for (let i = 0; i < 8; i++) {
	            this._banks[i] = new Uint8Array(0x0400);
	        }
	        for (let i = 0; i < 0x0400; i++) {
	            for (let j = 0; j < 8; j++) {
	                this._banks[j][i] = buffer[j * 0x0400 + i];
	            }
	        }
	        this.reset();
	    }
	    static matchesBuffer(buffer) {
	        const signatureCounts = searchForSignatures(buffer, [
	            [0x8d, 0xe0, 0x1f],
	            [0x8d, 0xe0, 0x5f],
	            [0x8d, 0xe9, 0xff],
	            [0x0c, 0xe0, 0x1f],
	            [0xad, 0xe0, 0x1f],
	            [0xad, 0xe9, 0xff],
	            [0xad, 0xed, 0xff],
	            [0xad, 0xf3, 0xbf]
	        ]);
	        for (let i = 0; i < signatureCounts.length; i++) {
	            if (signatureCounts[i] > 0) {
	                return true;
	            }
	        }
	        return false;
	    }
	    reset() {
	        for (let i = 0; i < 4; i++) {
	            this._activeBanks[i] = this._banks[7];
	        }
	    }
	    read(address) {
	        address &= 0x0fff;
	        if (address >= 0x0fe0 && address < 0x0ff8) {
	            this._handleBankswitch(address);
	        }
	        return this._activeBanks[address >> 10][address & 0x03ff];
	    }
	    peek(address) {
	        address &= 0x0fff;
	        return this._activeBanks[address >> 10][address & 0x03ff];
	    }
	    write(address, value) {
	        const addressMasked = address & 0x0fff;
	        if (addressMasked >= 0x0fe0 && addressMasked < 0x0ff8) {
	            this._handleBankswitch(addressMasked);
	        }
	        return super.write(address, value);
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_8k_E0;
	    }
	    _handleBankswitch(address) {
	        if (address < 0x0fe8) {
	            this._activeBanks[0] = this._banks[address - 0x0fe0];
	        }
	        else if (address < 0x0ff0) {
	            this._activeBanks[1] = this._banks[address - 0x0fe8];
	        }
	        else {
	            this._activeBanks[2] = this._banks[address - 0x0ff0];
	        }
	    }
	}

	class CartridgeFE extends AbstractCartridge {
	    constructor(buffer) {
	        super();
	        this._bank0 = new Uint8Array(0x1000);
	        this._bank1 = new Uint8Array(0x1000);
	        this._lastAccessWasFE = false;
	        this._lastAddressBusValue = -1;
	        if (buffer.length !== 0x2000) {
	            throw new Error(`buffer is not an 8k cartridge image: wrong length ${buffer.length}`);
	        }
	        for (let i = 0; i < 0x1000; i++) {
	            this._bank0[i] = buffer[i];
	            this._bank1[i] = buffer[0x1000 + i];
	        }
	        this.reset();
	    }
	    static matchesBuffer(buffer) {
	        const signatureCounts = searchForSignatures(buffer, [
	            [0x20, 0x00, 0xd0, 0xc6, 0xc5],
	            [0x20, 0xc3, 0xf8, 0xa5, 0x82],
	            [0xd0, 0xfb, 0x20, 0x73, 0xfe],
	            [0x20, 0x00, 0xf0, 0x84, 0xd6]
	        ]);
	        for (let i = 0; i < signatureCounts.length; i++) {
	            if (signatureCounts[i] > 0) {
	                return true;
	            }
	        }
	        return false;
	    }
	    reset() {
	        this._bank = this._bank0;
	        this._lastAccessWasFE = false;
	        this._lastAddressBusValue = -1;
	    }
	    read(address) {
	        return this._bank[address & 0x0fff];
	    }
	    write(address, value) {
	        super.write(address, value);
	    }
	    setBus(bus) {
	        this._bus = bus;
	        this._bus.event.read.addHandler(CartridgeFE._onBusAccess, this);
	        this._bus.event.write.addHandler(CartridgeFE._onBusAccess, this);
	        return this;
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_8k_FE;
	    }
	    static _onBusAccess(accessType, self) {
	        const previousAddressBusValue = self._lastAddressBusValue;
	        self._lastAddressBusValue = self._bus.getLastAddresBusValue() & 0x1fff;
	        if (self._lastAddressBusValue === previousAddressBusValue) {
	            return;
	        }
	        if (self._lastAccessWasFE) {
	            const dataBusHiBits = self._bus.getLastDataBusValue() & 0xe0;
	            self._bank =
	                dataBusHiBits === 0
	                    ? self._bank0
	                    : (self._bus.getLastDataBusValue() & 0x20) > 0
	                        ? self._bank0
	                        : self._bank1;
	        }
	        self._lastAccessWasFE = self._lastAddressBusValue === 0x01fe;
	    }
	}

	class Cartridge3F extends AbstractCartridge {
	    constructor(buffer) {
	        super();
	        this._banks = new Array(4);
	        this._bus = null;
	        if (buffer.length !== 0x2000) {
	            throw new Error(`buffer is not an 8k cartridge image: invalid length ${buffer.length}`);
	        }
	        for (let i = 0; i < 4; i++) {
	            this._banks[i] = new Uint8Array(0x0800);
	        }
	        this._bank1 = this._banks[3];
	        this._bank0 = this._banks[0];
	        for (let i = 0; i < 0x0800; i++) {
	            for (let j = 0; j < 4; j++) {
	                this._banks[j][i] = buffer[0x0800 * j + i];
	            }
	        }
	    }
	    static matchesBuffer(buffer) {
	        const signatureCounts = searchForSignatures(buffer, [[0x85, 0x3f]]);
	        return signatureCounts[0] >= 2;
	    }
	    reset() {
	        this._bank0 = this._banks[0];
	    }
	    setBus(bus) {
	        this._bus = bus;
	        this._bus.event.read.addHandler(Cartridge3F._onBusAccess, this);
	        this._bus.event.write.addHandler(Cartridge3F._onBusAccess, this);
	        return this;
	    }
	    read(address) {
	        address &= 0x0fff;
	        return address < 0x0800 ? this._bank0[address] : this._bank1[address & 0x07ff];
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_8k_3F;
	    }
	    static _onBusAccess(accessType, self) {
	        if (self._bus.getLastAddresBusValue() === 0x003f) {
	            self._bank0 = self._banks[self._bus.getLastDataBusValue() & 0x03];
	        }
	    }
	}

	class Cartridge3E extends AbstractCartridge {
	    constructor(buffer) {
	        super();
	        this._banks = null;
	        this._ramSelect = false;
	        this._ramBanks = new Array(0x0100);
	        this._bus = null;
	        if ((buffer.length & 0x07ff) !== 0) {
	            throw new Error(`buffer length ${buffer.length} is not a multiple of 2k`);
	        }
	        const bankCount = buffer.length >>> 11;
	        if (bankCount < 2) {
	            throw new Error('image must have at least 2k');
	        }
	        this._banks = new Array(bankCount);
	        for (let i = 0; i < bankCount; i++) {
	            this._banks[i] = new Uint8Array(0x0800);
	        }
	        for (let i = 0; i <= 0xff; i++) {
	            this._ramBanks[i] = new Uint8Array(0x0400);
	        }
	        this._ramBank = this._ramBanks[0];
	        this._bank1 = this._banks[bankCount - 1];
	        this._bank0 = this._banks[0];
	        for (let i = 0; i < 0x0800; i++) {
	            for (let j = 0; j < bankCount; j++) {
	                this._banks[j][i] = buffer[0x0800 * j + i];
	            }
	        }
	    }
	    static matchesBuffer(buffer) {
	        const signatureCounts = searchForSignatures(buffer, [[0x85, 0x3e, 0xa9, 0x00]]);
	        return signatureCounts[0] >= 1;
	    }
	    reset() {
	        this._bank0 = this._banks[0];
	    }
	    randomize(rng) {
	        for (let i = 0; i < this._ramBanks.length; i++) {
	            for (let j = 0; j < 0x0400; j++) {
	                this._ramBanks[i][j] = rng.int(0xff);
	            }
	        }
	    }
	    setBus(bus) {
	        this._bus = bus;
	        this._bus.event.read.addHandler(Cartridge3E._onBusAccess, this);
	        this._bus.event.write.addHandler(Cartridge3E._onBusAccess, this);
	        return this;
	    }
	    read(address) {
	        address &= 0x0fff;
	        if (this._ramSelect) {
	            if (address < 0x0400) {
	                return this._ramBank[address];
	            }
	            if (address < 0x0800) {
	                return (this._ramBank[address & 0x03ff] = this._bus.getLastDataBusValue());
	            }
	            return this._bank1[address & 0x07ff];
	        }
	        return address < 0x0800 ? this._bank0[address] : this._bank1[address & 0x07ff];
	    }
	    peek(address) {
	        address &= 0x0fff;
	        if (this._ramSelect) {
	            if (address < 0x0400) {
	                return this._ramBank[address];
	            }
	            if (address < 0x0800) {
	                return this._bus.getLastDataBusValue();
	            }
	            return this._bank1[address & 0x07ff];
	        }
	        return address < 0x0800 ? this._bank0[address] : this._bank1[address & 0x07ff];
	    }
	    write(address, value) {
	        if (!this._ramSelect) {
	            return;
	        }
	        address &= 0x0fff;
	        if (address >= 0x0400 && address < 0x0800) {
	            this._ramBank[address & 0x03ff] = value;
	        }
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_3E;
	    }
	    static _onBusAccess(accessType, self) {
	        switch (self._bus.getLastAddresBusValue()) {
	            case 0x003f:
	                self._ramSelect = false;
	                self._bank0 = self._banks[self._bus.getLastDataBusValue() % self._banks.length];
	                break;
	            case 0x003e:
	                self._ramSelect = true;
	                self._ramBank = self._ramBanks[self._bus.getLastDataBusValue() % 32];
	                break;
	        }
	    }
	}

	class CartridgeUA extends AbstractCartridge {
	    constructor(buffer) {
	        super();
	        this._bus = null;
	        this._bank = null;
	        this._bank0 = new Uint8Array(0x1000);
	        this._bank1 = new Uint8Array(0x1000);
	        if (buffer.length !== 0x2000) {
	            throw new Error(`buffer is not an 8k cartridge image: wrong length ${buffer.length}`);
	        }
	        for (let i = 0; i < 0x1000; i++) {
	            this._bank0[i] = buffer[i];
	            this._bank1[i] = buffer[0x1000 + i];
	        }
	        this.reset();
	    }
	    static matchesBuffer(buffer) {
	        const signatureCounts = searchForSignatures(buffer, [
	            [0x8d, 0x40, 0x02],
	            [0xad, 0x40, 0x02],
	            [0xbd, 0x1f, 0x02]
	        ]);
	        for (let i = 0; i < signatureCounts.length; i++) {
	            if (signatureCounts[i] > 0) {
	                return true;
	            }
	        }
	        return false;
	    }
	    reset() {
	        this._bank = this._bank0;
	    }
	    read(address) {
	        return this._bank[address & 0x0fff];
	    }
	    setBus(bus) {
	        this._bus = bus;
	        bus.event.read.addHandler(CartridgeUA._onBusAccess, this);
	        bus.event.write.addHandler(CartridgeUA._onBusAccess, this);
	        return this;
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_8k_UA;
	    }
	    static _onBusAccess(accessType, self) {
	        switch (self._bus.getLastAddresBusValue()) {
	            case 0x0220:
	                self._bank = self._bank0;
	                break;
	            case 0x0240:
	                self._bank = self._bank1;
	                break;
	        }
	    }
	}

	class CartridgeFA extends AbstractCartridge {
	    constructor(buffer) {
	        super();
	        this._bank0 = new Uint8Array(0x1000);
	        this._bank1 = new Uint8Array(0x1000);
	        this._bank2 = new Uint8Array(0x1000);
	        this._ram = new Uint8Array(0x0100);
	        if (buffer.length !== 0x3000) {
	            throw new Error(`buffer is not a 12k cartridge image: wrong length ${buffer.length}`);
	        }
	        for (let i = 0; i < 0x1000; i++) {
	            this._bank0[i] = buffer[i];
	            this._bank1[i] = buffer[0x1000 + i];
	            this._bank2[i] = buffer[0x2000 + i];
	        }
	        this.reset();
	    }
	    reset() {
	        this._bank = this._bank0;
	    }
	    randomize(rng) {
	        for (let i = 0; i < this._ram.length; i++) {
	            this._ram[i] = rng.int(0xff);
	        }
	    }
	    read(address) {
	        this._handleBankswitch(address & 0x0fff);
	        return this.peek(address);
	    }
	    peek(address) {
	        address &= 0x0fff;
	        if (address >= 0x0100 && address < 0x0200) {
	            return this._ram[address & 0xff];
	        }
	        else {
	            return this._bank[address];
	        }
	    }
	    write(address, value) {
	        address &= 0x0fff;
	        this._handleBankswitch(address);
	        if (address < 0x0100) {
	            this._ram[address] = value & 0xff;
	        }
	        else {
	            super.write(address, value);
	        }
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_12k_FA;
	    }
	    _handleBankswitch(address) {
	        switch (address) {
	            case 0x0ff8:
	                this._bank = this._bank0;
	                break;
	            case 0x0ff9:
	                this._bank = this._bank1;
	                break;
	            case 0x0ffa:
	                this._bank = this._bank2;
	                break;
	        }
	    }
	}

	class CartrdigeE7 extends AbstractCartridge {
	    constructor(buffer) {
	        super();
	        this._banks = new Array(8);
	        this._ram0 = new Uint8Array(0x0400);
	        this._ram1Banks = new Array(4);
	        this._ram0Enabled = false;
	        if (buffer.length !== 0x4000) {
	            throw new Error(`buffer is not a 16k cartridge image: wrong length ${buffer.length}`);
	        }
	        for (let i = 0; i < 8; i++) {
	            this._banks[i] = new Uint8Array(0x0800);
	        }
	        for (let i = 0; i < 4; i++) {
	            this._ram1Banks[i] = new Uint8Array(0x100);
	        }
	        for (let i = 0; i < 0x0800; i++) {
	            for (let j = 0; j < 8; j++) {
	                this._banks[j][i] = buffer[j * 0x0800 + i];
	            }
	        }
	        this.reset();
	    }
	    static matchesBuffer(buffer) {
	        const signatureCounts = searchForSignatures(buffer, [
	            [0xad, 0xe2, 0xff],
	            [0xad, 0xe5, 0xff],
	            [0xad, 0xe5, 0x1f],
	            [0xad, 0xe7, 0x1f],
	            [0x0c, 0xe7, 0x1f],
	            [0x8d, 0xe7, 0xff],
	            [0x8d, 0xe7, 0x1f]
	        ]);
	        for (let i = 0; i < signatureCounts.length; i++) {
	            if (signatureCounts[i] > 0) {
	                return true;
	            }
	        }
	        return false;
	    }
	    reset() {
	        this._bank0 = this._banks[0];
	        this._ram1 = this._ram1Banks[0];
	        this._ram0Enabled = false;
	    }
	    read(address) {
	        this._handleBankswitch(address & 0x0fff);
	        return this.peek(address);
	    }
	    peek(address) {
	        address &= 0x0fff;
	        if (address < 0x0800) {
	            if (this._ram0Enabled) {
	                return address >= 0x0400 ? this._ram0[address - 0x0400] : 0;
	            }
	            else {
	                return this._bank0[address];
	            }
	        }
	        if (address <= 0x09ff) {
	            return address >= 0x0900 ? this._ram1[address - 0x0900] : 0;
	        }
	        return this._banks[7][0x07ff - (0x0fff - address)];
	    }
	    write(address, value) {
	        address &= 0x0fff;
	        this._handleBankswitch(address);
	        if (address < 0x0400) {
	            if (this._ram0Enabled) {
	                this._ram0[address] = value;
	            }
	            else {
	                super.write(address, value);
	            }
	        }
	        else if (address < 0x0800) {
	            super.write(address, value);
	        }
	        else if (address < 0x08ff) {
	            this._ram1[address - 0x0800] = value;
	        }
	        else {
	            super.write(address, value);
	        }
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_16k_E7;
	    }
	    randomize(rng) {
	        for (let i = 0; i < 4; i++) {
	            for (let j = 0; j < this._ram1Banks[i].length; j++) {
	                this._ram1Banks[i][j] = rng.int(0xff);
	            }
	        }
	        for (let i = 0; i < this._ram0.length; i++) {
	            this._ram0[i] = rng.int(0xff);
	        }
	    }
	    _handleBankswitch(address) {
	        if (address < 0x0fe0) {
	            return;
	        }
	        if (address <= 0x0fe6) {
	            this._bank0 = this._banks[address & 0x000f];
	            this._ram0Enabled = false;
	        }
	        else if (address === 0x0fe7) {
	            this._ram0Enabled = true;
	        }
	        else if (address <= 0x0feb) {
	            this._ram1 = this._ram1Banks[address - 0x0fe8];
	        }
	    }
	}

	class CartridgeF0 extends AbstractCartridge {
	    constructor(buffer) {
	        super();
	        this._banks = new Array(16);
	        this._bankIdx = 0;
	        if (buffer.length !== 0x10000) {
	            throw new Error(`buffer is not a 64k cartridge image: wrong length ${buffer.length}`);
	        }
	        for (let i = 0; i < 16; i++) {
	            this._banks[i] = new Uint8Array(0x1000);
	        }
	        for (let i = 0; i < 0x1000; i++) {
	            for (let j = 0; j < 16; j++) {
	                this._banks[j][i] = buffer[j * 0x1000 + i];
	            }
	        }
	        this.reset();
	    }
	    reset() {
	        this._bankIdx = 0;
	        this._currentBank = this._banks[this._bankIdx];
	    }
	    read(address) {
	        address &= 0x0fff;
	        this._handleBankswitch(address);
	        return this._currentBank[address];
	    }
	    peek(address) {
	        return this._currentBank[address & 0x0fff];
	    }
	    write(address, value) {
	        address &= 0xfff;
	        this._handleBankswitch(address);
	        super.write(address, value);
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_64k_F0;
	    }
	    _handleBankswitch(address) {
	        if (address === 0x0ff0) {
	            this._bankIdx = (this._bankIdx + 1) & 0x0f;
	            this._currentBank = this._banks[this._bankIdx];
	        }
	    }
	}

	class CartridgeEF extends AbstractCartridge {
	    constructor(buffer, _supportSC = true) {
	        super();
	        this._supportSC = _supportSC;
	        this._bus = null;
	        this._banks = new Array(16);
	        this._ram = new Uint8Array(0x80);
	        this._hasSC = false;
	        if (buffer.length !== 0x10000) {
	            throw new Error(`buffer is not a 64k cartridge image: wrong length ${buffer.length}`);
	        }
	        for (let i = 0; i < 16; i++) {
	            this._banks[i] = new Uint8Array(0x1000);
	        }
	        for (let i = 0; i < 0x1000; i++) {
	            for (let j = 0; j < 16; j++) {
	                this._banks[j][i] = buffer[j * 0x1000 + i];
	            }
	        }
	        this.reset();
	    }
	    static matchesBuffer(buffer) {
	        const matchMagic = (magicString) => {
	            const magic = magicString.split('').map(x => x.charCodeAt(0));
	            for (let i = 0; i < magic.length; i++) {
	                if (magic[i] !== buffer[0xfff8 + i]) {
	                    return false;
	                }
	            }
	            return true;
	        };
	        if (buffer.length !== 0x10000) {
	            return false;
	        }
	        if (matchMagic('efef') || matchMagic('efsc')) {
	            return true;
	        }
	        const signatureCounts = searchForSignatures(buffer, [
	            [0x0c, 0xe0, 0xff],
	            [0xad, 0xe0, 0xff],
	            [0x0c, 0xe0, 0x1f],
	            [0xad, 0xe0, 0x1f]
	        ]);
	        for (let i = 0; i < 4; i++) {
	            if (signatureCounts[i] > 0) {
	                return true;
	            }
	        }
	        return false;
	    }
	    reset() {
	        this._bank = this._banks[15];
	        this._hasSC = false;
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_64k_EF;
	    }
	    randomize(rng) {
	        for (let i = 0; i < this._ram.length; i++) {
	            this._ram[i] = rng.int(0xff);
	        }
	    }
	    setBus(bus) {
	        this._bus = bus;
	        return this;
	    }
	    read(address) {
	        this._access(address & 0x0fff, this._bus.getLastDataBusValue());
	        return this.peek(address);
	    }
	    peek(address) {
	        address &= 0x0fff;
	        if (this._hasSC && address >= 0x0080 && address < 0x0100) {
	            return this._ram[address - 0x80];
	        }
	        else {
	            return this._bank[address];
	        }
	    }
	    write(address, value) {
	        address &= 0x0fff;
	        if (address < 0x80 && this._supportSC) {
	            this._hasSC = true;
	        }
	        this._access(address, value);
	    }
	    _access(address, value) {
	        if (address < 0x80 && this._hasSC) {
	            this._ram[address] = value;
	            return;
	        }
	        if (address >= 0x0fe0 && address <= 0x0fef) {
	            this._bank = this._banks[address - 0x0fe0];
	        }
	    }
	}

	class CartridgeF4 extends AbstractCartridge {
	    constructor(buffer, _supportSC = true) {
	        super();
	        this._supportSC = _supportSC;
	        this._bus = null;
	        this._banks = new Array(8);
	        this._ram = new Uint8Array(0x80);
	        this._hasSC = false;
	        if (buffer.length !== 0x8000) {
	            throw new Error(`buffer is not a 32k cartridge image: wrong length ${buffer.length}`);
	        }
	        for (let i = 0; i < 8; i++) {
	            this._banks[i] = new Uint8Array(0x1000);
	        }
	        for (let i = 0; i < 0x1000; i++) {
	            for (let j = 0; j < 8; j++) {
	                this._banks[j][i] = buffer[j * 0x1000 + i];
	            }
	        }
	        this.reset();
	    }
	    reset() {
	        this._bank = this._banks[0];
	        this._hasSC = false;
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_32k_F4;
	    }
	    randomize(rng) {
	        for (let i = 0; i < this._ram.length; i++) {
	            this._ram[i] = rng.int(0xff);
	        }
	    }
	    setBus(bus) {
	        this._bus = bus;
	        return this;
	    }
	    read(address) {
	        this._access(address & 0x0fff, this._bus.getLastDataBusValue());
	        return this.peek(address);
	    }
	    peek(address) {
	        address &= 0x0fff;
	        if (this._hasSC && address >= 0x0080 && address < 0x0100) {
	            return this._ram[address - 0x80];
	        }
	        else {
	            return this._bank[address];
	        }
	    }
	    write(address, value) {
	        address &= 0x0fff;
	        if (address < 0x80 && this._supportSC) {
	            this._hasSC = true;
	        }
	        this._access(address, value);
	    }
	    _access(address, value) {
	        if (address < 0x80 && this._hasSC) {
	            this._ram[address] = value;
	            return;
	        }
	        if (address >= 0x0ff4 && address <= 0x0ffb) {
	            this._bank = this._banks[address - 0x0ff4];
	        }
	    }
	}

	class CartridgeFA2 extends AbstractCartridge {
	    constructor(buffer) {
	        super();
	        this._banks = new Array(7);
	        this._ram = new Uint8Array(0x100);
	        this._savedRam = new Uint8Array(0x100);
	        this._accessCounter = 0;
	        this._accessCounterLimit = 0;
	        if (buffer.length !== 0x7000 && buffer.length !== 0x7400) {
	            throw new Error(`buffer is not a 28k/29k cartridge image: wrong length ${buffer.length}`);
	        }
	        for (let i = 0; i < 7; i++) {
	            this._banks[i] = new Uint8Array(0x1000);
	        }
	        const offset = buffer.length === 0x7000 ? 0 : 0x0400;
	        for (let i = 0; i < 0x1000; i++) {
	            for (let j = 0; j < 7; j++) {
	                this._banks[j][i] = buffer[j * 0x1000 + i + offset];
	            }
	        }
	        this.reset();
	    }
	    static matchesBuffer(buffer) {
	        const signatureCounts = searchForSignatures(buffer, [
	            [0xa0, 0xc1, 0x1f, 0xe0],
	            [0x00, 0x80, 0x02, 0xe0]
	        ]);
	        return signatureCounts[0] > 0 || signatureCounts[1] > 0;
	    }
	    reset() {
	        this._accessCounter = 0;
	        this._accessCounterLimit = 0;
	        this._bank = this._banks[0];
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_FA2;
	    }
	    randomize(rng) {
	        for (let i = 0; i < this._ram.length; i++) {
	            this._ram[i] = rng.int(0xff);
	        }
	    }
	    setBus(bus) {
	        this._bus = bus;
	        return this;
	    }
	    read(address) {
	        this.write(address & 0x0fff, this._bus.getLastDataBusValue());
	        return this.peek(address);
	    }
	    peek(address) {
	        address &= 0x0fff;
	        if (address >= 0x0100 && address < 0x0200) {
	            return this._ram[address - 0x0100];
	        }
	        else if (address === 0x0ff4) {
	            return this._accessCounter >= this._accessCounterLimit
	                ?
	                    this._bank[address] & ~0x40
	                :
	                    this._bank[address] | 0x40;
	        }
	        else {
	            return this._bank[address];
	        }
	    }
	    write(address, value) {
	        address &= 0x0fff;
	        this._accessCounter++;
	        if (address < 0x0100) {
	            this._ram[address] = value;
	            return;
	        }
	        if (address === 0x0ff4) {
	            return this._handleIo();
	        }
	        if (address >= 0x0ff5 && address <= 0x0ffb) {
	            this._bank = this._banks[address - 0x0ff5];
	        }
	    }
	    _handleIo() {
	        if (this._accessCounter < this._accessCounterLimit) {
	            return;
	        }
	        if (this._ram[0xff] === 1) {
	            for (let i = 0; i < 0x100; i++) {
	                this._ram[i] = this._savedRam[i];
	            }
	            this._accessCounterLimit = 10;
	        }
	        else if (this._ram[0xff] === 2) {
	            for (let i = 0; i < 0x100; i++) {
	                this._savedRam[i] = this._ram[i];
	            }
	            this._accessCounterLimit = 100;
	        }
	        else {
	            return;
	        }
	        this._accessCounter = 0;
	        this._ram[0xff] = 0;
	    }
	}

	class Header {
	    constructor(buffer) {
	        this.blockLocation = null;
	        this.blockChecksum = null;
	        this.startAddressLow = buffer[0x2000];
	        this.startAddressHigh = buffer[0x2001];
	        this.controlWord = buffer[0x2002];
	        this.blockCount = buffer[0x2003];
	        this.checksum = buffer[0x2004];
	        this.multiloadId = buffer[0x2005];
	        this.progressBarSpeedLow = buffer[0x2006];
	        this.progressBarSpeedHigh = buffer[0x2007];
	        this.blockLocation = new Uint8Array(this.blockCount);
	        this.blockChecksum = new Uint8Array(this.blockCount);
	        for (let i = 0; i < this.blockCount; i++) {
	            this.blockLocation[i] = buffer[0x2000 + 16 + i];
	            this.blockChecksum[i] = buffer[0x2000 + 64 + i];
	        }
	    }
	    verify() {
	        const checksum = this.startAddressLow +
	            this.startAddressHigh +
	            this.controlWord +
	            this.blockCount +
	            this.checksum +
	            this.multiloadId +
	            this.progressBarSpeedLow +
	            this.progressBarSpeedHigh;
	        return (checksum & 0xff) === 0x55;
	    }
	}

	const bios = decode('pfpMGPj//3jYqQCi/5qqqJUA6ND7TBj4ogKGAa4G8I74/6AAoiiUBMoQ+6KAoACUAOjQ+6ILvGj4lPDKEPhM8ACiBr1z+JXwyhD4rvD/hoC8APCt8f+u8v+G9K7z/4b1ov+gAJpM8ACN+f+t+//Q+0xB+I34/0wAAA==');

	class CartridgeSupercharger extends AbstractCartridge {
	    constructor(buffer) {
	        super();
	        this._loadCount = 0;
	        this._loads = null;
	        this._headers = null;
	        this._rom = new Uint8Array(0x800);
	        this._ramBanks = new Array(3);
	        this._bank0 = null;
	        this._bank1 = null;
	        this._bank1Type = 1;
	        this._transitionCount = 0;
	        this._pendingWriteData = 0;
	        this._pendingWrite = false;
	        this._lastAddressBusValue = -1;
	        this._writeRamEnabled = false;
	        this._loadInProgress = false;
	        this._loadTimestamp = 0;
	        this._cpuTimeProvider = null;
	        if (buffer.length % 8448 !== 0) {
	            throw new Error(`not a supercharger image --- invalid size`);
	        }
	        this._loadCount = buffer.length / 8448;
	        this._loads = new Array(this._loadCount);
	        this._headers = new Array(this._loadCount);
	        for (let i = 0; i < this._loadCount; i++) {
	            this._loads[i] = new Uint8Array(8448);
	        }
	        for (let i = 0; i < 8448; i++) {
	            for (let j = 0; j < this._loadCount; j++) {
	                this._loads[j][i] = buffer[j * 8448 + i];
	            }
	        }
	        for (let i = 0; i < this._loadCount; i++) {
	            this._headers[i] = new Header(this._loads[i]);
	            if (!this._headers[i].verify()) {
	                console.log(`load ${i} has invalid checksum`);
	            }
	        }
	        for (let i = 0; i < 3; i++) {
	            this._ramBanks[i] = new Uint8Array(0x0800);
	        }
	        this._setupRom();
	        this.reset();
	    }
	    reset() {
	        this._setBankswitchMode(0);
	        this._transitionCount = 0;
	        this._pendingWrite = false;
	        this._pendingWriteData = 0;
	        this._lastAddressBusValue = -1;
	        this._writeRamEnabled = false;
	        this._loadInProgress = false;
	        this._loadTimestamp = 0;
	    }
	    setBus(bus) {
	        this._bus = bus;
	        this._bus.event.read.addHandler(CartridgeSupercharger._onBusAccess, this);
	        this._bus.event.write.addHandler(CartridgeSupercharger._onBusAccess, this);
	        return this;
	    }
	    setCpuTimeProvider(provider) {
	        this._cpuTimeProvider = provider;
	        return this;
	    }
	    setRng(rng) {
	        this._rng = rng;
	        return this;
	    }
	    read(address) {
	        return this._access(address, this._bus.getLastDataBusValue());
	    }
	    peek(address) {
	        address &= 0x0fff;
	        return address < 0x0800 ? this._bank0[address] : this._bank1[address & 0x07ff];
	    }
	    write(address, value) {
	        this._access(address, value);
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_supercharger;
	    }
	    static _onBusAccess(type, self) {
	        const address = self._bus.getLastAddresBusValue();
	        if (address !== self._lastAddressBusValue && !self._loadInProgress) {
	            if (self._transitionCount <= 5) {
	                self._transitionCount++;
	            }
	            self._lastAddressBusValue = address;
	        }
	    }
	    _access(address, value) {
	        address &= 0x0fff;
	        if (this._loadInProgress) {
	            if ((this._cpuTimeProvider() - this._loadTimestamp) > 1E-3) {
	                this._loadInProgress = false;
	            }
	            else {
	                return value;
	            }
	        }
	        const readValue = address < 0x0800 ? this._bank0[address] : this._bank1[address & 0x07ff];
	        if ((address & 0x0f00) === 0 && (!this._pendingWrite || !this._writeRamEnabled)) {
	            this._pendingWriteData = address & 0x00ff;
	            this._transitionCount = 0;
	            this._pendingWrite = true;
	            return readValue;
	        }
	        if (address === 0x0ff8) {
	            this._setBankswitchMode((this._pendingWriteData & 28) >>> 2);
	            this._writeRamEnabled = (this._pendingWriteData & 0x02) > 0;
	            this._pendingWrite = false;
	            return readValue;
	        }
	        if (address === 0x0ff9 && this._bank1Type === 1 && ((this._lastAddressBusValue & 0x1fff) < 0xff)) {
	            this._loadIntoRam(value);
	            return readValue;
	        }
	        if (this._pendingWrite && this._writeRamEnabled && this._transitionCount === 5) {
	            this._pendingWrite = false;
	            if (address < 0x0800) {
	                this._bank0[address] = this._pendingWriteData;
	            }
	            else if (this._bank1Type === 0) {
	                this._bank1[address & 0x07ff] = this._pendingWriteData;
	            }
	            else {
	                return readValue;
	            }
	            return this._pendingWriteData;
	        }
	        return readValue;
	    }
	    _setBankswitchMode(mode) {
	        switch (mode) {
	            case 0:
	                return this._configureBanks(2, 1);
	            case 1:
	                return this._configureBanks(0, 1);
	            case 2:
	                return this._configureBanks(2, 0, 0);
	            case 3:
	                return this._configureBanks(0, 0, 2);
	            case 4:
	                return this._configureBanks(2, 1);
	            case 5:
	                return this._configureBanks(1, 1);
	            case 6:
	                return this._configureBanks(2, 0, 1);
	            case 7:
	                return this._configureBanks(1, 0, 2);
	            default:
	                throw new Error('invalid bankswitching mode');
	        }
	    }
	    _configureBanks(bank0, bank1Type, bank1 = 0) {
	        this._bank0 = this._ramBanks[bank0];
	        this._bank1Type = bank1Type;
	        this._bank1 = bank1Type === 0 ? this._ramBanks[bank1] : this._rom;
	    }
	    _setupRom() {
	        for (let i = 0; i < 0x0800; i++) {
	            this._rom[i] = 0;
	        }
	        for (let i = 0; i < bios.length; i++) {
	            this._rom[i] = bios[i];
	        }
	        this._rom[0x07ff] = this._rom[0x07fd] = 0xf8;
	        this._rom[0x07fe] = this._rom[0x07fc] = 0x07;
	    }
	    _loadIntoRam(loadId) {
	        let loadIndex;
	        for (loadIndex = 0; loadIndex < this._loadCount; loadIndex++) {
	            if (this._headers[loadIndex].multiloadId === loadId || this._loadCount === 1) {
	                break;
	            }
	        }
	        if (loadIndex >= this._loadCount) {
	            console.log(`no load with id ${loadId}`);
	        }
	        const header = this._headers[loadIndex], load = this._loads[loadIndex];
	        for (let blockIdx = 0; blockIdx < header.blockCount; blockIdx++) {
	            const location = header.blockLocation[blockIdx];
	            let bank = location & 0x03;
	            if (bank > 2) {
	                bank = 0;
	                console.log(`invalid bank for block ${blockIdx}, load ${loadIndex}`);
	            }
	            const base = ((location & 28) >>> 2) * 256;
	            let checksum = location + header.blockChecksum[blockIdx];
	            for (let i = 0; i < 256; i++) {
	                checksum += load[256 * blockIdx + i];
	                this._ramBanks[bank][base + i] = load[256 * blockIdx + i];
	            }
	            if ((checksum & 0xff) !== 0x55) {
	                console.log(`load ${loadIndex}, block ${blockIdx}: invalid checksum`);
	            }
	        }
	        this._rom[0x7f0] = header.controlWord;
	        this._rom[0x7f1] = this._rng.int(0xff);
	        this._rom[0x7f2] = header.startAddressLow;
	        this._rom[0x7f3] = header.startAddressHigh;
	        this._loadInProgress = true;
	        this._loadTimestamp = this._cpuTimeProvider();
	    }
	}

	const mixerTable = new Uint8Array([0x0, 0x4, 0x5, 0x9, 0x6, 0xa, 0xb, 0xf]);
	class CartridgeDPC extends AbstractCartridge {
	    constructor(buffer) {
	        super();
	        this._bank0 = new Uint8Array(0x1000);
	        this._bank1 = new Uint8Array(0x1000);
	        this._fetcherData = new Uint8Array(0x0800);
	        this._fetchers = new Array(8);
	        this._rng = 1;
	        this._cpuTimeProvider = null;
	        this._lastCpuTime = 0;
	        this._clockAccumulator = 0;
	        if (buffer.length < 0x2800) {
	            throw new Error(`buffer is not a DPC image: too small ${buffer.length}`);
	        }
	        for (let i = 0; i < 8; i++) {
	            this._fetchers[i] = new Fetcher();
	        }
	        for (let i = 0; i < 0x1000; i++) {
	            this._bank0[i] = buffer[i];
	            this._bank1[i] = buffer[0x1000 + i];
	        }
	        for (let i = 0; i < 0x0800; i++) {
	            this._fetcherData[i] = buffer[0x2000 + i];
	        }
	        this.reset();
	    }
	    reset() {
	        this._bank = this._bank1;
	        this._rng = 1;
	        this._fetchers.forEach(fetcher => fetcher.reset());
	        this._lastCpuTime = 0;
	        this._clockAccumulator = 0;
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_8k_DPC;
	    }
	    setBus(bus) {
	        this._bus = bus;
	        return this;
	    }
	    setCpuTimeProvider(provider) {
	        this._cpuTimeProvider = provider;
	        return this;
	    }
	    read(address) {
	        return this._access(address, this._bus.getLastDataBusValue());
	    }
	    peek(address) {
	        return this._bank[address & 0x0fff];
	    }
	    write(address, value) {
	        this._access(address, value);
	    }
	    _access(address, value) {
	        address &= 0x0fff;
	        if (address > 0x7f) {
	            switch (address) {
	                case 0x0ff8:
	                    this._bank = this._bank0;
	                    break;
	                case 0x0ff9:
	                    this._bank = this._bank1;
	                    break;
	            }
	            return this._bank[address];
	        }
	        if (address < 0x08) {
	            if (address & 0x04) {
	                this._clockMusicFetchers();
	                return mixerTable[(this._fetchers[5].mask & 0x4) | (this._fetchers[6].mask & 0x2) | (this._fetchers[7].mask & 0x1)];
	            }
	            else {
	                return this._randomNext();
	            }
	        }
	        if (address < 0x40) {
	            const fetcher = this._fetchers[(address - 8) & 0x07], mask = fetcher.mask;
	            let fetchedData = this._fetcherData[0x07ff - fetcher.pointer];
	            fetcher.next();
	            switch ((address - 8) >>> 3) {
	                case 0:
	                    return fetchedData;
	                case 1:
	                    return fetchedData & mask;
	                case 2:
	                    fetchedData &= mask;
	                    return ((fetchedData << 4) | (fetchedData >>> 4)) & 0xff;
	                case 3:
	                    fetchedData &= mask;
	                    return (((fetchedData & 0x01) << 7) |
	                        ((fetchedData & 0x02) << 5) |
	                        ((fetchedData & 0x04) << 3) |
	                        ((fetchedData & 0x08) << 1) |
	                        ((fetchedData & 0x10) >>> 1) |
	                        ((fetchedData & 0x20) >>> 3) |
	                        ((fetchedData & 0x40) >>> 5) |
	                        ((fetchedData & 0x80) >>> 7));
	                case 4:
	                    return (fetchedData & mask) >>> 1;
	                case 5:
	                    return (fetchedData << 1) & mask;
	                case 6:
	                    return mask;
	            }
	        }
	        if (address < 0x60) {
	            const fetcher = this._fetchers[(address - 0x40) & 0x07];
	            switch ((address - 0x40) >>> 3) {
	                case 0:
	                    this._clockMusicFetchers();
	                    fetcher.setStart(value);
	                    break;
	                case 1:
	                    this._clockMusicFetchers();
	                    fetcher.setEnd(value);
	                    break;
	                case 2:
	                    fetcher.setLow(value);
	                    break;
	                case 3:
	                    fetcher.setHigh(value);
	                    if (address > 0x5c) {
	                        fetcher.setMusicMode(value);
	                    }
	                    break;
	            }
	            return this._bank[address];
	        }
	        if (address >= 0x70 && address < 0x78) {
	            this._rng = 1;
	            return this._bank[address];
	        }
	        return this._bank[address];
	    }
	    _randomNext() {
	        const oldRng = this._rng;
	        this._rng =
	            ((this._rng << 1) |
	                (~((this._rng >>> 7) ^ (this._rng >>> 5) ^ ((this._rng >>> 4) ^ (this._rng >>> 3))) & 0x01)) &
	                0xff;
	        return oldRng;
	    }
	    _clockMusicFetchers() {
	        const cpuTime = this._cpuTimeProvider();
	        this._clockAccumulator += (cpuTime - this._lastCpuTime) * 20000;
	        this._lastCpuTime = cpuTime;
	        const clocks = Math.floor(this._clockAccumulator);
	        this._clockAccumulator -= clocks;
	        if (clocks === 0) {
	            return;
	        }
	        for (let i = 5; i < 8; i++) {
	            this._fetchers[i].forwardClock(clocks);
	        }
	    }
	}
	class Fetcher {
	    constructor() {
	        this.pointer = 0;
	        this.start = 0;
	        this.end = 0;
	        this.musicMode = false;
	        this.mask = 0x00;
	    }
	    contructor() {
	        this.reset();
	    }
	    reset() {
	        this.pointer = this.start = this.end = this.mask = 0;
	        this.musicMode = false;
	    }
	    next() {
	        if (this.musicMode) {
	            return;
	        }
	        this.pointer = (this.pointer + 0x07ff) & 0x07ff;
	        this._updateMask();
	    }
	    setStart(start) {
	        this.start = start;
	        this.mask = 0x00;
	        this._updateMask();
	    }
	    setEnd(end) {
	        this.end = end;
	        this._updateMask();
	    }
	    setLow(value) {
	        this.pointer = (this.pointer & 0x0700) | value;
	        this._updateMask();
	    }
	    setHigh(value) {
	        this.pointer = (this.pointer & 0xff) | ((value & 0x07) << 8);
	        this._updateMask();
	    }
	    setMusicMode(value) {
	        this.musicMode = (value & 0x10) !== 0;
	    }
	    forwardClock(clocks) {
	        if (!this.musicMode) {
	            return;
	        }
	        const period = this.start + 1, newPointerLow = ((this.pointer & 0xff) + period - clocks % period) % period, distanceStart = (256 + this.start - newPointerLow) & 0xff, distanceEnd = (256 + this.end - newPointerLow) & 0xff;
	        this.pointer = (this.pointer & 0x0700) | newPointerLow;
	        this.mask = distanceStart > distanceEnd ? 0 : 0xff;
	    }
	    _updateMask() {
	        if ((this.pointer & 0xff) === this.start) {
	            this.mask = 0xff;
	        }
	        if ((this.pointer & 0xff) === this.end) {
	            this.mask = 0x00;
	        }
	    }
	}

	var global$1 = (typeof global !== "undefined" ? global :
	            typeof self !== "undefined" ? self :
	            typeof window !== "undefined" ? window : {});

	// shim for using process in browser
	// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	var cachedSetTimeout = defaultSetTimout;
	var cachedClearTimeout = defaultClearTimeout;
	if (typeof global$1.setTimeout === 'function') {
	    cachedSetTimeout = setTimeout;
	}
	if (typeof global$1.clearTimeout === 'function') {
	    cachedClearTimeout = clearTimeout;
	}

	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	function nextTick(fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	}
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	var title = 'browser';
	var platform = 'browser';
	var browser = true;
	var env = {};
	var argv = [];
	var version = ''; // empty string to avoid regexp issues
	var versions = {};
	var release = {};
	var config = {};

	function noop() {}

	var on = noop;
	var addListener = noop;
	var once = noop;
	var off = noop;
	var removeListener = noop;
	var removeAllListeners = noop;
	var emit = noop;

	function binding(name) {
	    throw new Error('process.binding is not supported');
	}

	function cwd () { return '/' }
	function chdir (dir) {
	    throw new Error('process.chdir is not supported');
	}function umask() { return 0; }

	// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
	var performance = global$1.performance || {};
	var performanceNow =
	  performance.now        ||
	  performance.mozNow     ||
	  performance.msNow      ||
	  performance.oNow       ||
	  performance.webkitNow  ||
	  function(){ return (new Date()).getTime() };

	// generate timestamp or delta
	// see http://nodejs.org/api/process.html#process_process_hrtime
	function hrtime(previousTimestamp){
	  var clocktime = performanceNow.call(performance)*1e-3;
	  var seconds = Math.floor(clocktime);
	  var nanoseconds = Math.floor((clocktime%1)*1e9);
	  if (previousTimestamp) {
	    seconds = seconds - previousTimestamp[0];
	    nanoseconds = nanoseconds - previousTimestamp[1];
	    if (nanoseconds<0) {
	      seconds--;
	      nanoseconds += 1e9;
	    }
	  }
	  return [seconds,nanoseconds]
	}

	var startTime = new Date();
	function uptime() {
	  var currentTime = new Date();
	  var dif = currentTime - startTime;
	  return dif / 1000;
	}

	var process = {
	  nextTick: nextTick,
	  title: title,
	  browser: browser,
	  env: env,
	  argv: argv,
	  version: version,
	  versions: versions,
	  on: on,
	  addListener: addListener,
	  once: once,
	  off: off,
	  removeListener: removeListener,
	  removeAllListeners: removeAllListeners,
	  emit: emit,
	  binding: binding,
	  cwd: cwd,
	  chdir: chdir,
	  umask: umask,
	  hrtime: hrtime,
	  platform: platform,
	  release: release,
	  config: config,
	  uptime: uptime
	};

	var __dirname = '/Users/pestix/git/6502ts/6502.ts/node_modules/thumbulator.ts/lib/native';

	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
	var inited = false;
	function init () {
	  inited = true;
	  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	  for (var i = 0, len = code.length; i < len; ++i) {
	    lookup[i] = code[i];
	    revLookup[code.charCodeAt(i)] = i;
	  }

	  revLookup['-'.charCodeAt(0)] = 62;
	  revLookup['_'.charCodeAt(0)] = 63;
	}

	function toByteArray (b64) {
	  if (!inited) {
	    init();
	  }
	  var i, j, l, tmp, placeHolders, arr;
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

	  // base64 is 4/3 + up to two characters of the original data
	  arr = new Arr(len * 3 / 4 - placeHolders);

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len;

	  var L = 0;

	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
	    arr[L++] = (tmp >> 16) & 0xFF;
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
	    arr[L++] = tmp & 0xFF;
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  if (!inited) {
	    init();
	  }
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var output = '';
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    output += lookup[tmp >> 2];
	    output += lookup[(tmp << 4) & 0x3F];
	    output += '==';
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
	    output += lookup[tmp >> 10];
	    output += lookup[(tmp >> 4) & 0x3F];
	    output += lookup[(tmp << 2) & 0x3F];
	    output += '=';
	  }

	  parts.push(output);

	  return parts.join('')
	}

	function read$1 (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	function write$1 (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	}

	var toString = {}.toString;

	var isArray = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};

	var INSPECT_MAX_BYTES = 50;

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
	  ? global$1.TYPED_ARRAY_SUPPORT
	  : true;

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length);
	    that.__proto__ = Buffer.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length);
	    }
	    that.length = length;
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer.poolSize = 8192; // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype;
	  return arr
	};

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	};

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype;
	  Buffer.__proto__ = Uint8Array;
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size);
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	};

	function allocUnsafe (that, size) {
	  assertSize(size);
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0;
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	};
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	};

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8';
	  }

	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0;
	  that = createBuffer(that, length);

	  var actual = that.write(string, encoding);

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual);
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0;
	  that = createBuffer(that, length);
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255;
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array);
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset);
	  } else {
	    array = new Uint8Array(array, byteOffset, length);
	  }

	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array;
	    that.__proto__ = Buffer.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array);
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (internalIsBuffer(obj)) {
	    var len = checked(obj.length) | 0;
	    that = createBuffer(that, len);

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len);
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	Buffer.isBuffer = isBuffer;
	function internalIsBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	};

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }

	  var i;
	  if (length === undefined) {
	    length = 0;
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length;
	    }
	  }

	  var buffer = Buffer.allocUnsafe(length);
	  var pos = 0;
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i];
	    if (!internalIsBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos);
	    pos += buf.length;
	  }
	  return buffer
	};

	function byteLength (string, encoding) {
	  if (internalIsBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string;
	  }

	  var len = string.length;
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	}
	Buffer.byteLength = byteLength;

	function slowToString (encoding, start, end) {
	  var loweredCase = false;

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0;
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length;
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0;
	  start >>>= 0;

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8';

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase();
	        loweredCase = true;
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true;

	function swap (b, n, m) {
	  var i = b[n];
	  b[n] = b[m];
	  b[m] = i;
	}

	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length;
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1);
	  }
	  return this
	};

	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length;
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3);
	    swap(this, i + 1, i + 2);
	  }
	  return this
	};

	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length;
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7);
	    swap(this, i + 1, i + 6);
	    swap(this, i + 2, i + 5);
	    swap(this, i + 3, i + 4);
	  }
	  return this
	};

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0;
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	};

	Buffer.prototype.equals = function equals (b) {
	  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	};

	Buffer.prototype.inspect = function inspect () {
	  var str = '';
	  var max = INSPECT_MAX_BYTES;
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
	    if (this.length > max) str += ' ... ';
	  }
	  return '<Buffer ' + str + '>'
	};

	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!internalIsBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0;
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0;
	  }
	  if (thisStart === undefined) {
	    thisStart = 0;
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length;
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0;
	  end >>>= 0;
	  thisStart >>>= 0;
	  thisEnd >>>= 0;

	  if (this === target) return 0

	  var x = thisEnd - thisStart;
	  var y = end - start;
	  var len = Math.min(x, y);

	  var thisCopy = this.slice(thisStart, thisEnd);
	  var targetCopy = target.slice(start, end);

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i];
	      y = targetCopy[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset;
	    byteOffset = 0;
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff;
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000;
	  }
	  byteOffset = +byteOffset;  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1);
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1;
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0;
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding);
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (internalIsBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF; // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1;
	  var arrLength = arr.length;
	  var valLength = val.length;

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase();
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2;
	      arrLength /= 2;
	      valLength /= 2;
	      byteOffset /= 2;
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i;
	  if (dir) {
	    var foundIndex = -1;
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i;
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex;
	        foundIndex = -1;
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true;
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false;
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	};

	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	};

	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	};

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0;
	  var remaining = buf.length - offset;
	  if (!length) {
	    length = remaining;
	  } else {
	    length = Number(length);
	    if (length > remaining) {
	      length = remaining;
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length;
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2;
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16);
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed;
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8';
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset;
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0;
	    if (isFinite(length)) {
	      length = length | 0;
	      if (encoding === undefined) encoding = 'utf8';
	    } else {
	      encoding = length;
	      length = undefined;
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset;
	  if (length === undefined || length > remaining) length = remaining;

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8';

	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	};

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	};

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return fromByteArray(buf)
	  } else {
	    return fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end);
	  var res = [];

	  var i = start;
	  while (i < end) {
	    var firstByte = buf[i];
	    var codePoint = null;
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1;

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint;

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte;
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1];
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          fourthByte = buf[i + 3];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint;
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD;
	      bytesPerSequence = 1;
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000;
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
	      codePoint = 0xDC00 | codePoint & 0x3FF;
	    }

	    res.push(codePoint);
	    i += bytesPerSequence;
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000;

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length;
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = '';
	  var i = 0;
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    );
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F);
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i]);
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length;

	  if (!start || start < 0) start = 0;
	  if (!end || end < 0 || end > len) end = len;

	  var out = '';
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i]);
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end);
	  var res = '';
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length;
	  start = ~~start;
	  end = end === undefined ? len : ~~end;

	  if (start < 0) {
	    start += len;
	    if (start < 0) start = 0;
	  } else if (start > len) {
	    start = len;
	  }

	  if (end < 0) {
	    end += len;
	    if (end < 0) end = 0;
	  } else if (end > len) {
	    end = len;
	  }

	  if (end < start) end = start;

	  var newBuf;
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end);
	    newBuf.__proto__ = Buffer.prototype;
	  } else {
	    var sliceLen = end - start;
	    newBuf = new Buffer(sliceLen, undefined);
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start];
	    }
	  }

	  return newBuf
	};

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }

	  return val
	};

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length);
	  }

	  var val = this[offset + --byteLength];
	  var mul = 1;
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul;
	  }

	  return val
	};

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  return this[offset]
	};

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return this[offset] | (this[offset + 1] << 8)
	};

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return (this[offset] << 8) | this[offset + 1]
	};

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	};

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	};

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var i = byteLength;
	  var mul = 1;
	  var val = this[offset + --i];
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	};

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset] | (this[offset + 1] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset + 1] | (this[offset] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	};

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	};

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read$1(this, offset, true, 23, 4)
	};

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read$1(this, offset, false, 23, 4)
	};

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read$1(this, offset, true, 52, 8)
	};

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read$1(this, offset, false, 52, 8)
	};

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var mul = 1;
	  var i = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8;
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 1] = (value >>> 8);
	    this[offset] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = 0;
	  var mul = 1;
	  var sub = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  var sub = 0;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  if (value < 0) value = 0xff + value + 1;
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 3] = (value >>> 24);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (value < 0) value = 0xffffffff + value + 1;
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4);
	  }
	  write$1(buf, value, offset, littleEndian, 23, 4);
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	};

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	};

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8);
	  }
	  write$1(buf, value, offset, littleEndian, 52, 8);
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	};

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	};

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0;
	  if (!end && end !== 0) end = this.length;
	  if (targetStart >= target.length) targetStart = target.length;
	  if (!targetStart) targetStart = 0;
	  if (end > 0 && end < start) end = start;

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length;
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start;
	  }

	  var len = end - start;
	  var i;

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    );
	  }

	  return len
	};

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start;
	      start = 0;
	      end = this.length;
	    } else if (typeof end === 'string') {
	      encoding = end;
	      end = this.length;
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0);
	      if (code < 256) {
	        val = code;
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255;
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0;
	  end = end === undefined ? this.length : end >>> 0;

	  if (!val) val = 0;

	  var i;
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val;
	    }
	  } else {
	    var bytes = internalIsBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString());
	    var len = bytes.length;
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len];
	    }
	  }

	  return this
	};

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '=';
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity;
	  var codePoint;
	  var length = string.length;
	  var leadSurrogate = null;
	  var bytes = [];

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i);

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint;

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	        leadSurrogate = codePoint;
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	    }

	    leadSurrogate = null;

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint);
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF);
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo;
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i);
	    hi = c >> 8;
	    lo = c % 256;
	    byteArray.push(lo);
	    byteArray.push(hi);
	  }

	  return byteArray
	}


	function base64ToBytes (str) {
	  return toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i];
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}


	// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	function isBuffer(obj) {
	  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
	}

	function isFastBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
	}

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	function resolve() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : '/';

	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	}
	// path.normalize(path)
	// posix version
	function normalize(path) {
	  var isPathAbsolute = isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isPathAbsolute).join('/');

	  if (!path && !isPathAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isPathAbsolute ? '/' : '') + path;
	}
	// posix version
	function isAbsolute(path) {
	  return path.charAt(0) === '/';
	}

	// posix version
	function join() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	}


	// path.relative(from, to)
	// posix version
	function relative(from, to) {
	  from = resolve(from).substr(1);
	  to = resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	}

	var sep = '/';
	var delimiter = ':';

	function dirname(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	}

	function basename(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	}


	function extname(path) {
	  return splitPath(path)[3];
	}
	var require$$1 = {
	  extname: extname,
	  basename: basename,
	  dirname: dirname,
	  sep: sep,
	  delimiter: delimiter,
	  relative: relative,
	  join: join,
	  isAbsolute: isAbsolute,
	  normalize: normalize,
	  resolve: resolve
	};
	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}

	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b' ?
	    function (str, start, len) { return str.substr(start, len) } :
	    function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;

	var thumbulator = createCommonjsModule(function (module, exports) {
	var Module = (function() {
	  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
	  return (
	function(Module) {
	  Module = Module || {};

	var Module=typeof Module!=="undefined"?Module:{};var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key];}}var arguments_=[];var thisProgram="./this.program";var quit_=function(status,toThrow){throw toThrow};var ENVIRONMENT_IS_WEB=false;var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=false;var ENVIRONMENT_HAS_NODE=false;var ENVIRONMENT_IS_SHELL=false;ENVIRONMENT_IS_WEB=typeof window==="object";ENVIRONMENT_IS_WORKER=typeof importScripts==="function";ENVIRONMENT_HAS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";ENVIRONMENT_IS_NODE=ENVIRONMENT_HAS_NODE&&!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_WORKER;ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary;if(ENVIRONMENT_IS_NODE){scriptDirectory=__dirname+"/";var nodeFS;var nodePath;read_=function shell_read(filename,binary){var ret;ret=tryParseAsDataURI(filename);if(!ret){if(!nodeFS)nodeFS=require$$0;if(!nodePath)nodePath=require$$1;filename=nodePath["normalize"](filename);ret=nodeFS["readFileSync"](filename);}return binary?ret:ret.toString()};readBinary=function readBinary(filename){var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret);}assert(ret.buffer);return ret};if(process["argv"].length>1){thisProgram=process["argv"][1].replace(/\\/g,"/");}arguments_=process["argv"].slice(2);process["on"]("unhandledRejection",abort);quit_=function(status){process["exit"](status);};Module["inspect"]=function(){return "[Emscripten Module object]"};}else if(ENVIRONMENT_IS_SHELL){if(typeof read!="undefined"){read_=function shell_read(f){var data=tryParseAsDataURI(f);if(data){return intArrayToString(data)}return read(f)};}readBinary=function readBinary(f){var data;data=tryParseAsDataURI(f);if(data){return data}if(typeof readbuffer==="function"){return new Uint8Array(readbuffer(f))}data=read(f,"binary");assert(typeof data==="object");return data};if(typeof scriptArgs!="undefined"){arguments_=scriptArgs;}else if(typeof arguments!="undefined"){arguments_=arguments;}if(typeof quit==="function"){quit_=function(status){quit(status);};}if(typeof print!=="undefined"){if(typeof console==="undefined")console={};console.log=print;console.warn=console.error=typeof printErr!=="undefined"?printErr:print;}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href;}else if(document.currentScript){scriptDirectory=document.currentScript.src;}if(_scriptDir){scriptDirectory=_scriptDir;}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.lastIndexOf("/")+1);}else{scriptDirectory="";}read_=function shell_read(url){try{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText}catch(err){var data=tryParseAsDataURI(url);if(data){return intArrayToString(data)}throw err}};if(ENVIRONMENT_IS_WORKER){readBinary=function readBinary(url){try{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}catch(err){var data=tryParseAsDataURI(url);if(data){return data}throw err}};}readAsync=function readAsync(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=function xhr_onload(){if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}var data=tryParseAsDataURI(url);if(data){onload(data.buffer);return}onerror();};xhr.onerror=onerror;xhr.send(null);};}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.warn.bind(console);for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key];}}moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var functionPointers=new Array(0);var tempRet0=0;var setTempRet0=function(value){tempRet0=value;};var getTempRet0=function(){return tempRet0};var GLOBAL_BASE=8;var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime;if(Module["noExitRuntime"])noExitRuntime=Module["noExitRuntime"];var ABORT=false;function assert(condition,text){if(!condition){abort("Assertion failed: "+text);}}function getCFunc(ident){var func=Module["_"+ident];assert(func,"Cannot call unknown function "+ident+", make sure it is exported");return func}function ccall(ident,returnType,argTypes,args,opts){var toC={"string":function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){var len=(str.length<<2)+1;ret=stackAlloc(len);stringToUTF8(str,ret,len);}return ret},"array":function(arr){var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType==="string")return UTF8ToString(ret);if(returnType==="boolean")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i]);}else{cArgs[i]=args[i];}}}var ret=func.apply(null,cArgs);ret=convertReturnValue(ret);if(stack!==0)stackRestore(stack);return ret}var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(u8Array,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(u8Array[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&u8Array.subarray&&UTF8Decoder){return UTF8Decoder.decode(u8Array.subarray(idx,endPtr))}else{var str="";while(idx<endPtr){var u0=u8Array[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2;}else{u0=(u0&7)<<18|u1<<12|u2<<6|u8Array[idx++]&63;}if(u0<65536){str+=String.fromCharCode(u0);}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023);}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023;}if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u;}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63;}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}else{if(outIdx+3>=endIdx)break;outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}}outU8Array[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}var UTF16Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf-16le"):undefined;function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer);}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=HEAP16=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=HEAPU16=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=HEAPF32=new Float32Array(buf);Module["HEAPF64"]=HEAPF64=new Float64Array(buf);}var DYNAMIC_BASE=13920,DYNAMICTOP_PTR=3648;var INITIAL_TOTAL_MEMORY=Module["TOTAL_MEMORY"]||16777216;if(Module["buffer"]){buffer=Module["buffer"];}else{buffer=new ArrayBuffer(INITIAL_TOTAL_MEMORY);}INITIAL_TOTAL_MEMORY=buffer.byteLength;updateGlobalBufferAndViews(buffer);HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){Module["dynCall_v"](func);}else{Module["dynCall_vi"](func,callback.arg);}}else{func(callback.arg===undefined?null:callback.arg);}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift());}}callRuntimeCallbacks(__ATPRERUN__);}function initRuntime(){callRuntimeCallbacks(__ATINIT__);}function preMain(){callRuntimeCallbacks(__ATMAIN__);}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift());}}callRuntimeCallbacks(__ATPOSTRUN__);}function addOnPreRun(cb){__ATPRERUN__.unshift(cb);}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb);}var runDependencies=0;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}if(runDependencies==0){if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback();}}}Module["preloadedImages"]={};Module["preloadedAudios"]={};var memoryInitializer=null;var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return String.prototype.startsWith?filename.startsWith(dataURIPrefix):filename.indexOf(dataURIPrefix)===0}var ASM_CONSTS=[function($0){return Module.trapOnInstructionFetch($0)},function($0){return Module.busRead32($0)},function($0,$1){Module.busWrite32($0,$1);},function($0){return Module.busRead16($0)},function($0,$1){return Module.trapOnBx32($0,$1)},function($0,$1){Module.busWrite16($0,$1);}];function _emscripten_asm_const_iii(code,a0,a1){return ASM_CONSTS[code](a0,a1)}function _emscripten_asm_const_ii(code,a0){return ASM_CONSTS[code](a0)}memoryInitializer="data:application/octet-stream;base64,AAAAAAAAAAARAAoAERERAAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABEADwoREREDCgcAARMJCwsAAAkGCwAACwAGEQAAABEREQAAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAARAAoKERERAAoAAAIACQsAAAAJAAsAAAsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAMAAAAAAkMAAAAAAAMAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAA0AAAAEDQAAAAAJDgAAAAAADgAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAPAAAAAA8AAAAACRAAAAAAABAAABAAABIAAAASEhIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAABISEgAAAAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAAAAAAAAAAAAAoAAAAACgAAAAAJCwAAAAAACwAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAwAAAAACQwAAAAAAAwAAAwAADAxMjM0NTY3ODlBQkNERUYFAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAQAAAHkNAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABkCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHRodW1idWxhdG9yAHsgcmV0dXJuIE1vZHVsZS5idXNSZWFkMTYoJDApOyB9AHsgcmV0dXJuIE1vZHVsZS5idXNSZWFkMzIoJDApOyB9AHsgTW9kdWxlLmJ1c1dyaXRlMTYoJDAsICQxKTsgfQB7IE1vZHVsZS5idXNXcml0ZTMyKCQwLCAkMSk7IH0AcGMgaGFzIGxzYml0IHNldCAweCUwOFgKAHsgcmV0dXJuIE1vZHVsZS50cmFwT25JbnN0cnVjdGlvbkZldGNoKCQwKTsgfQAtLS0gMHglMDhYOiAweCUwNFggAGFkYyByJXUsciV1CgBhZGRzIHIldSxyJXUsIzB4JVgKAGFkZHMgciV1LCMweCUwMlgKAGFkZHMgciV1LHIldSxyJXUKAGFkZCByJXUsciV1CgBhZGQgcGMsLi4uIHByb2R1Y2VkIGFuIGFybSBhZGRyZXNzIDB4JTA4WCAweCUwOFgKAGFkZCByJXUsUEMsIzB4JTAyWAoAYWRkIHIldSxTUCwjMHglMDJYCgBhZGQgU1AsIzB4JTAyWAoAYW5kcyByJXUsciV1CgBhc3JzIHIldSxyJXUsIzB4JVgKAGFzcnMgciV1LHIldQoAYmVxIDB4JTA4WAoAYm5lIDB4JTA4WAoAYmNzIDB4JTA4WAoAYmNjIDB4JTA4WAoAYm1pIDB4JTA4WAoAYnBsIDB4JTA4WAoAYnZzIDB4JTA4WAoAYnZjIDB4JTA4WAoAYmhpIDB4JTA4WAoAYmxzIDB4JTA4WAoAYmdlIDB4JTA4WAoAYmx0IDB4JTA4WAoAYmd0IDB4JTA4WAoAYmxlIDB4JTA4WAoAQiAweCUwOFgKAGJpY3MgciV1LHIldQoAYmtwdCAweCUwMlgKAGJsIDB4JTA4WAoAYmx4IHIldQoAY2Fubm90IGJyYW5jaCB0byBhcm0gMHglMDhYIDB4JTA0WAoAYnggciV1CgB7IHJldHVybiBNb2R1bGUudHJhcE9uQngzMigkMCwgJDEpOyB9AGNtbnMgciV1LHIldQoAY21wIHIldSwjMHglMDJYCgBjbXBzIHIldSxyJXUKAGNwcyBUT0RPCgBjcHkgciV1LHIldQoAZW9ycyByJXUsciV1CgBsZG1pYSByJXUhLHsAciV1AH0KAGxkciByJXUsW3IldSwjMHglWF0KAGxkciByJXUsW3IldSxyJXVdCgBsZHIgciV1LFtQQysjMHglWF0KAGxkciByJXUsW1NQKyMweCVYXQoAbGRyYiByJXUsW3IldSwjMHglWF0KAGxkcmIgciV1LFtyJXUsciV1XQoAbGRyaCByJXUsW3IldSwjMHglWF0KAGxkcmggciV1LFtyJXUsciV1XQoAbGRyc2IgciV1LFtyJXUsciV1XQoAbGRyc2ggciV1LFtyJXUsciV1XQoAbHNscyByJXUsciV1LCMweCVYCgBsc2xzIHIldSxyJXUKAGxzcnMgciV1LHIldSwjMHglWAoAbHNycyByJXUsciV1CgBtb3ZzIHIldSwjMHglMDJYCgBtb3ZzIHIldSxyJXUKAG1vdiByJXUsciV1CgBtdWxzIHIldSxyJXUKAG12bnMgciV1LHIldQoAbmVncyByJXUsciV1CgBvcnJzIHIldSxyJXUKAHBvcCB7AHBjAHBvcCB7cmN9IHdpdGggYW4gQVJNIGFkZHJlc3MgcGMgMHglMDhYIHBvcHBlZCAweCUwOFgKAHB1c2ggewBscgBwdXNoIHtscn0gd2l0aCBhbiBBUk0gYWRkcmVzcyBwYyAweCUwOFggcG9wcGVkIDB4JTA4WAoAcmV2IHIldSxyJXUKAHJldjE2IHIldSxyJXUKAHJldnNoIHIldSxyJXUKAHJvcnMgciV1LHIldQoAc2JjIHIldSxyJXUKAHNldGVuZCBub3QgaW1wbGVtZW50ZWQKAHN0bWlhIHIldSEsewBzdHIgciV1LFtyJXUsIzB4JVhdCgBzdHIgciV1LFtyJXUsciV1XQoAc3RyIHIldSxbU1AsIzB4JVhdCgBzdHJiIHIldSxbciV1LCMweCVYXQoAc3RyYiByJXUsW3IldSxyJXVdCgBzdHJoIHIldSxbciV1LCMweCVYXQoAc3RyaCByJXUsW3IldSxyJXVdCgBzdWJzIHIldSxyJXUsIzB4JVgKAHN1YnMgciV1LCMweCUwMlgKAHN1YnMgciV1LHIldSxyJXUKAHN1YiBTUCwjMHglMDJYCgBzd2kgMHglMDJYCgAKCnN3aSAweCUwMlgKAHN4dGIgciV1LHIldQoAc3h0aCByJXUsciV1CgB0c3QgciV1LHIldQoAdXh0YiByJXUsciV1CgB1eHRoIHIldSxyJXUKAGludmFsaWQgaW5zdHJ1Y3Rpb24gMHglMDhYIDB4JTA0WAoALSsgICAwWDB4AChudWxsKQAtMFgrMFggMFgtMHgrMHggMHgAaW5mAElORgBuYW4ATkFOAC4=";var tempDoublePtr=3664;function demangle(func){return func}function demangleAll(text){var regex=/\b__Z[\w\d_]+/g;return text.replace(regex,function(x){var y=demangle(x);return x===y?x:y+" ["+x+"]"})}function jsStackTrace(){var err=new Error;if(!err.stack){try{throw new Error(0)}catch(e){err=e;}if(!err.stack){return "(no stack trace available)"}}return err.stack.toString()}function stackTrace(){var js=jsStackTrace();if(Module["extraStackTrace"])js+="\n"+Module["extraStackTrace"]();return demangleAll(js)}var SYSCALLS={buffers:[null,[],[]],printChar:function(stream,curr){var buffer=SYSCALLS.buffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0;}else{buffer.push(curr);}},varargs:0,get:function(varargs){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(){var ret=UTF8ToString(SYSCALLS.get());return ret},get64:function(){var low=SYSCALLS.get(),high=SYSCALLS.get();return low},getZero:function(){SYSCALLS.get();}};function ___syscall140(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),offset_high=SYSCALLS.get(),offset_low=SYSCALLS.get(),result=SYSCALLS.get(),whence=SYSCALLS.get();return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall6(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD();return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function flush_NO_FILESYSTEM(){var fflush=Module["_fflush"];if(fflush)fflush(0);var buffers=SYSCALLS.buffers;if(buffers[1].length)SYSCALLS.printChar(1,10);if(buffers[2].length)SYSCALLS.printChar(2,10);}function _fd_write(stream,iov,iovcnt,pnum){try{var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];for(var j=0;j<len;j++){SYSCALLS.printChar(stream,HEAPU8[ptr+j]);}num+=len;}HEAP32[pnum>>2]=num;return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___wasi_fd_write(){return _fd_write.apply(null,arguments)}function _emscripten_get_heap_size(){return HEAP8.length}function _exit(status){exit(status);}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest);}function ___setErrNo(value){if(Module["___errno_location"])HEAP32[Module["___errno_location"]()>>2]=value;return value}function abortOnCannotGrowMemory(requestedSize){abort("OOM");}function _emscripten_resize_heap(requestedSize){abortOnCannotGrowMemory();}function intArrayToString(array){var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){chr&=255;}ret.push(String.fromCharCode(chr));}return ret.join("")}var decodeBase64=typeof atob==="function"?atob:function(input){var keyStr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";var output="";var chr1,chr2,chr3;var enc1,enc2,enc3,enc4;var i=0;input=input.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{enc1=keyStr.indexOf(input.charAt(i++));enc2=keyStr.indexOf(input.charAt(i++));enc3=keyStr.indexOf(input.charAt(i++));enc4=keyStr.indexOf(input.charAt(i++));chr1=enc1<<2|enc2>>4;chr2=(enc2&15)<<4|enc3>>2;chr3=(enc3&3)<<6|enc4;output=output+String.fromCharCode(chr1);if(enc3!==64){output=output+String.fromCharCode(chr2);}if(enc4!==64){output=output+String.fromCharCode(chr3);}}while(i<input.length);return output};function intArrayFromBase64(s){if(typeof ENVIRONMENT_IS_NODE==="boolean"&&ENVIRONMENT_IS_NODE){var buf;try{buf=Buffer.from(s,"base64");}catch(_){buf=new Buffer(s,"base64");}return new Uint8Array(buf.buffer,buf.byteOffset,buf.byteLength)}try{var decoded=decodeBase64(s);var bytes=new Uint8Array(decoded.length);for(var i=0;i<decoded.length;++i){bytes[i]=decoded.charCodeAt(i);}return bytes}catch(_){throw new Error("Converting base64 string to bytes failed.")}}function tryParseAsDataURI(filename){if(!isDataURI(filename)){return}return intArrayFromBase64(filename.slice(dataURIPrefix.length))}var asmGlobalArg={"Math":Math,"Int8Array":Int8Array,"Int16Array":Int16Array,"Int32Array":Int32Array,"Uint8Array":Uint8Array,"Uint16Array":Uint16Array,"Float32Array":Float32Array,"Float64Array":Float64Array};var asmLibraryArg={"a":abort,"b":setTempRet0,"c":getTempRet0,"d":___setErrNo,"e":___syscall140,"f":___syscall6,"g":___wasi_fd_write,"h":_emscripten_asm_const_ii,"i":_emscripten_asm_const_iii,"j":_emscripten_get_heap_size,"k":_emscripten_memcpy_big,"l":_emscripten_resize_heap,"m":_exit,"n":_fd_write,"o":abortOnCannotGrowMemory,"p":demangle,"q":demangleAll,"r":flush_NO_FILESYSTEM,"s":jsStackTrace,"t":stackTrace,"u":tempDoublePtr,"v":DYNAMICTOP_PTR};// EMSCRIPTEN_START_ASM
	var asm=(/** @suppress {uselessCode} */ function(global,env,buffer) {
	"use asm";var a=new global.Int8Array(buffer),b=new global.Int16Array(buffer),c=new global.Int32Array(buffer),d=new global.Uint8Array(buffer),e=new global.Uint16Array(buffer),f=new global.Float32Array(buffer),g=new global.Float64Array(buffer),h=env.u|0,i=env.v|0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0.0,r=global.Math.imul,s=global.Math.clz32,t=env.a,u=env.b,v=env.c,w=env.d,x=env.e,y=env.f,z=env.g,A=env.h,B=env.i,C=env.j,D=env.k,E=env.l,F=env.m,G=env.n,H=env.o,I=env.p,J=env.q,K=env.r,L=env.s,M=env.t,N=3680,O=13920,P=0.0;
	// EMSCRIPTEN_START_FUNCS
	function V(a){a=a|0;var b=0;b=N;N=N+a|0;N=N+15&-16;return b|0}function W(){return N|0}function X(a){a=a|0;N=a;}function Y(a,b){a=a|0;b=b|0;N=a;O=b;}function Z(a){a=a|0;c[712]=a;return}function _(){return 888}function $(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;c[713]=0;if(!a){f=0;return f|0}b=0;d=0;while(1){g=fa()|0;e=(c[713]|0)!=0;d=(g|0)==0?d:g;b=b+1|0;if(e|(g|0)==0^1)break;if(b>>>0>=a>>>0){b=0;f=6;break}}if((f|0)==6)return b|0;g=e?10:d;return g|0}function aa(){c[713]=1;return}function ba(b){b=b|0;a[3440]=b;return}function ca(a){a=a|0;var b=0,d=0;d=N;N=N+16|0;b=c[2784+((a&15)<<2)>>2]|0;if((a&15|0)!=15){N=d;return b|0}if(b&1|0){a=c[160]|0;c[d>>2]=b;va(a,1028,d)|0;}b=b&-2;N=d;return b|0}function da(a,b){a=a|0;b=b|0;c[2784+((a&15)<<2)>>2]=(a&15|0)==15?b&-2:b;return}function ea(){c[714]=4;c[715]=0;c[716]=0;c[717]=0;c[718]=0;return 0}function fa(){var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;o=N;N=N+1232|0;d=c[711]|0;if(d&1|0){n=c[160]|0;c[o>>2]=d;va(n,1028,o)|0;}b=c[712]|0;if(!b){b=A(0,(d&-2)+-2|0)|0;if(b|0){n=b;N=o;return n|0}}else if(((d&-2)+-2|0)==(b|0)){n=20;N=o;return n|0}if((d&-2)>>>0>4026531839&(c[717]|0)!=0){c[717]=0;n=c[709]|0;c[696]=A(1,n|0)|0;c[697]=A(1,n+4|0)|0;c[698]=A(1,n+8|0)|0;c[699]=A(1,n+12|0)|0;c[708]=A(1,n+16|0)|0;c[710]=A(1,n+20|0)|0;e=A(1,n+24|0)|0;c[718]=A(1,n+28|0)|0;c[709]=n+32;}else e=d&-2;b=c[714]|0;do if(b&1){d=c[716]|0;if(!d){c[716]=c[715];c[714]=b|65536;b=b|65536;break}else{c[716]=d+-1;break}}while(0);if((b&3|0)==3?(b&65536|0)!=0&(c[717]|0)==0:0){f=c[709]|0;d=c[718]|0;a:do if((f+-4&-268435456|0)==-536870912)switch((f+536813548|0)>>>2|f+536813548<<30|0){case 0:{c[714]=d&65543;if((b&1|0)!=0|(d&1|0)==0)break a;c[716]=c[715];break a}case 1:{c[715]=d&16777215;break a}case 2:{c[716]=d&16777215;break a}case 3:break a;default:break a}else B(2,f+-4|0,d|0)|0;while(0);b:do if((f+-8&-268435456|0)==-536870912)switch((f+536813544|0)>>>2|f+536813544<<30|0){case 0:{n=c[714]|0;c[714]=e&65543;if((e&1|0)==0|(n&1|0)!=0)break b;c[716]=c[715];break b}case 1:{c[715]=e&16777215;break b}case 2:{c[716]=e&16777215;break b}case 3:break b;default:break b}else B(2,f+-8|0,e|0)|0;while(0);b=c[710]|0;c:do if((f+-12&-268435456|0)==-536870912)switch((f+536813540|0)>>>2|f+536813540<<30|0){case 0:{n=c[714]|0;c[714]=b&65543;if((b&1|0)==0|(n&1|0)!=0)break c;c[716]=c[715];break c}case 1:{c[715]=b&16777215;break c}case 2:{c[716]=b&16777215;break c}case 3:break c;default:break c}else B(2,f+-12|0,b|0)|0;while(0);b=c[708]|0;d:do if((f+-16&-268435456|0)==-536870912)switch((f+536813536|0)>>>2|f+536813536<<30|0){case 0:{n=c[714]|0;c[714]=b&65543;if((b&1|0)==0|(n&1|0)!=0)break d;c[716]=c[715];break d}case 1:{c[715]=b&16777215;break d}case 2:{c[716]=b&16777215;break d}case 3:break d;default:break d}else B(2,f+-16|0,b|0)|0;while(0);b=c[699]|0;e:do if((f+-20&-268435456|0)==-536870912)switch((f+536813532|0)>>>2|f+536813532<<30|0){case 0:{n=c[714]|0;c[714]=b&65543;if((b&1|0)==0|(n&1|0)!=0)break e;c[716]=c[715];break e}case 1:{c[715]=b&16777215;break e}case 2:{c[716]=b&16777215;break e}case 3:break e;default:break e}else B(2,f+-20|0,b|0)|0;while(0);b=c[698]|0;f:do if((f+-24&-268435456|0)==-536870912)switch((f+536813528|0)>>>2|f+536813528<<30|0){case 0:{n=c[714]|0;c[714]=b&65543;if((b&1|0)==0|(n&1|0)!=0)break f;c[716]=c[715];break f}case 1:{c[715]=b&16777215;break f}case 2:{c[716]=b&16777215;break f}case 3:break f;default:break f}else B(2,f+-24|0,b|0)|0;while(0);b=c[697]|0;g:do if((f+-28&-268435456|0)==-536870912)switch((f+536813524|0)>>>2|f+536813524<<30|0){case 0:{n=c[714]|0;c[714]=b&65543;if((b&1|0)==0|(n&1|0)!=0)break g;c[716]=c[715];break g}case 1:{c[715]=b&16777215;break g}case 2:{c[716]=b&16777215;break g}case 3:break g;default:break g}else B(2,f+-28|0,b|0)|0;while(0);b=c[696]|0;h:do if((f+-32&-268435456|0)==-536870912)switch((f+536813520|0)>>>2|f+536813520<<30|0){case 0:{n=c[714]|0;c[714]=b&65543;if((b&1|0)==0|(n&1|0)!=0)break h;c[716]=c[715];break h}case 1:{c[715]=b&16777215;break h}case 2:{c[716]=b&16777215;break h}case 3:break h;default:break h}else B(2,f+-32|0,b|0)|0;while(0);c[709]=f+-32;e=(A(1,60)|0)+2|0;c[710]=-7;c[717]=1;}g=e+-2|0;n=A(3,g|0)|0;m=e+2|0;c[711]=m&-2;if(a[3440]|0){l=c[160]|0;c[o+8>>2]=g;c[o+8+4>>2]=n;va(l,1099,o+8|0)|0;}if((n&65472|0)==16704){if(a[3440]|0){m=c[160]|0;c[o+16>>2]=n&7;c[o+16+4>>2]=n>>>3&7;va(m,1119,o+16|0)|0;}d=c[2784+((n&7)<<2)>>2]|0;e=c[2784+((n>>>3&7)<<2)>>2]|0;m=c[718]|0;c[2784+((n&7)<<2)>>2]=e+d+(m>>>29&1);b=(e+d+(m>>>29&1)|0)<0?m|-2147483648:m&2147483647;b=(e+d+(m>>>29&1)|0)==0?b|1073741824:b&-1073741825;c[718]=b;if(!(b&536870912)){n=((e>>>31)+(d>>>31)+(((e&2147483647)+(d&2147483647)|0)>>>31)&2|0)==0?b&-536870913:b|536870912;c[718]=(((e&2147483647)+(d&2147483647)|0)>>>31|0)==(((e>>>31)+(d>>>31)+(((e&2147483647)+(d&2147483647)|0)>>>31)|0)>>>1&1|0)?n&-268435457:n|268435456;n=0;N=o;return n|0}else{m=(e>>>31)+(d>>>31)+(((e&2147483647)+(d&2147483647)+1|0)>>>31)|0;n=(m&2|0)==0?b&-536870913:b|536870912;c[718]=(((e&2147483647)+(d&2147483647)+1|0)>>>31|0)==(m>>>1&1|0)?n&-268435457:n|268435456;n=0;N=o;return n|0}}if((n&65024|0)==7168?n>>>6&7|0:0){if(a[3440]|0){m=c[160]|0;c[o+24>>2]=n&7;c[o+24+4>>2]=n>>>3&7;c[o+24+8>>2]=n>>>6&7;va(m,1132,o+24|0)|0;}l=c[2784+((n>>>3&7)<<2)>>2]|0;c[2784+((n&7)<<2)>>2]=l+(n>>>6&7);m=c[718]|0;m=(l+(n>>>6&7)|0)<0?m|-2147483648:m&2147483647;m=(l+(n>>>6&7)|0)==0?m|1073741824:m&-1073741825;m=((((l&2147483647)+(n>>>6&7)|0)>>>31)+(l>>>31)&2|0)==0?m&-536870913:m|536870912;c[718]=(((l&2147483647)+(n>>>6&7)|0)>>>31|0)==(((((l&2147483647)+(n>>>6&7)|0)>>>31)+(l>>>31)|0)>>>1|0)?m&-268435457:m|268435456;n=0;N=o;return n|0}if((n&63488|0)==12288){if(a[3440]|0){m=c[160]|0;c[o+40>>2]=n>>>8&7;c[o+40+4>>2]=n&255;va(m,1152,o+40|0)|0;}l=c[2784+((n>>>8&7)<<2)>>2]|0;c[2784+((n>>>8&7)<<2)>>2]=l+(n&255);m=c[718]|0;m=(l+(n&255)|0)<0?m|-2147483648:m&2147483647;m=(l+(n&255)|0)==0?m|1073741824:m&-1073741825;m=((((l&2147483647)+(n&255)|0)>>>31)+(l>>>31)&2|0)==0?m&-536870913:m|536870912;c[718]=(((l&2147483647)+(n&255)|0)>>>31|0)==(((((l&2147483647)+(n&255)|0)>>>31)+(l>>>31)|0)>>>1|0)?m&-268435457:m|268435456;n=0;N=o;return n|0}if((n&65024|0)==6144){if(a[3440]|0){m=c[160]|0;c[o+48>>2]=n&7;c[o+48+4>>2]=n>>>3&7;c[o+48+8>>2]=n>>>6&7;va(m,1170,o+48|0)|0;}m=c[2784+((n>>>3&7)<<2)>>2]|0;l=c[2784+((n>>>6&7)<<2)>>2]|0;c[2784+((n&7)<<2)>>2]=l+m;n=c[718]|0;n=(l+m|0)<0?n|-2147483648:n&2147483647;n=(l+m|0)==0?n|1073741824:n&-1073741825;n=((l>>>31)+(m>>>31)+(((l&2147483647)+(m&2147483647)|0)>>>31)&2|0)==0?n&-536870913:n|536870912;c[718]=(((l&2147483647)+(m&2147483647)|0)>>>31|0)==(((l>>>31)+(m>>>31)+(((l&2147483647)+(m&2147483647)|0)>>>31)|0)>>>1&1|0)?n&-268435457:n|268435456;n=0;N=o;return n|0}if((n&65280|0)==17408){if(a[3440]|0){l=c[160]|0;c[o+64>>2]=n>>>4&8|n&7;c[o+64+4>>2]=n>>>3&15;va(l,1188,o+64|0)|0;}b=c[2784+((n>>>4&8|n&7)<<2)>>2]|0;if((n>>>4&8|n&7|0)==15){if(b&1|0){l=c[160]|0;c[o+72>>2]=b;va(l,1028,o+72|0)|0;}b=b&-2;}d=c[2784+((n>>>3&15)<<2)>>2]|0;if((n>>>3&15|0)==15){if(d&1|0){l=c[160]|0;c[o+80>>2]=d;va(l,1028,o+80|0)|0;}d=d&-2;}b=d+b|0;if((n>>>4&8|n&7|0)!=15){c[2784+((n>>>4&8|n&7)<<2)>>2]=b;n=0;N=o;return n|0}if(!(b&1)){n=c[160]|0;c[o+88>>2]=m;c[o+88+4>>2]=b;va(n,1201,o+88|0)|0;F(1);}c[711]=b+2&-2;n=0;N=o;return n|0}d=n&63488;switch(d<<16>>16){case -24576:{if(a[3440]|0){m=c[160]|0;c[o+96>>2]=n>>>8&7;c[o+96+4>>2]=n<<2&1020;va(m,1251,o+96|0)|0;}b=c[711]|0;if(b&1|0){m=c[160]|0;c[o+104>>2]=b;va(m,1028,o+104|0)|0;}c[2784+((n>>>8&7)<<2)>>2]=(b&-4)+(n<<2&1020);n=0;N=o;return n|0}case -22528:{if(a[3440]|0){m=c[160]|0;c[o+112>>2]=n>>>8&7;c[o+112+4>>2]=n<<2&1020;va(m,1271,o+112|0)|0;}c[2784+((n>>>8&7)<<2)>>2]=(c[709]|0)+(n<<2&1020);n=0;N=o;return n|0}default:{if((n&65408|0)==45056){if(a[3440]|0){m=c[160]|0;c[o+120>>2]=n<<2&508;va(m,1291,o+120|0)|0;}c[709]=(c[709]|0)+(n<<2&508);n=0;N=o;return n|0}if((n&65472|0)==16384){if(a[3440]|0){m=c[160]|0;c[o+128>>2]=n&7;c[o+128+4>>2]=n>>>3&7;va(m,1307,o+128|0)|0;}m=c[2784+((n>>>3&7)<<2)>>2]&c[2784+((n&7)<<2)>>2];c[2784+((n&7)<<2)>>2]=m;n=c[718]|0;n=(m|0)<0?n|-2147483648:n&2147483647;c[718]=(m|0)==0?n|1073741824:n&-1073741825;n=0;N=o;return n|0}if((n&63488|0)==4096){if(a[3440]|0){m=c[160]|0;c[o+136>>2]=n&7;c[o+136+4>>2]=n>>>3&7;c[o+136+8>>2]=n>>>6&31;va(m,1321,o+136|0)|0;}d=c[2784+((n>>>3&7)<<2)>>2]|0;do if(!(n>>>6&31)){b=c[718]|0;if((d|0)<0){c[718]=b|536870912;c[2784+((n&7)<<2)>>2]=-1;b=b|536870912;h=141;break}else{c[718]=b&-536870913;c[2784+((n&7)<<2)>>2]=0;b=b&1610612735;h=143;break}}else{b=c[718]|0;b=(d&1<<(n>>>6&31)+-1|0)==0?b&-536870913:b|536870912;c[718]=b;d=((d|0)<0?-1<<32-(n>>>6&31):0)|d>>>(n>>>6&31);c[2784+((n&7)<<2)>>2]=d;if((d|0)>=0)if(!d){b=b&1073741823;h=143;}else b=b&1073741823;else h=141;}while(0);if((h|0)==141)b=b&1073741823|-2147483648;else if((h|0)==143)b=b|1073741824;c[718]=b;n=0;N=o;return n|0}if((n&65472|0)==16640){if(a[3440]|0){m=c[160]|0;c[o+152>>2]=n&7;c[o+152+4>>2]=n>>>3&7;va(m,1341,o+152|0)|0;}d=c[2784+((n&7)<<2)>>2]|0;b=c[2784+((n>>>3&7)<<2)>>2]&255;do if(b){if(b>>>0<32){h=c[718]|0;h=(1<<b+-1&d|0)==0?h&-536870913:h|536870912;c[718]=h;b=((d|0)<0?-1<<32-b:0)|d>>>b;d=h;h=155;break}b=c[718]|0;if((d|0)<0){c[718]=b|536870912;c[2784+((n&7)<<2)>>2]=-1;b=b|-1610612736;h=156;break}else{c[718]=b&-536870913;c[2784+((n&7)<<2)>>2]=0;b=b&536870911;h=158;break}}else{b=d;d=c[718]|0;h=155;}while(0);do if((h|0)==155){c[2784+((n&7)<<2)>>2]=b;if((b|0)<0){b=d|-2147483648;h=156;break}if(!b){b=d&2147483647;h=158;}else b=d&1073741823;}while(0);if((h|0)==156)b=b&-1073741825;else if((h|0)==158)b=b|1073741824;c[718]=b;n=0;N=o;return n|0}i:do if((n&61440|0)==53248){f=(((n&128|0)==0?n&255:n|-256)<<1)+m|0;do switch(n>>>8&15){case 0:{if(a[3440]|0){n=c[160]|0;c[o+160>>2]=f+-1;va(n,1355,o+160|0)|0;}if(!(c[718]&1073741824)){n=0;N=o;return n|0}c[711]=f+2&-2;n=0;N=o;return n|0}case 1:{if(a[3440]|0){n=c[160]|0;c[o+168>>2]=f+-1;va(n,1367,o+168|0)|0;}if(c[718]&1073741824|0){n=0;N=o;return n|0}c[711]=f+2&-2;n=0;N=o;return n|0}case 2:{if(a[3440]|0){n=c[160]|0;c[o+176>>2]=f+-1;va(n,1379,o+176|0)|0;}if(!(c[718]&536870912)){n=0;N=o;return n|0}c[711]=f+2&-2;n=0;N=o;return n|0}case 3:{if(a[3440]|0){n=c[160]|0;c[o+184>>2]=f+-1;va(n,1391,o+184|0)|0;}if(c[718]&536870912|0){n=0;N=o;return n|0}c[711]=f+2&-2;n=0;N=o;return n|0}case 4:{if(a[3440]|0){n=c[160]|0;c[o+192>>2]=f+-1;va(n,1403,o+192|0)|0;}if((c[718]|0)>=0){n=0;N=o;return n|0}c[711]=f+2&-2;n=0;N=o;return n|0}case 5:{if(a[3440]|0){n=c[160]|0;c[o+200>>2]=f+-1;va(n,1415,o+200|0)|0;}if((c[718]|0)<0){n=0;N=o;return n|0}c[711]=f+2&-2;n=0;N=o;return n|0}case 6:{if(a[3440]|0){n=c[160]|0;c[o+208>>2]=f+-1;va(n,1427,o+208|0)|0;}if(!(c[718]&268435456)){n=0;N=o;return n|0}c[711]=f+2&-2;n=0;N=o;return n|0}case 7:{if(a[3440]|0){n=c[160]|0;c[o+216>>2]=f+-1;va(n,1439,o+216|0)|0;}if(c[718]&268435456|0){n=0;N=o;return n|0}c[711]=f+2&-2;n=0;N=o;return n|0}case 8:{if(a[3440]|0){n=c[160]|0;c[o+224>>2]=f+-1;va(n,1451,o+224|0)|0;}if((c[718]&1610612736|0)!=536870912){n=0;N=o;return n|0}c[711]=f+2&-2;n=0;N=o;return n|0}case 9:{if(a[3440]|0){n=c[160]|0;c[o+232>>2]=f+-1;va(n,1463,o+232|0)|0;}if((c[718]&1610612736|0)==536870912){n=0;N=o;return n|0}c[711]=f+2&-2;n=0;N=o;return n|0}case 10:{if(a[3440]|0){n=c[160]|0;c[o+240>>2]=f+-1;va(n,1475,o+240|0)|0;}b=c[718]&-1879048192;j:do if((b|0)<0){switch(b|0){case -1879048192:break j;default:b=0;}N=o;return b|0}else{switch(b|0){case 0:break j;default:b=0;}N=o;return b|0}while(0);c[711]=f+2&-2;n=0;N=o;return n|0}case 11:{if(a[3440]|0){n=c[160]|0;c[o+248>>2]=f+-1;va(n,1487,o+248|0)|0;}b=c[718]&-1879048192;k:do if((b|0)<268435456){switch(b|0){case -2147483648:break k;default:b=0;}N=o;return b|0}else{switch(b|0){case 268435456:break k;default:b=0;}N=o;return b|0}while(0);c[711]=f+2&-2;n=0;N=o;return n|0}case 12:{if(a[3440]|0){n=c[160]|0;c[o+256>>2]=f+-1;va(n,1499,o+256|0)|0;}n=c[718]|0;if(n&1073741824|0?1:(((n&-1879048192|0)==0?((n&-1879048192|0)==-1879048192?2:1):(n&-1879048192|0)==-1879048192&1)|0)==0){n=0;N=o;return n|0}c[711]=f+2&-2;n=0;N=o;return n|0}case 13:{if(a[3440]|0){n=c[160]|0;c[o+264>>2]=f+-1;va(n,1511,o+264|0)|0;}n=c[718]|0;if((((n&-1879048192|0)==-2147483648?((n&-1879048192|0)==268435456?2:1):(n&-1879048192|0)==268435456&1)|0)==(0-(n>>>30&1)|0)){n=0;N=o;return n|0}c[711]=f+2&-2;n=0;N=o;return n|0}default:break i}while(0)}while(0);if((n&63488|0)==57344){b=(((n&1024|0)==0?n&2047:n|-2048)<<1)+m|0;if(a[3440]|0){n=c[160]|0;c[o+272>>2]=b+-1;va(n,1523,o+272|0)|0;}c[711]=b+2&-2;n=0;N=o;return n|0}if((n&65472|0)==17280){if(a[3440]|0){m=c[160]|0;c[o+280>>2]=n&7;c[o+280+4>>2]=n>>>3&7;va(m,1533,o+280|0)|0;}m=c[2784+((n&7)<<2)>>2]&~c[2784+((n>>>3&7)<<2)>>2];c[2784+((n&7)<<2)>>2]=m;n=c[718]|0;n=(m|0)<0?n|-2147483648:n&2147483647;c[718]=(m|0)==0?n|1073741824:n&-1073741825;n=0;N=o;return n|0}if((n&65280|0)==48640){m=c[160]|0;c[o+288>>2]=n&255;va(m,1547,o+288|0)|0;n=1;N=o;return n|0}l:do if((n&57344|0)==57344){if((n&6144)<4096){switch(n&6144){case 2048:break;default:break l}b=(c[710]|0)+(n<<1&4094)&-4|2;if(a[3440]|0){n=c[160]|0;c[o+304>>2]=b+-3;va(n,1560,o+304|0)|0;}c[710]=e|1;c[711]=b;n=0;N=o;return n|0}switch(n&6144){case 4096:{if(a[3440]|0)Na(10,c[160]|0)|0;c[710]=(((n&1024|0)==0?n&2047:n|1046528)<<12)+m;n=0;N=o;return n|0}case 6144:{b=(c[710]|0)+(n<<1&4094)|0;if(a[3440]|0){n=c[160]|0;c[o+296>>2]=b+-1;va(n,1560,o+296|0)|0;}c[710]=e|1;c[711]=b+2&-2;n=0;N=o;return n|0}default:break l}}while(0);switch((n&65415)<<16>>16){case 18304:{if(a[3440]|0){l=c[160]|0;c[o+312>>2]=n>>>3&15;va(l,1571,o+312|0)|0;}b=c[2784+((n>>>3&15)<<2)>>2]|0;if((n>>>3&15|0)==15){if(b&1|0){l=c[160]|0;c[o+320>>2]=b;va(l,1028,o+320|0)|0;}b=b&-2;}b=b+2|0;if(!(b&1)){l=c[160]|0;c[o+328>>2]=m;c[o+328+4>>2]=n;va(l,1580,o+328|0)|0;n=2;N=o;return n|0}else{c[710]=e|1;c[711]=b&-2;n=0;N=o;return n|0}}case 18176:{if(a[3440]|0){m=c[160]|0;c[o+336>>2]=n>>>3&15;va(m,1616,o+336|0)|0;}b=c[2784+((n>>>3&15)<<2)>>2]|0;if((n>>>3&15|0)==15){if(b&1|0){n=c[160]|0;c[o+344>>2]=b;va(n,1028,o+344|0)|0;}b=b&-2;}b=b+2|0;if(b&1|0){c[711]=b&-2;n=0;N=o;return n|0}b=B(4,g|0,b|0)|0;if(b|0){n=b;N=o;return n|0}c[711]=(c[710]|0)+2&-2;n=0;N=o;return n|0}default:{if((n&65472|0)==17088){if(a[3440]|0){m=c[160]|0;c[o+352>>2]=n&7;c[o+352+4>>2]=n>>>3&7;va(m,1662,o+352|0)|0;}m=c[2784+((n&7)<<2)>>2]|0;l=c[2784+((n>>>3&7)<<2)>>2]|0;n=c[718]|0;n=(l+m|0)<0?n|-2147483648:n&2147483647;n=(l+m|0)==0?n|1073741824:n&-1073741825;n=((l>>>31)+(m>>>31)+(((l&2147483647)+(m&2147483647)|0)>>>31)&2|0)==0?n&-536870913:n|536870912;c[718]=(((l&2147483647)+(m&2147483647)|0)>>>31|0)==(((l>>>31)+(m>>>31)+(((l&2147483647)+(m&2147483647)|0)>>>31)|0)>>>1&1|0)?n&-268435457:n|268435456;n=0;N=o;return n|0}if((n&63488|0)==10240){if(a[3440]|0){m=c[160]|0;c[o+360>>2]=n>>>8&7;c[o+360+4>>2]=n&255;va(m,1676,o+360|0)|0;}k=c[2784+((n>>>8&7)<<2)>>2]|0;m=c[718]|0;m=(k-(n&255)|0)<0?m|-2147483648:m&2147483647;m=(k-(n&255)|0)==0?m|1073741824:m&-1073741825;l=(k>>>31)+1+((-2147483648-(n&255)+(k&2147483647)|0)>>>31)|0;m=(l&2|0)==0?m&-536870913:m|536870912;c[718]=((-2147483648-(n&255)+(k&2147483647)|0)>>>31|0)==(l>>>1&1|0)?m&-268435457:m|268435456;n=0;N=o;return n|0}if((n&65472|0)==17024){if(a[3440]|0){m=c[160]|0;c[o+368>>2]=n&7;c[o+368+4>>2]=n>>>3&7;va(m,1693,o+368|0)|0;}k=c[2784+((n&7)<<2)>>2]|0;l=c[2784+((n>>>3&7)<<2)>>2]|0;n=c[718]|0;n=(k-l|0)<0?n|-2147483648:n&2147483647;n=(k-l|0)==0?n|1073741824:n&-1073741825;m=(~l>>>31)+(k>>>31)+(((k&2147483647)+1+(~l&2147483647)|0)>>>31)|0;n=(m&2|0)==0?n&-536870913:n|536870912;c[718]=(((k&2147483647)+1+(~l&2147483647)|0)>>>31|0)==(m>>>1&1|0)?n&-268435457:n|268435456;n=0;N=o;return n|0}if((n&65280|0)==17664){if(a[3440]|0){m=c[160]|0;c[o+376>>2]=n>>>4&8|n&7;c[o+376+4>>2]=n>>>3&15;va(m,1693,o+376|0)|0;}b=c[2784+((n>>>4&8|n&7)<<2)>>2]|0;if((n>>>4&8|n&7|0)==15){if(b&1|0){m=c[160]|0;c[o+384>>2]=b;va(m,1028,o+384|0)|0;}d=b&-2;}else d=b;b=c[2784+((n>>>3&15)<<2)>>2]|0;if((n>>>3&15|0)==15){if(b&1|0){n=c[160]|0;c[o+392>>2]=b;va(n,1028,o+392|0)|0;}b=b&-2;}m=d-b|0;n=c[718]|0;n=(m|0)<0?n|-2147483648:n&2147483647;n=(m|0)==0?n|1073741824:n&-1073741825;m=~b;l=((d&2147483647)+1+(m&2147483647)|0)>>>31;m=(m>>>31)+(d>>>31)+l|0;n=(m&2|0)==0?n&-536870913:n|536870912;c[718]=(l|0)==(m>>>1&1|0)?n&-268435457:n|268435456;n=0;N=o;return n|0}if((n&65512|0)==46688&(a[3440]|0)!=0)oa(1707,9,1,c[160]|0)|0;b=n&65472;switch(b<<16>>16){case 17920:{if(a[3440]|0){m=c[160]|0;c[o+400>>2]=n&7;c[o+400+4>>2]=n>>>3&7;va(m,1717,o+400|0)|0;}c[2784+((n&7)<<2)>>2]=c[2784+((n>>>3&7)<<2)>>2];n=0;N=o;return n|0}case 16448:{if(a[3440]|0){m=c[160]|0;c[o+408>>2]=n&7;c[o+408+4>>2]=n>>>3&7;va(m,1730,o+408|0)|0;}m=c[2784+((n>>>3&7)<<2)>>2]^c[2784+((n&7)<<2)>>2];c[2784+((n&7)<<2)>>2]=m;n=c[718]|0;n=(m|0)<0?n|-2147483648:n&2147483647;c[718]=(m|0)==0?n|1073741824:n&-1073741825;n=0;N=o;return n|0}default:{m:do if(d<<16>>16<26624){switch(d<<16>>16){case -14336:break;default:break m}if(!(a[3440]|0))d=n&1;else{d=c[160]|0;c[o+416>>2]=n>>>8&7;va(d,1744,o+416|0)|0;if(!(n&1))b=0;else{c[o+424>>2]=0;va(d,1757,o+424|0)|0;b=1;}if(n&2){if(b|0)Na(44,d)|0;c[o+1168>>2]=1;va(d,1757,o+1168|0)|0;b=b+1|0;}if(n&4){if(b|0)Na(44,d)|0;c[o+1176>>2]=2;va(d,1757,o+1176|0)|0;b=b+1|0;}if(n&8){if(b|0)Na(44,d)|0;c[o+1184>>2]=3;va(d,1757,o+1184|0)|0;b=b+1|0;}if(n&16){if(b|0)Na(44,d)|0;c[o+1192>>2]=4;va(d,1757,o+1192|0)|0;b=b+1|0;}if(n&32){if(b|0)Na(44,d)|0;c[o+1200>>2]=5;va(d,1757,o+1200|0)|0;b=b+1|0;}if(n&64){if(b|0)Na(44,d)|0;c[o+1208>>2]=6;va(d,1757,o+1208|0)|0;b=b+1|0;}if(n&128|0){if(b|0)Na(44,d)|0;c[o+1216>>2]=7;va(d,1757,o+1216|0)|0;}oa(1761,2,1,d)|0;d=n&1;}b=c[2784+((n>>>8&7)<<2)>>2]|0;if(d){c[696]=A(1,b|0)|0;b=b+4|0;}if(n&2){c[697]=A(1,b|0)|0;b=b+4|0;}if(n&4){c[698]=A(1,b|0)|0;b=b+4|0;}if(n&8){c[699]=A(1,b|0)|0;b=b+4|0;}if(n&16){c[700]=A(1,b|0)|0;b=b+4|0;}if(n&32){c[701]=A(1,b|0)|0;b=b+4|0;}if(n&64){c[702]=A(1,b|0)|0;b=b+4|0;}if(n&128){c[703]=A(1,b|0)|0;b=b+4|0;}if(1<<(n>>>8&7)&n|0){n=0;N=o;return n|0}c[2784+((n>>>8&7)<<2)>>2]=b;n=0;N=o;return n|0}else{switch(d<<16>>16){case 26624:break;default:break m}if(a[3440]|0){m=c[160]|0;c[o+432>>2]=n&7;c[o+432+4>>2]=n>>>3&7;c[o+432+8>>2]=n>>>4&124;va(m,1764,o+432|0)|0;}c[2784+((n&7)<<2)>>2]=A(1,(c[2784+((n>>>3&7)<<2)>>2]|0)+(n>>>4&124)|0)|0;n=0;N=o;return n|0}while(0);if((n&65024|0)==22528){if(a[3440]|0){m=c[160]|0;c[o+448>>2]=n&7;c[o+448+4>>2]=n>>>3&7;c[o+448+8>>2]=n>>>6&7;va(m,1785,o+448|0)|0;}c[2784+((n&7)<<2)>>2]=A(1,(c[2784+((n>>>6&7)<<2)>>2]|0)+(c[2784+((n>>>3&7)<<2)>>2]|0)|0)|0;n=0;N=o;return n|0}n:do if(d<<16>>16<18432){switch(d<<16>>16){case -26624:break;default:break n}if(a[3440]|0){m=c[160]|0;c[o+480>>2]=n>>>8&7;c[o+480+4>>2]=n<<2&1020;va(m,1824,o+480|0)|0;}c[2784+((n>>>8&7)<<2)>>2]=A(1,(c[709]|0)+(n<<2&1020)|0)|0;n=0;N=o;return n|0}else{if(d<<16>>16>=30720){switch(d<<16>>16){case 30720:break;default:break n}if(a[3440]|0){m=c[160]|0;c[o+488>>2]=n&7;c[o+488+4>>2]=n>>>3&7;c[o+488+8>>2]=n>>>6&31;va(m,1844,o+488|0)|0;}l=(c[2784+((n>>>3&7)<<2)>>2]|0)+(n>>>6&31)|0;m=A(3,l&-2|0)|0;c[2784+((n&7)<<2)>>2]=((l&1|0)==0?m:m>>>8)&255;n=0;N=o;return n|0}switch(d<<16>>16){case 18432:break;default:break n}if(a[3440]|0){m=c[160]|0;c[o+464>>2]=n>>>8&7;c[o+464+4>>2]=n<<2&1020;va(m,1804,o+464|0)|0;}b=c[711]|0;if(b&1|0){m=c[160]|0;c[o+472>>2]=b;va(m,1028,o+472|0)|0;}c[2784+((n>>>8&7)<<2)>>2]=A(1,(b&-4)+(n<<2&1020)|0)|0;n=0;N=o;return n|0}while(0);if((n&65024|0)==23552){if(a[3440]|0){m=c[160]|0;c[o+504>>2]=n&7;c[o+504+4>>2]=n>>>3&7;c[o+504+8>>2]=n>>>6&7;va(m,1866,o+504|0)|0;}l=(c[2784+((n>>>6&7)<<2)>>2]|0)+(c[2784+((n>>>3&7)<<2)>>2]|0)|0;m=A(3,l&-2|0)|0;c[2784+((n&7)<<2)>>2]=((l&1|0)==0?m:m>>>8)&255;n=0;N=o;return n|0}if((n&63488|0)==34816){if(a[3440]|0){m=c[160]|0;c[o+520>>2]=n&7;c[o+520+4>>2]=n>>>3&7;c[o+520+8>>2]=n>>>5&62;va(m,1886,o+520|0)|0;}c[2784+((n&7)<<2)>>2]=(A(3,(c[2784+((n>>>3&7)<<2)>>2]|0)+(n>>>5&62)|0)|0)&65535;n=0;N=o;return n|0}switch((n&65024)<<16>>16){case 23040:{if(a[3440]|0){m=c[160]|0;c[o+536>>2]=n&7;c[o+536+4>>2]=n>>>3&7;c[o+536+8>>2]=n>>>6&7;va(m,1908,o+536|0)|0;}c[2784+((n&7)<<2)>>2]=(A(3,(c[2784+((n>>>6&7)<<2)>>2]|0)+(c[2784+((n>>>3&7)<<2)>>2]|0)|0)|0)&65535;n=0;N=o;return n|0}case 22016:{if(a[3440]|0){m=c[160]|0;c[o+552>>2]=n&7;c[o+552+4>>2]=n>>>3&7;c[o+552+8>>2]=n>>>6&7;va(m,1928,o+552|0)|0;}l=(c[2784+((n>>>6&7)<<2)>>2]|0)+(c[2784+((n>>>3&7)<<2)>>2]|0)|0;m=A(3,l&-2|0)|0;m=(l&1|0)==0?m:m>>>8;c[2784+((n&7)<<2)>>2]=(m&128|0)==0?m&255:m|-256;n=0;N=o;return n|0}case 24064:{if(a[3440]|0){m=c[160]|0;c[o+568>>2]=n&7;c[o+568+4>>2]=n>>>3&7;c[o+568+8>>2]=n>>>6&7;va(m,1949,o+568|0)|0;}m=A(3,(c[2784+((n>>>6&7)<<2)>>2]|0)+(c[2784+((n>>>3&7)<<2)>>2]|0)|0)|0;c[2784+((n&7)<<2)>>2]=(m&32768|0)==0?m&65535:m|-65536;n=0;N=o;return n|0}default:{if(!(n&63488)){if(a[3440]|0){m=c[160]|0;c[o+584>>2]=n&7;c[o+584+4>>2]=n>>>3&7;c[o+584+8>>2]=n>>>6&31;va(m,1970,o+584|0)|0;}b=c[2784+((n>>>3&7)<<2)>>2]|0;if(!(n>>>6&31))d=c[718]|0;else{d=c[718]|0;d=(b&1<<32-(n>>>6&31)|0)==0?d&-536870913:d|536870912;c[718]=d;b=b<<(n>>>6&31);}c[2784+((n&7)<<2)>>2]=b;n=(b|0)<0?d|-2147483648:d&2147483647;c[718]=(b|0)==0?n|1073741824:n&-1073741825;n=0;N=o;return n|0}if((n&65472|0)==16512){if(a[3440]|0){m=c[160]|0;c[o+600>>2]=n&7;c[o+600+4>>2]=n>>>3&7;va(m,1990,o+600|0)|0;}b=c[2784+((n&7)<<2)>>2]|0;d=c[2784+((n>>>3&7)<<2)>>2]&255;do if(!d){d=c[718]|0;h=357;}else{if(d>>>0<32){h=c[718]|0;h=(1<<32-d&b|0)==0?h&-536870913:h|536870912;c[718]=h;b=b<<d;d=h;h=357;break}if((d|0)==32){m=c[718]|0;b=(b&1|0)==0?m&-536870913:m|536870912;}else b=c[718]&-536870913;c[718]=b;c[2784+((n&7)<<2)>>2]=0;b=b&1073741823;h=360;}while(0);do if((h|0)==357){c[2784+((n&7)<<2)>>2]=b;if((b|0)>=0)if(!b){b=d&2147483647;h=360;break}else{b=d&1073741823;break}else{b=d&1073741823|-2147483648;break}}while(0);if((h|0)==360)b=b|1073741824;c[718]=b;n=0;N=o;return n|0}if((n&63488|0)==2048){if(a[3440]|0){m=c[160]|0;c[o+608>>2]=n&7;c[o+608+4>>2]=n>>>3&7;c[o+608+8>>2]=n>>>6&31;va(m,2004,o+608|0)|0;}b=c[2784+((n>>>3&7)<<2)>>2]|0;do if(n>>>6&31){d=c[718]|0;d=(b&1<<(n>>>6&31)+-1|0)==0?d&-536870913:d|536870912;c[718]=d;c[2784+((n&7)<<2)>>2]=b>>>(n>>>6&31);if((b>>>(n>>>6&31)|0)>=0)if(!(b>>>(n>>>6&31))){b=d&1073741823;h=370;break}else{b=d&1073741823;break}else{b=d&1073741823|-2147483648;break}}else{h=c[718]|0;b=(b|0)>-1?h&-536870913:h|536870912;c[718]=b;c[2784+((n&7)<<2)>>2]=0;b=b&2147483647;h=370;}while(0);if((h|0)==370)b=b|1073741824;c[718]=b;n=0;N=o;return n|0}if((n&65472|0)==16576){if(a[3440]|0){m=c[160]|0;c[o+624>>2]=n&7;c[o+624+4>>2]=n>>>3&7;va(m,2024,o+624|0)|0;}b=c[2784+((n&7)<<2)>>2]|0;d=c[2784+((n>>>3&7)<<2)>>2]&255;do if(!d){d=c[718]|0;h=383;}else{if(d>>>0<32){h=c[718]|0;h=(1<<d+-1&b|0)==0?h&-536870913:h|536870912;c[718]=h;b=b>>>d;d=h;h=383;break}if((d|0)==32){m=c[718]|0;b=(b|0)>-1?m&-536870913:m|536870912;}else b=c[718]&-536870913;c[718]=b;c[2784+((n&7)<<2)>>2]=0;b=b&1073741823;h=386;}while(0);do if((h|0)==383){c[2784+((n&7)<<2)>>2]=b;if((b|0)>=0)if(!b){b=d&2147483647;h=386;break}else{b=d&1073741823;break}else{b=d&1073741823|-2147483648;break}}while(0);if((h|0)==386)b=b|1073741824;c[718]=b;n=0;N=o;return n|0}if((n&63488|0)==8192){if(a[3440]|0){m=c[160]|0;c[o+632>>2]=n>>>8&7;c[o+632+4>>2]=n&255;va(m,2038,o+632|0)|0;}c[2784+((n>>>8&7)<<2)>>2]=n&255;m=c[718]&1073741823;c[718]=(n&255|0)==0?m|1073741824:m;n=0;N=o;return n|0}if((n&65472|0)==7168){if(a[3440]|0){m=c[160]|0;c[o+640>>2]=n&7;c[o+640+4>>2]=n>>>3&7;va(m,2056,o+640|0)|0;}m=c[2784+((n>>>3&7)<<2)>>2]|0;c[2784+((n&7)<<2)>>2]=m;n=c[718]|0;n=(m|0)<0?n|-2147483648:n&2147483647;c[718]=((m|0)==0?n|1073741824:n&-1879048193)&-805306369;n=0;N=o;return n|0}if((n&65280|0)==17920){if(a[3440]|0){m=c[160]|0;c[o+648>>2]=n>>>4&8|n&7;c[o+648+4>>2]=n>>>3&15;va(m,2070,o+648|0)|0;}b=c[2784+((n>>>3&15)<<2)>>2]|0;if((n>>>3&15|0)==15){if(b&1|0){m=c[160]|0;c[o+656>>2]=b;va(m,1028,o+656|0)|0;}b=b&-2;}if((n>>>4&8|n&7|0)==15){c[711]=b+2&-2;n=0;N=o;return n|0}else{c[2784+((n>>>4&8|n&7)<<2)>>2]=b;n=0;N=o;return n|0}}switch(((n&65472)+-16960|0)>>>6&67108863|0){case 4:{if(a[3440]|0){m=c[160]|0;c[o+664>>2]=n&7;c[o+664+4>>2]=n>>>3&7;va(m,2083,o+664|0)|0;}m=r(c[2784+((n>>>3&7)<<2)>>2]|0,c[2784+((n&7)<<2)>>2]|0)|0;c[2784+((n&7)<<2)>>2]=m;n=c[718]|0;n=(m|0)<0?n|-2147483648:n&2147483647;c[718]=(m|0)==0?n|1073741824:n&-1073741825;n=0;N=o;return n|0}case 6:{if(a[3440]|0){m=c[160]|0;c[o+672>>2]=n&7;c[o+672+4>>2]=n>>>3&7;va(m,2097,o+672|0)|0;}m=c[2784+((n>>>3&7)<<2)>>2]|0;c[2784+((n&7)<<2)>>2]=~m;n=c[718]|0;n=(m|0)>-1?n|-2147483648:n&2147483647;c[718]=(m|0)==-1?n|1073741824:n&-1073741825;n=0;N=o;return n|0}case 0:{if(a[3440]|0){m=c[160]|0;c[o+680>>2]=n&7;c[o+680+4>>2]=n>>>3&7;va(m,2111,o+680|0)|0;}l=c[2784+((n>>>3&7)<<2)>>2]|0;c[2784+((n&7)<<2)>>2]=0-l;n=c[718]|0;n=(0-l|0)<0?n|-2147483648:n&2147483647;n=(l|0)==0?n|1073741824:n&-1073741825;m=(((~l&2147483647)+1|0)>>>31)+(~l>>>31)|0;n=(m&2|0)==0?n&-536870913:n|536870912;c[718]=(((~l&2147483647)+1|0)>>>31|0)==(m>>>1|0)?n&-268435457:n|268435456;n=0;N=o;return n|0}case 3:{if(a[3440]|0){m=c[160]|0;c[o+688>>2]=n&7;c[o+688+4>>2]=n>>>3&7;va(m,2125,o+688|0)|0;}m=c[2784+((n>>>3&7)<<2)>>2]|c[2784+((n&7)<<2)>>2];c[2784+((n&7)<<2)>>2]=m;n=c[718]|0;n=(m|0)<0?n|-2147483648:n&2147483647;c[718]=(m|0)==0?n|1073741824:n&-1073741825;n=0;N=o;return n|0}default:switch((n&65024)<<16>>16){case -17408:{if(!(a[3440]|0))d=n&1;else{d=c[160]|0;oa(2139,5,1,d)|0;if(!(n&1))b=0;else{c[o+696>>2]=0;va(d,1757,o+696|0)|0;b=1;}if(n&2){if(b|0)Na(44,d)|0;c[o+1056>>2]=1;va(d,1757,o+1056|0)|0;b=b+1|0;}if(n&4){if(b|0)Na(44,d)|0;c[o+1064>>2]=2;va(d,1757,o+1064|0)|0;b=b+1|0;}if(n&8){if(b|0)Na(44,d)|0;c[o+1072>>2]=3;va(d,1757,o+1072|0)|0;b=b+1|0;}if(n&16){if(b|0)Na(44,d)|0;c[o+1080>>2]=4;va(d,1757,o+1080|0)|0;b=b+1|0;}if(n&32){if(b|0)Na(44,d)|0;c[o+1088>>2]=5;va(d,1757,o+1088|0)|0;b=b+1|0;}if(n&64){if(b|0)Na(44,d)|0;c[o+1096>>2]=6;va(d,1757,o+1096|0)|0;b=b+1|0;}if(n&128){if(b|0)Na(44,d)|0;c[o+1104>>2]=7;va(d,1757,o+1104|0)|0;b=b+1|0;}if(n&256|0){if(b|0)Na(44,d)|0;oa(2145,2,1,d)|0;}oa(1761,2,1,d)|0;d=n&1;}b=c[709]|0;if(d){c[696]=A(1,b|0)|0;b=b+4|0;}if(n&2){c[697]=A(1,b|0)|0;b=b+4|0;}if(n&4){c[698]=A(1,b|0)|0;b=b+4|0;}if(n&8){c[699]=A(1,b|0)|0;b=b+4|0;}if(n&16){c[700]=A(1,b|0)|0;b=b+4|0;}if(n&32){c[701]=A(1,b|0)|0;b=b+4|0;}if(n&64){c[702]=A(1,b|0)|0;b=b+4|0;}if(n&128){c[703]=A(1,b|0)|0;b=b+4|0;}if(n&256){d=A(1,b|0)|0;if(!(d&1)){n=c[160]|0;c[o+704>>2]=m;c[o+704+4>>2]=d;va(n,2148,o+704|0)|0;d=d&-2;}c[711]=d+2&-2;b=b+4|0;}c[709]=b;n=0;N=o;return n|0}case -19456:{l=c[160]|0;if(!(a[3440]|0)){b=n&2;d=n&4;e=n&8;f=n&16;g=n&32;h=n&64;i=n&128;k=n&256;j=n&1;}else{oa(2202,6,1,l)|0;if(!(n&1))b=0;else{c[o+712>>2]=0;va(l,1757,o+712|0)|0;b=1;}if(n&2){if(b|0)Na(44,l)|0;c[o+1112>>2]=1;va(l,1757,o+1112|0)|0;b=b+1|0;}if(n&4){if(b|0)Na(44,l)|0;c[o+1120>>2]=2;va(l,1757,o+1120|0)|0;b=b+1|0;}if(n&8){if(b|0)Na(44,l)|0;c[o+1128>>2]=3;va(l,1757,o+1128|0)|0;b=b+1|0;}if(n&16){if(b|0)Na(44,l)|0;c[o+1136>>2]=4;va(l,1757,o+1136|0)|0;b=b+1|0;}if(n&32){if(b|0)Na(44,l)|0;c[o+1144>>2]=5;va(l,1757,o+1144|0)|0;b=b+1|0;}if(n&64){if(b|0)Na(44,l)|0;c[o+1152>>2]=6;va(l,1757,o+1152|0)|0;b=b+1|0;}if(n&128){if(b|0)Na(44,l)|0;c[o+1160>>2]=7;va(l,1757,o+1160|0)|0;b=b+1|0;}if(n&256|0){if(b|0)Na(44,l)|0;oa(2209,2,1,l)|0;}oa(1761,2,1,l)|0;b=n&2;d=n&4;e=n&8;f=n&16;g=n&32;h=n&64;i=n&128;k=n&256;j=n&1;}g=(c[709]|0)-(j+(b>>>1)+(d>>>2)+(e>>>3)+(f>>>4)+(g>>>5)+(h>>>6)+(i>>>7)+(k>>>8)<<2)|0;b=g;e=0;f=1;while(1){if(!(f&n))d=b;else{d=c[2784+(e<<2)>>2]|0;o:do if((b&-268435456|0)==-536870912){j=b+536813552|0;switch(j>>>2|j<<30|0){case 0:{j=c[714]|0;c[714]=d&65543;if((d&1|0)==0|(j&1|0)!=0)break o;c[716]=c[715];break o}case 1:{c[715]=d&16777215;break o}case 2:{c[716]=d&16777215;break o}case 3:break o;default:break o}}else B(2,b|0,d|0)|0;while(0);d=b+4|0;}e=e+1|0;if((e|0)==8)break;else{b=d;f=f<<1&254;}}do if(k|0){b=c[710]|0;p:do if((d&-268435456|0)==-536870912){n=d+536813552|0;switch(n>>>2|n<<30|0){case 0:{n=c[714]|0;c[714]=b&65543;if((b&1|0)==0|(n&1|0)!=0)break p;c[716]=c[715];break p}case 1:{c[715]=b&16777215;break p}case 2:{c[716]=b&16777215;break p}case 3:break p;default:break p}}else B(2,d|0,b|0)|0;while(0);if(b&1|0)break;c[o+720>>2]=m;c[o+720+4>>2]=b;va(l,2212,o+720|0)|0;}while(0);c[709]=g;n=0;N=o;return n|0}default:{q:do if(b<<16>>16<-17728)switch(b<<16>>16){case -17920:{if(a[3440]|0){m=c[160]|0;c[o+728>>2]=n&7;c[o+728+4>>2]=n>>>3&7;va(m,2267,o+728|0)|0;}c[2784+((n&7)<<2)>>2]=Za(c[2784+((n>>>3&7)<<2)>>2]|0)|0;n=0;N=o;return n|0}case -17856:{if(a[3440]|0){m=c[160]|0;c[o+736>>2]=n&7;c[o+736+4>>2]=n>>>3&7;va(m,2280,o+736|0)|0;}m=c[2784+((n>>>3&7)<<2)>>2]|0;c[2784+((n&7)<<2)>>2]=m<<8&65280|m>>>8&255|m>>>16<<24|m>>>24<<16;n=0;N=o;return n|0}default:break q}else{if(b<<16>>16<16768){switch(b<<16>>16){case -17728:break;default:break q}if(a[3440]|0){m=c[160]|0;c[o+744>>2]=n&7;c[o+744+4>>2]=n>>>3&7;va(m,2295,o+744|0)|0;}m=c[2784+((n>>>3&7)<<2)>>2]|0;c[2784+((n&7)<<2)>>2]=(m&128|0)==0?m<<8&65280|m>>>8&255:m<<8&65280|m>>>8&255|-65536;n=0;N=o;return n|0}switch(b<<16>>16){case 16832:break;case 16768:{if(a[3440]|0){m=c[160]|0;c[o+760>>2]=n&7;c[o+760+4>>2]=n>>>3&7;va(m,2324,o+760|0)|0;}d=c[2784+((n&7)<<2)>>2]|0;e=c[2784+((n>>>3&7)<<2)>>2]|0;m=c[718]|0;c[2784+((n&7)<<2)>>2]=d-e+-1+(m>>>29&1);b=(d-e+-1+(m>>>29&1)|0)<0?m|-2147483648:m&2147483647;b=(d-e+-1+(m>>>29&1)|0)==0?b|1073741824:b&-1073741825;c[718]=b;if(!(b&536870912)){m=(~e>>>31)+(d>>>31)+(((~e&2147483647)+(d&2147483647)|0)>>>31)|0;n=(m&2|0)==0?b&-536870913:b|536870912;c[718]=(((~e&2147483647)+(d&2147483647)|0)>>>31|0)==(m>>>1&1|0)?n&-268435457:n|268435456;n=0;N=o;return n|0}else{m=(~e>>>31)+(d>>>31)+(((~e&2147483647)+(d&2147483647)+1|0)>>>31)|0;n=(m&2|0)==0?b&-536870913:b|536870912;c[718]=(((~e&2147483647)+(d&2147483647)+1|0)>>>31|0)==(m>>>1&1|0)?n&-268435457:n|268435456;n=0;N=o;return n|0}}default:break q}if(a[3440]|0){m=c[160]|0;c[o+752>>2]=n&7;c[o+752+4>>2]=n>>>3&7;va(m,2310,o+752|0)|0;}b=c[2784+((n&7)<<2)>>2]|0;d=c[2784+((n>>>3&7)<<2)>>2]|0;do if(d&255)if(!(d&31)){d=c[718]|0;d=(b|0)>-1?d&-536870913:d|536870912;c[718]=d;break}else{m=c[718]|0;m=(1<<(d&31)+-1&b|0)==0?m&-536870913:m|536870912;c[718]=m;b=b<<32-(d&31)|b>>>(d&31);d=m;break}else d=c[718]|0;while(0);c[2784+((n&7)<<2)>>2]=b;n=(b|0)<0?d|-2147483648:d&2147483647;c[718]=(b|0)==0?n|1073741824:n&-1073741825;n=0;N=o;return n|0}while(0);if((n&65527|0)==46672){oa(2337,23,1,c[160]|0)|0;n=1;N=o;return n|0}r:do if(d<<16>>16<24576){switch(d<<16>>16){case -16384:break;default:break r}if(a[3440]|0){d=c[160]|0;c[o+768>>2]=n>>>8&7;va(d,2361,o+768|0)|0;if(!(n&1))b=0;else{c[o+776>>2]=0;va(d,1757,o+776|0)|0;b=1;}if(n&2){if(b|0)Na(44,d)|0;c[o+1e3>>2]=1;va(d,1757,o+1e3|0)|0;b=b+1|0;}if(n&4){if(b|0)Na(44,d)|0;c[o+1008>>2]=2;va(d,1757,o+1008|0)|0;b=b+1|0;}if(n&8){if(b|0)Na(44,d)|0;c[o+1016>>2]=3;va(d,1757,o+1016|0)|0;b=b+1|0;}if(n&16){if(b|0)Na(44,d)|0;c[o+1024>>2]=4;va(d,1757,o+1024|0)|0;b=b+1|0;}if(n&32){if(b|0)Na(44,d)|0;c[o+1032>>2]=5;va(d,1757,o+1032|0)|0;b=b+1|0;}if(n&64){if(b|0)Na(44,d)|0;c[o+1040>>2]=6;va(d,1757,o+1040|0)|0;b=b+1|0;}if(n&128|0){if(b|0)Na(44,d)|0;c[o+1048>>2]=7;va(d,1757,o+1048|0)|0;}oa(1761,2,1,d)|0;}e=1;f=0;b=c[2784+((n>>>8&7)<<2)>>2]|0;while(1){if(e&n){d=c[2784+(f<<2)>>2]|0;s:do if((b&-268435456|0)==-536870912){m=b+536813552|0;switch(m>>>2|m<<30|0){case 0:{m=c[714]|0;c[714]=d&65543;if((d&1|0)==0|(m&1|0)!=0)break s;c[716]=c[715];break s}case 1:{c[715]=d&16777215;break s}case 2:{c[716]=d&16777215;break s}case 3:break s;default:break s}}else B(2,b|0,d|0)|0;while(0);b=b+4|0;}f=f+1|0;if((f|0)==8)break;else e=e<<1&254;}c[2784+((n>>>8&7)<<2)>>2]=b;n=0;N=o;return n|0}else{switch(d<<16>>16){case 24576:break;default:break r}if(a[3440]|0){m=c[160]|0;c[o+784>>2]=n&7;c[o+784+4>>2]=n>>>3&7;c[o+784+8>>2]=n>>>4&124;va(m,2374,o+784|0)|0;}d=(c[2784+((n>>>3&7)<<2)>>2]|0)+(n>>>4&124)|0;b=c[2784+((n&7)<<2)>>2]|0;if((d&-268435456|0)!=-536870912){B(2,d|0,b|0)|0;n=0;N=o;return n|0}switch((d+536813552|0)>>>2|d+536813552<<30|0){case 0:{n=c[714]|0;c[714]=b&65543;if((b&1|0)==0|(n&1|0)!=0){n=0;N=o;return n|0}c[716]=c[715];n=0;N=o;return n|0}case 1:{c[715]=b&16777215;n=0;N=o;return n|0}case 2:{c[716]=b&16777215;n=0;N=o;return n|0}case 3:{n=0;N=o;return n|0}default:{n=0;N=o;return n|0}}}while(0);if((n&65024|0)==20480){if(a[3440]|0){m=c[160]|0;c[o+800>>2]=n&7;c[o+800+4>>2]=n>>>3&7;c[o+800+8>>2]=n>>>6&7;va(m,2395,o+800|0)|0;}d=(c[2784+((n>>>6&7)<<2)>>2]|0)+(c[2784+((n>>>3&7)<<2)>>2]|0)|0;b=c[2784+((n&7)<<2)>>2]|0;if((d&-268435456|0)!=-536870912){B(2,d|0,b|0)|0;n=0;N=o;return n|0}switch((d+536813552|0)>>>2|d+536813552<<30|0){case 0:{n=c[714]|0;c[714]=b&65543;if((b&1|0)==0|(n&1|0)!=0){n=0;N=o;return n|0}c[716]=c[715];n=0;N=o;return n|0}case 1:{c[715]=b&16777215;n=0;N=o;return n|0}case 2:{c[716]=b&16777215;n=0;N=o;return n|0}case 3:{n=0;N=o;return n|0}default:{n=0;N=o;return n|0}}}t:do if(d<<16>>16<28672){switch(d<<16>>16){case -28672:break;default:break t}if(a[3440]|0){m=c[160]|0;c[o+816>>2]=n>>>8&7;c[o+816+4>>2]=n<<2&1020;va(m,2414,o+816|0)|0;}d=(c[709]|0)+(n<<2&1020)|0;b=c[2784+((n>>>8&7)<<2)>>2]|0;if((d&-268435456|0)!=-536870912){B(2,d|0,b|0)|0;n=0;N=o;return n|0}switch((d+536813552|0)>>>2|d+536813552<<30|0){case 0:{n=c[714]|0;c[714]=b&65543;if((b&1|0)==0|(n&1|0)!=0){n=0;N=o;return n|0}c[716]=c[715];n=0;N=o;return n|0}case 1:{c[715]=b&16777215;n=0;N=o;return n|0}case 2:{c[716]=b&16777215;n=0;N=o;return n|0}case 3:{n=0;N=o;return n|0}default:{n=0;N=o;return n|0}}}else{switch(d<<16>>16){case 28672:break;default:break t}if(a[3440]|0){m=c[160]|0;c[o+824>>2]=n&7;c[o+824+4>>2]=n>>>3&7;c[o+824+8>>2]=n>>>6&31;va(m,2434,o+824|0)|0;}e=(c[2784+((n>>>3&7)<<2)>>2]|0)+(n>>>6&31)|0;b=c[2784+((n&7)<<2)>>2]|0;d=A(3,e&-2|0)|0;if(!(e&1))b=d&65280|b&255;else b=d&255|b<<8;B(5,e&-2|0,b&65535|0)|0;n=0;N=o;return n|0}while(0);if((n&65024|0)==21504){if(a[3440]|0){m=c[160]|0;c[o+840>>2]=n&7;c[o+840+4>>2]=n>>>3&7;c[o+840+8>>2]=n>>>6&7;va(m,2456,o+840|0)|0;}e=(c[2784+((n>>>6&7)<<2)>>2]|0)+(c[2784+((n>>>3&7)<<2)>>2]|0)|0;b=c[2784+((n&7)<<2)>>2]|0;d=A(3,e&-2|0)|0;if(!(e&1))b=d&65280|b&255;else b=d&255|b<<8;B(5,e&-2|0,b&65535|0)|0;n=0;N=o;return n|0}if((n&63488|0)==32768){if(a[3440]|0){m=c[160]|0;c[o+856>>2]=n&7;c[o+856+4>>2]=n>>>3&7;c[o+856+8>>2]=n>>>5&62;va(m,2476,o+856|0)|0;}B(5,(c[2784+((n>>>3&7)<<2)>>2]|0)+(n>>>5&62)|0,c[2784+((n&7)<<2)>>2]&65535|0)|0;n=0;N=o;return n|0}u:do if((n&65024)<<16>>16<20992){switch((n&65024)<<16>>16){case 7680:break;default:break u}if(a[3440]|0){m=c[160]|0;c[o+888>>2]=n&7;c[o+888+4>>2]=n>>>3&7;c[o+888+8>>2]=n>>>6&7;va(m,2518,o+888|0)|0;}k=c[2784+((n>>>3&7)<<2)>>2]|0;c[2784+((n&7)<<2)>>2]=k-(n>>>6&7);m=c[718]|0;m=(k-(n>>>6&7)|0)<0?m|-2147483648:m&2147483647;m=(k-(n>>>6&7)|0)==0?m|1073741824:m&-1073741825;l=(k>>>31)+1+((-2147483648-(n>>>6&7)+(k&2147483647)|0)>>>31)|0;m=(l&2|0)==0?m&-536870913:m|536870912;c[718]=((-2147483648-(n>>>6&7)+(k&2147483647)|0)>>>31|0)==(l>>>1&1|0)?m&-268435457:m|268435456;n=0;N=o;return n|0}else{switch((n&65024)<<16>>16){case 20992:break;default:break u}if(a[3440]|0){m=c[160]|0;c[o+872>>2]=n&7;c[o+872+4>>2]=n>>>3&7;c[o+872+8>>2]=n>>>6&7;va(m,2498,o+872|0)|0;}B(5,(c[2784+((n>>>6&7)<<2)>>2]|0)+(c[2784+((n>>>3&7)<<2)>>2]|0)|0,c[2784+((n&7)<<2)>>2]&65535|0)|0;n=0;N=o;return n|0}while(0);if((n&63488|0)==14336){if(a[3440]|0){m=c[160]|0;c[o+904>>2]=n>>>8&7;c[o+904+4>>2]=n&255;va(m,2538,o+904|0)|0;}k=c[2784+((n>>>8&7)<<2)>>2]|0;c[2784+((n>>>8&7)<<2)>>2]=k-(n&255);m=c[718]|0;m=(k-(n&255)|0)<0?m|-2147483648:m&2147483647;m=(k-(n&255)|0)==0?m|1073741824:m&-1073741825;l=(k>>>31)+1+((-2147483648-(n&255)+(k&2147483647)|0)>>>31)|0;m=(l&2|0)==0?m&-536870913:m|536870912;c[718]=((-2147483648-(n&255)+(k&2147483647)|0)>>>31|0)==(l>>>1&1|0)?m&-268435457:m|268435456;n=0;N=o;return n|0}if((n&65024|0)==6656){if(a[3440]|0){m=c[160]|0;c[o+912>>2]=n&7;c[o+912+4>>2]=n>>>3&7;c[o+912+8>>2]=n>>>6&7;va(m,2556,o+912|0)|0;}k=c[2784+((n>>>3&7)<<2)>>2]|0;l=c[2784+((n>>>6&7)<<2)>>2]|0;c[2784+((n&7)<<2)>>2]=k-l;n=c[718]|0;n=(k-l|0)<0?n|-2147483648:n&2147483647;n=(k-l|0)==0?n|1073741824:n&-1073741825;m=(~l>>>31)+(k>>>31)+(((k&2147483647)+1+(~l&2147483647)|0)>>>31)|0;n=(m&2|0)==0?n&-536870913:n|536870912;c[718]=(((k&2147483647)+1+(~l&2147483647)|0)>>>31|0)==(m>>>1&1|0)?n&-268435457:n|268435456;n=0;N=o;return n|0}if((n&65408|0)==45184){if(a[3440]|0){m=c[160]|0;c[o+928>>2]=n<<2&508;va(m,2574,o+928|0)|0;}c[709]=(c[709]|0)-(n<<2&508);n=0;N=o;return n|0}if((n&65280|0)==57088){if(a[3440]|0){m=c[160]|0;c[o+936>>2]=n&255;va(m,2590,o+936|0)|0;}if((n&255|0)==204){c[696]=c[718];n=0;N=o;return n|0}else{m=c[160]|0;c[o+944>>2]=n&255;va(m,2602,o+944|0)|0;n=1;N=o;return n|0}}v:do if(b<<16>>16>=-19840){if(b<<16>>16<-19776){switch(b<<16>>16){case -19840:break;default:break v}if(a[3440]|0){m=c[160]|0;c[o+984>>2]=n&7;c[o+984+4>>2]=n>>>3&7;va(m,2671,o+984|0)|0;}c[2784+((n&7)<<2)>>2]=c[2784+((n>>>3&7)<<2)>>2]&65535;n=0;N=o;return n|0}if(b<<16>>16<16896){switch(b<<16>>16){case -19776:break;default:break v}if(a[3440]|0){m=c[160]|0;c[o+976>>2]=n&7;c[o+976+4>>2]=n>>>3&7;va(m,2657,o+976|0)|0;}c[2784+((n&7)<<2)>>2]=c[2784+((n>>>3&7)<<2)>>2]&255;n=0;N=o;return n|0}else{switch(b<<16>>16){case 16896:break;default:break v}if(a[3440]|0){m=c[160]|0;c[o+968>>2]=n&7;c[o+968+4>>2]=n>>>3&7;va(m,2644,o+968|0)|0;}m=c[2784+((n>>>3&7)<<2)>>2]&c[2784+((n&7)<<2)>>2];n=c[718]|0;n=(m|0)<0?n|-2147483648:n&2147483647;c[718]=(m|0)==0?n|1073741824:n&-1073741825;n=0;N=o;return n|0}}else switch(b<<16>>16){case -19904:{if(a[3440]|0){m=c[160]|0;c[o+952>>2]=n&7;c[o+952+4>>2]=n>>>3&7;va(m,2616,o+952|0)|0;}m=c[2784+((n>>>3&7)<<2)>>2]|0;c[2784+((n&7)<<2)>>2]=(m&128|0)==0?m&255:m|-256;n=0;N=o;return n|0}case -19968:{if(a[3440]|0){m=c[160]|0;c[o+960>>2]=n&7;c[o+960+4>>2]=n>>>3&7;va(m,2630,o+960|0)|0;}m=c[2784+((n>>>3&7)<<2)>>2]|0;c[2784+((n&7)<<2)>>2]=(m&32768|0)==0?m&65535:m|-65536;n=0;N=o;return n|0}default:break v}while(0);m=c[160]|0;c[o+992>>2]=g;c[o+992+4>>2]=n;va(m,2685,o+992|0)|0;n=1;N=o;return n|0}}}}}}}}}}}return 0}function ga(a){a=a|0;var b=0;b=N;N=N+16|0;c[b>>2]=la(c[a+60>>2]|0)|0;a=ja(y(6,b|0)|0)|0;N=b;return a|0}function ha(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0;h=N;N=N+32|0;g=c[a+28>>2]|0;c[h>>2]=g;g=(c[a+20>>2]|0)-g|0;c[h+4>>2]=g;c[h+8>>2]=b;c[h+12>>2]=d;f=2;b=g+d|0;g=h;while(1){if(!((z(c[a+60>>2]|0,g|0,f|0,h+16|0)|0)<<16>>16))e=c[h+16>>2]|0;else{c[h+16>>2]=-1;e=-1;}if((b|0)==(e|0)){b=6;break}if((e|0)<0){b=8;break}k=c[g+4>>2]|0;j=e>>>0>k>>>0;i=j?g+8|0:g;k=e-(j?k:0)|0;c[i>>2]=(c[i>>2]|0)+k;c[i+4>>2]=(c[i+4>>2]|0)-k;f=f+(j<<31>>31)|0;b=b-e|0;g=i;}if((b|0)==6){k=c[a+44>>2]|0;c[a+16>>2]=k+(c[a+48>>2]|0);c[a+28>>2]=k;c[a+20>>2]=k;}else if((b|0)==8){c[a+16>>2]=0;c[a+28>>2]=0;c[a+20>>2]=0;c[a>>2]=c[a>>2]|32;if((f|0)==2)d=0;else d=d-(c[g+4>>2]|0)|0;}N=h;return d|0}function ia(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;f=N;N=N+32|0;c[f+8>>2]=c[a+60>>2];c[f+8+4>>2]=d;c[f+8+8>>2]=b;c[f+8+12>>2]=f;c[f+8+16>>2]=e;if((ja(x(140,f+8|0)|0)|0)<0){c[f>>2]=-1;c[f+4>>2]=-1;a=-1;b=-1;}else{a=c[f+4>>2]|0;b=c[f>>2]|0;}u(a|0);N=f;return b|0}function ja(a){a=a|0;if(a>>>0>4294963200){c[(ka()|0)>>2]=0-a;a=-1;}return a|0}function ka(){return 2940}function la(a){a=a|0;return a|0}function ma(a){a=a|0;return (a+-48|0)>>>0<10|0}function na(){return 644}function oa(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;f=r(d,b)|0;d=(b|0)==0?0:d;if((c[e+76>>2]|0)>-1){g=(qa(e)|0)==0;a=ta(a,f,e)|0;if(!g)pa(e);}else a=ta(a,f,e)|0;if((a|0)!=(f|0))d=(a>>>0)/(b>>>0)|0;return d|0}function pa(a){a=a|0;return}function qa(a){a=a|0;return 1}function ra(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,i=0;i=N;N=N+16|0;a[i>>0]=e;f=c[b+16>>2]|0;if(!f)if(!(sa(b)|0)){g=c[b+16>>2]|0;h=4;}else f=-1;else{g=f;h=4;}do if((h|0)==4){f=c[b+20>>2]|0;if(f>>>0<g>>>0?(e&255|0)!=(a[b+75>>0]|0):0){c[b+20>>2]=f+1;a[f>>0]=e;f=e&255;break}if((S[c[b+36>>2]&1](b,i,1)|0)==1)f=d[i>>0]|0;else f=-1;}while(0);N=i;return f|0}function sa(b){b=b|0;var d=0;d=a[b+74>>0]|0;a[b+74>>0]=d+255|d;d=c[b>>2]|0;if(!(d&8)){c[b+8>>2]=0;c[b+4>>2]=0;d=c[b+44>>2]|0;c[b+28>>2]=d;c[b+20>>2]=d;c[b+16>>2]=d+(c[b+48>>2]|0);b=0;}else{c[b>>2]=d|32;b=-1;}return b|0}function ta(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;f=c[e+16>>2]|0;if(!f)if(!(sa(e)|0)){g=c[e+16>>2]|0;h=5;}else f=0;else{g=f;h=5;}a:do if((h|0)==5){f=c[e+20>>2]|0;if((g-f|0)>>>0<d>>>0){f=S[c[e+36>>2]&1](e,b,d)|0;break}b:do if((a[e+75>>0]|0)<0|(d|0)==0){i=0;g=b;}else{h=d;while(1){g=h+-1|0;if((a[b+g>>0]|0)==10)break;if(!g){i=0;g=b;break b}else h=g;}f=S[c[e+36>>2]&1](e,b,h)|0;if(f>>>0<h>>>0)break a;i=h;g=b+h|0;d=d-h|0;f=c[e+20>>2]|0;}while(0);_a(f|0,g|0,d|0)|0;c[e+20>>2]=(c[e+20>>2]|0)+d;f=i+d|0;}while(0);return f|0}function ua(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;a:do if((e|0)!=0&(b&3|0)!=0){f=e;while(1){if((a[b>>0]|0)==(d&255)<<24>>24){g=6;break a}b=b+1|0;e=f+-1|0;if((e|0)!=0&(b&3|0)!=0)f=e;else{f=e;e=(e|0)!=0;g=5;break}}}else{f=e;e=(e|0)!=0;g=5;}while(0);if((g|0)==5)if(e)g=6;else g=16;b:do if((g|0)==6){if((a[b>>0]|0)==(d&255)<<24>>24)if(!f){g=16;break}else break;e=r(d&255,16843009)|0;c:do if(f>>>0>3)while(1){h=c[b>>2]^e;if((h&-2139062144^-2139062144)&h+-16843009|0)break c;b=b+4|0;f=f+-4|0;if(f>>>0<=3){g=11;break}}else g=11;while(0);if((g|0)==11)if(!f){g=16;break}while(1){if((a[b>>0]|0)==(d&255)<<24>>24)break b;f=f+-1|0;if(!f){g=16;break}else b=b+1|0;}}while(0);if((g|0)==16)b=0;return b|0}function va(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;e=N;N=N+16|0;c[e>>2]=d;d=wa(a,b,e)|0;N=e;return d|0}function wa(a,b,c){a=a|0;b=b|0;c=c|0;return za(a,b,c,1,1)|0}function xa(b,e,f,g,h,i){b=b|0;e=+e;f=f|0;g=g|0;h=h|0;i=i|0;var j=0,k=0,l=0,m=0,n=0.0,o=0,p=0,q=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0;B=N;N=N+560|0;c[B+536>>2]=0;A=B+540+12|0;La(e)|0;j=v()|0;if((j|0)<0){La(-e)|0;e=-e;z=1;x=2737;j=v()|0;}else{z=(h&2049|0)!=0&1;x=(h&2048|0)==0?((h&1|0)==0?2738:2743):2740;}do if(0==0&(j&2146435072|0)==2146435072){j=z+3|0;Ha(b,32,f,j,h&-65537);Ba(b,x,z);Ba(b,e!=e|0.0!=0.0?(i&32|0?2764:2768):i&32|0?2756:2760,3);Ha(b,32,f,j,h^8192);}else{n=+Ma(e,B+536|0)*2.0;if(n!=0.0)c[B+536>>2]=(c[B+536>>2]|0)+-1;if((i|32|0)==97){p=(i&32|0)==0?x:x+9|0;o=z|2;do if(!(g>>>0>11|(12-g|0)==0)){e=8.0;j=12-g|0;do{j=j+-1|0;e=e*16.0;}while((j|0)!=0);if((a[p>>0]|0)==45){e=-(e+(-n-e));break}else{e=n+e-e;break}}else e=n;while(0);k=c[B+536>>2]|0;j=(k|0)<0?0-k|0:k;j=Ga(j,((j|0)<0)<<31>>31,A)|0;if((j|0)==(A|0)){a[B+540+11>>0]=48;j=B+540+11|0;}a[j+-1>>0]=(k>>31&2)+43;m=j+-2|0;a[m>>0]=i+15;j=B;do{z=~~e;k=j+1|0;a[j>>0]=i&32|d[480+z>>0];e=(e-+(z|0))*16.0;if((k-B|0)==1?!((h&8|0)==0&((g|0)<1&e==0.0)):0){a[k>>0]=46;j=j+2|0;}else j=k;}while(e!=0.0);l=j;if((g|0)!=0?(-2-B+l|0)<(g|0):0){g=g+2+A-m|0;j=A;k=m;}else{g=A-B-m+l|0;j=A;k=m;}A=g+o|0;Ha(b,32,f,A,h);Ba(b,p,o);Ha(b,48,f,A,h^65536);Ba(b,B,l-B|0);j=j-k|0;Ha(b,48,g-(l-B+j)|0,0,0);Ba(b,m,j);Ha(b,32,f,A,h^8192);j=A;break}k=(g|0)<0?6:g;if(n!=0.0){j=(c[B+536>>2]|0)+-28|0;c[B+536>>2]=j;e=n*268435456.0;}else{e=n;j=c[B+536>>2]|0;}y=(j|0)<0?B+32|0:B+32+288|0;g=y;do{u=~~e>>>0;c[g>>2]=u;g=g+4|0;e=(e-+(u>>>0))*1.0e9;}while(e!=0.0);if((j|0)>0){o=y;while(1){m=(j|0)<29?j:29;j=g+-4|0;if(j>>>0>=o>>>0){l=0;do{s=Ya(c[j>>2]|0,0,m|0)|0;s=Sa(s|0,v()|0,l|0,0)|0;t=v()|0;l=Wa(s|0,t|0,1e9,0)|0;u=Ra(l|0,v()|0,1e9,0)|0;u=Ta(s|0,t|0,u|0,v()|0)|0;v()|0;c[j>>2]=u;j=j+-4|0;}while(j>>>0>=o>>>0);if(l){u=o+-4|0;c[u>>2]=l;l=u;}else l=o;}else l=o;a:do if(g>>>0>l>>>0){j=g;while(1){g=j+-4|0;if(c[g>>2]|0){g=j;break a}if(g>>>0>l>>>0)j=g;else break}}while(0);j=(c[B+536>>2]|0)-m|0;c[B+536>>2]=j;if((j|0)>0)o=l;else break}}else l=y;if((j|0)<0){do{o=0-j|0;o=(o|0)<9?o:9;if(l>>>0<g>>>0){m=0;j=l;do{u=c[j>>2]|0;c[j>>2]=(u>>>o)+m;m=r(u&(1<<o)+-1,1e9>>>o)|0;j=j+4|0;}while(j>>>0<g>>>0);j=(c[l>>2]|0)==0?l+4|0:l;if(!m)l=j;else{c[g>>2]=m;g=g+4|0;l=j;}}else l=(c[l>>2]|0)==0?l+4|0:l;j=(i|32|0)==102?y:l;g=(g-j>>2|0)>(((k+25|0)/9|0)+1|0)?j+(((k+25|0)/9|0)+1<<2)|0:g;j=(c[B+536>>2]|0)+o|0;c[B+536>>2]=j;}while((j|0)<0);j=l;}else j=l;if(j>>>0<g>>>0){l=(y-j>>2)*9|0;o=c[j>>2]|0;if(o>>>0>=10){m=10;do{m=m*10|0;l=l+1|0;}while(o>>>0>=m>>>0)}}else l=0;m=k-((i|32|0)==102?0:l)+(((k|0)!=0&(i|32|0)==103)<<31>>31)|0;if((m|0)<(((g-y>>2)*9|0)+-9|0)){p=y+4+(((m+9216|0)/9|0)+-1024<<2)|0;m=m+9216-(((m+9216|0)/9|0)*9|0)|0;if((m|0)<8){o=10;while(1){o=o*10|0;if((m|0)<7)m=m+1|0;else break}}else o=10;s=c[p>>2]|0;m=(s>>>0)/(o>>>0)|0;t=s-(r(m,o)|0)|0;q=(p+4|0)==(g|0);if(!(q&(t|0)==0)){e=(m&1|0)==0?9007199254740992.0:9007199254740994.0;u=o>>>1;n=t>>>0<u>>>0?.5:q&(t|0)==(u|0)?1.0:1.5;if(z){u=(a[x>>0]|0)==45;n=u?-n:n;e=u?-e:e;}c[p>>2]=s-t;if(e+n!=e){u=s-t+o|0;c[p>>2]=u;if(u>>>0>999999999){m=p;while(1){l=m+-4|0;c[m>>2]=0;if(l>>>0<j>>>0){j=j+-4|0;c[j>>2]=0;}u=(c[l>>2]|0)+1|0;c[l>>2]=u;if(u>>>0>999999999)m=l;else{p=l;break}}}l=(y-j>>2)*9|0;o=c[j>>2]|0;if(o>>>0<10)m=p;else{m=10;do{m=m*10|0;l=l+1|0;}while(o>>>0>=m>>>0);m=p;}}else m=p;}else m=p;t=m+4|0;g=g>>>0>t>>>0?t:g;t=j;}else t=j;p=0-l|0;b:do if(g>>>0>t>>>0)while(1){j=g+-4|0;if(c[j>>2]|0){u=g;s=1;break b}if(j>>>0>t>>>0)g=j;else{u=j;s=0;break}}else{u=g;s=0;}while(0);do if((i|32|0)==103){if((l|0)>-5?(k+(((k|0)!=0^1)&1)|0)>(l|0):0){m=i+-1|0;k=k+(((k|0)!=0^1)&1)+-1-l|0;}else{m=i+-2|0;k=k+(((k|0)!=0^1)&1)+-1|0;}if(!(h&8)){if(s?(w=c[u+-4>>2]|0,(w|0)!=0):0)if(!((w>>>0)%10|0)){j=0;g=10;do{g=g*10|0;j=j+1|0;}while(!((w>>>0)%(g>>>0)|0|0))}else j=0;else j=9;g=((u-y>>2)*9|0)+-9|0;if((m|32|0)==102){i=g-j|0;i=(i|0)>0?i:0;k=(k|0)<(i|0)?k:i;break}else{i=g+l-j|0;i=(i|0)>0?i:0;k=(k|0)<(i|0)?k:i;break}}}else m=i;while(0);q=(k|0)!=0;g=q?1:h>>>3&1;o=(m|32|0)==102;if(o){p=0;j=(l|0)>0?l:0;}else{j=(l|0)<0?p:l;j=Ga(j,((j|0)<0)<<31>>31,A)|0;if((A-j|0)<2)do{j=j+-1|0;a[j>>0]=48;}while((A-j|0)<2);a[j+-1>>0]=(l>>31&2)+43;j=j+-2|0;a[j>>0]=m;p=j;j=A-j|0;}j=z+1+k+g+j|0;Ha(b,32,f,j,h);Ba(b,x,z);Ha(b,48,f,j,h^65536);if(o){m=t>>>0>y>>>0?y:t;l=m;do{g=Ga(c[l>>2]|0,0,B+9|0)|0;if((l|0)==(m|0)){if((g|0)==(B+9|0)){a[B+8>>0]=48;g=B+8|0;}}else if(g>>>0>B>>>0){$a(B|0,48,g-B|0)|0;do g=g+-1|0;while(g>>>0>B>>>0)}Ba(b,g,B+9-g|0);l=l+4|0;}while(l>>>0<=y>>>0);if(!((h&8|0)==0&(q^1)))Ba(b,2772,1);if(l>>>0<u>>>0&(k|0)>0)while(1){g=Ga(c[l>>2]|0,0,B+9|0)|0;if(g>>>0>B>>>0){$a(B|0,48,g-B|0)|0;do g=g+-1|0;while(g>>>0>B>>>0)}Ba(b,g,(k|0)<9?k:9);l=l+4|0;g=k+-9|0;if(!(l>>>0<u>>>0&(k|0)>9)){k=g;break}else k=g;}Ha(b,48,k+9|0,9,0);}else{o=s?u:t+4|0;if(t>>>0<o>>>0&(k|0)>-1){m=t;do{g=Ga(c[m>>2]|0,0,B+9|0)|0;if((g|0)==(B+9|0)){a[B+8>>0]=48;g=B+8|0;}do if((m|0)==(t|0)){l=g+1|0;Ba(b,g,1);if((h&8|0)==0&(k|0)<1){g=l;break}Ba(b,2772,1);g=l;}else{if(g>>>0<=B>>>0)break;$a(B|0,48,g+(0-B)|0)|0;do g=g+-1|0;while(g>>>0>B>>>0)}while(0);z=B+9-g|0;Ba(b,g,(k|0)>(z|0)?z:k);k=k-z|0;m=m+4|0;}while(m>>>0<o>>>0&(k|0)>-1)}Ha(b,48,k+18|0,18,0);Ba(b,p,A-p|0);}Ha(b,32,f,j,h^8192);}while(0);N=B;return ((j|0)<(f|0)?f:j)|0}function ya(a,b){a=a|0;b=b|0;var d=0.0,e=0;e=(c[b>>2]|0)+(8-1)&~(8-1);d=+g[e>>3];c[b>>2]=e+8;g[a>>3]=d;return}function za(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0;k=N;N=N+224|0;h=k+160|0;i=h+40|0;do{c[h>>2]=0;h=h+4|0;}while((h|0)<(i|0));c[k+208>>2]=c[e>>2];if((Aa(0,d,k+208|0,k+80|0,k+160|0,f,g)|0)<0)e=-1;else{if((c[b+76>>2]|0)>-1)j=qa(b)|0;else j=0;i=c[b>>2]|0;if((a[b+74>>0]|0)<1)c[b>>2]=i&-33;if(!(c[b+48>>2]|0)){h=c[b+44>>2]|0;c[b+44>>2]=k;c[b+28>>2]=k;c[b+20>>2]=k;c[b+48>>2]=80;c[b+16>>2]=k+80;e=Aa(b,d,k+208|0,k+80|0,k+160|0,f,g)|0;if(h){S[c[b+36>>2]&1](b,0,0)|0;e=(c[b+20>>2]|0)==0?-1:e;c[b+44>>2]=h;c[b+48>>2]=0;c[b+16>>2]=0;c[b+28>>2]=0;c[b+20>>2]=0;}}else e=Aa(b,d,k+208|0,k+80|0,k+160|0,f,g)|0;h=c[b>>2]|0;c[b>>2]=h|i&32;if(j|0)pa(b);e=(h&32|0)==0?e:-1;}N=k;return e|0}function Aa(d,e,f,h,i,j,k){d=d|0;e=e|0;f=f|0;h=h|0;i=i|0;j=j|0;k=k|0;var l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0;A=N;N=N+64|0;c[A+56>>2]=e;x=A+40|0;l=0;e=0;n=0;a:while(1){do{do if((e|0)>-1)if((l|0)>(2147483647-e|0)){c[(ka()|0)>>2]=75;e=-1;break}else{e=l+e|0;break}while(0);r=c[A+56>>2]|0;l=a[r>>0]|0;if(!(l<<24>>24)){w=92;break a}m=r;b:while(1){switch(l<<24>>24){case 37:{w=10;break b}case 0:{l=m;break b}default:{}}u=m+1|0;c[A+56>>2]=u;l=a[u>>0]|0;m=u;}c:do if((w|0)==10){w=0;l=m;do{if((a[m+1>>0]|0)!=37)break c;l=l+1|0;m=m+2|0;c[A+56>>2]=m;}while((a[m>>0]|0)==37)}while(0);l=l-r|0;if(d|0)Ba(d,r,l);}while((l|0)!=0);u=(ma(a[(c[A+56>>2]|0)+1>>0]|0)|0)==0;m=c[A+56>>2]|0;if(!u?(a[m+2>>0]|0)==36:0){s=(a[m+1>>0]|0)+-48|0;p=1;l=3;}else{s=-1;p=n;l=1;}l=m+l|0;c[A+56>>2]=l;m=a[l>>0]|0;if(((m<<24>>24)+-32|0)>>>0>31|(1<<(m<<24>>24)+-32&75913|0)==0)o=0;else{n=0;o=(m<<24>>24)+-32|0;do{n=1<<o|n;l=l+1|0;c[A+56>>2]=l;m=a[l>>0]|0;o=(m<<24>>24)+-32|0;}while(!(o>>>0>31|(1<<o&75913|0)==0));o=n;}if(m<<24>>24==42){if((ma(a[l+1>>0]|0)|0)!=0?(z=c[A+56>>2]|0,(a[z+2>>0]|0)==36):0){c[i+((a[z+1>>0]|0)+-48<<2)>>2]=10;l=c[h+((a[z+1>>0]|0)+-48<<3)>>2]|0;n=1;m=z+3|0;}else{if(p|0){e=-1;break}if(d|0){u=(c[f>>2]|0)+(4-1)&~(4-1);l=c[u>>2]|0;c[f>>2]=u+4;}else l=0;n=0;m=(c[A+56>>2]|0)+1|0;}c[A+56>>2]=m;q=(l|0)<0;t=q?0-l|0:l;q=q?o|8192:o;u=n;}else{l=Ca(A+56|0)|0;if((l|0)<0){e=-1;break}t=l;q=o;u=p;m=c[A+56>>2]|0;}do if((a[m>>0]|0)==46){l=m+1|0;if((a[l>>0]|0)!=42){c[A+56>>2]=l;l=Ca(A+56|0)|0;m=c[A+56>>2]|0;break}if(ma(a[m+2>>0]|0)|0?(y=c[A+56>>2]|0,(a[y+3>>0]|0)==36):0){c[i+((a[y+2>>0]|0)+-48<<2)>>2]=10;l=c[h+((a[y+2>>0]|0)+-48<<3)>>2]|0;c[A+56>>2]=y+4;m=y+4|0;break}if(u|0){e=-1;break a}if(d|0){p=(c[f>>2]|0)+(4-1)&~(4-1);l=c[p>>2]|0;c[f>>2]=p+4;}else l=0;m=(c[A+56>>2]|0)+2|0;c[A+56>>2]=m;}else l=-1;while(0);p=0;while(1){if(((a[m>>0]|0)+-65|0)>>>0>57){e=-1;break a}n=m;m=m+1|0;c[A+56>>2]=m;n=a[(a[n>>0]|0)+-65+(16+(p*58|0))>>0]|0;if(((n&255)+-1|0)>>>0>=8)break;else p=n&255;}if(!(n<<24>>24)){e=-1;break}o=(s|0)>-1;do if(n<<24>>24==19)if(o){e=-1;break a}else w=54;else{if(o){c[i+(s<<2)>>2]=n&255;s=h+(s<<3)|0;w=c[s+4>>2]|0;c[A+40>>2]=c[s>>2];c[A+40+4>>2]=w;w=54;break}if(!d){e=0;break a}Da(A+40|0,n&255,f,k);m=c[A+56>>2]|0;w=55;}while(0);if((w|0)==54){w=0;if(d|0)w=55;else l=0;}d:do if((w|0)==55){w=0;m=a[m+-1>>0]|0;m=(p|0)!=0&(m&15|0)==3?m&-33:m;n=q&-65537;s=(q&8192|0)==0?q:n;e:do switch(m|0){case 110:switch((p&255)<<24>>24){case 0:{c[c[A+40>>2]>>2]=e;l=0;break d}case 1:{c[c[A+40>>2]>>2]=e;l=0;break d}case 2:{l=c[A+40>>2]|0;c[l>>2]=e;c[l+4>>2]=((e|0)<0)<<31>>31;l=0;break d}case 3:{b[c[A+40>>2]>>1]=e;l=0;break d}case 4:{a[c[A+40>>2]>>0]=e;l=0;break d}case 6:{c[c[A+40>>2]>>2]=e;l=0;break d}case 7:{l=c[A+40>>2]|0;c[l>>2]=e;c[l+4>>2]=((e|0)<0)<<31>>31;l=0;break d}default:{l=0;break d}}case 112:{m=120;l=l>>>0>8?l:8;n=s|8;w=67;break}case 88:case 120:{n=s;w=67;break}case 111:{n=Fa(c[A+40>>2]|0,c[A+40+4>>2]|0,A+40|0)|0;q=n;o=0;p=2720;l=(s&8|0)==0|(l|0)>(x-n|0)?l:x-n+1|0;n=s;w=73;break}case 105:case 100:{m=c[A+40>>2]|0;n=c[A+40+4>>2]|0;if((n|0)<0){m=Ta(0,0,m|0,n|0)|0;n=v()|0;c[A+40>>2]=m;c[A+40+4>>2]=n;o=1;p=2720;w=72;break e}else{o=(s&2049|0)!=0&1;p=(s&2048|0)==0?((s&1|0)==0?2720:2722):2721;w=72;break e}}case 117:{o=0;p=2720;m=c[A+40>>2]|0;n=c[A+40+4>>2]|0;w=72;break}case 99:{a[A+39>>0]=c[A+40>>2];r=A+39|0;o=0;p=2720;q=1;m=n;l=x;break}case 115:{B=c[A+40>>2]|0;B=(B|0)==0?2730:B;s=ua(B,0,l)|0;r=B;o=0;p=2720;q=(s|0)==0?l:s-B|0;m=n;l=(s|0)==0?B+l|0:s;break}case 67:{c[A+48>>2]=c[A+40>>2];c[A+48+4>>2]=0;c[A+40>>2]=A+48;o=-1;w=79;break}case 83:{if(!l){Ha(d,32,t,0,s);l=0;w=89;}else{o=l;w=79;}break}case 65:case 71:case 70:case 69:case 97:case 103:case 102:case 101:{l=R[j&1](d,+g[A+40>>3],t,l,s,m)|0;break d}default:{o=0;p=2720;q=l;m=s;l=x;}}while(0);f:do if((w|0)==67){q=Ea(c[A+40>>2]|0,c[A+40+4>>2]|0,A+40|0,m&32)|0;p=(n&8|0)==0|((c[A+40>>2]|0)==0?(c[A+40+4>>2]|0)==0:0);o=p?0:2;p=p?2720:2720+(m>>>4)|0;w=73;}else if((w|0)==72){q=Ga(m,n,A+40|0)|0;n=s;w=73;}else if((w|0)==79){w=0;n=c[A+40>>2]|0;l=0;while(1){m=c[n>>2]|0;if(!m)break;m=Ia(A+60|0,m)|0;if((m|0)<0|m>>>0>(o-l|0)>>>0){w=83;break}l=m+l|0;if(o>>>0>l>>>0)n=n+4|0;else break}if((w|0)==83){w=0;if((m|0)<0){e=-1;break a}}Ha(d,32,t,l,s);if(!l){l=0;w=89;}else{n=c[A+40>>2]|0;o=0;while(1){m=c[n>>2]|0;if(!m){w=89;break f}m=Ia(A+60|0,m)|0;o=m+o|0;if((o|0)>(l|0)){w=89;break f}Ba(d,A+60|0,m);if(o>>>0>=l>>>0){w=89;break}else n=n+4|0;}}}while(0);if((w|0)==73){w=0;m=c[A+40>>2]|0?1:(c[A+40+4>>2]|0)!=0;B=(l|0)!=0|m;m=x-q+((m^1)&1)|0;r=B?q:A+40|0;q=B?((l|0)>(m|0)?l:m):0;m=(l|0)>-1?n&-65537:n;l=x;}else if((w|0)==89){w=0;Ha(d,32,t,l,s^8192);l=(t|0)>(l|0)?t:l;break}s=l-r|0;q=(q|0)<(s|0)?s:q;B=q+o|0;l=(t|0)<(B|0)?B:t;Ha(d,32,l,B,m);Ba(d,p,o);Ha(d,48,l,B,m^65536);Ha(d,48,q,s,0);Ba(d,r,s);Ha(d,32,l,B,m^8192);}while(0);n=u;}g:do if((w|0)==92)if(!d)if(!n)e=0;else{e=1;while(1){l=c[i+(e<<2)>>2]|0;if(!l)break;Da(h+(e<<3)|0,l,f,k);e=e+1|0;if(e>>>0>=10){e=1;break g}}while(1){if(c[i+(e<<2)>>2]|0){e=-1;break g}e=e+1|0;if(e>>>0>=10){e=1;break}}}while(0);N=A;return e|0}function Ba(a,b,d){a=a|0;b=b|0;d=d|0;if(!(c[a>>2]&32))ta(b,d,a)|0;return}function Ca(b){b=b|0;var d=0,e=0;if(!(ma(a[c[b>>2]>>0]|0)|0))d=0;else{d=0;do{e=c[b>>2]|0;d=(d*10|0)+-48+(a[e>>0]|0)|0;c[b>>2]=e+1;}while((ma(a[e+1>>0]|0)|0)!=0)}return d|0}function Da(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0.0;a:do if(b>>>0<=20)do switch(b|0){case 9:{b=(c[d>>2]|0)+(4-1)&~(4-1);e=c[b>>2]|0;c[d>>2]=b+4;c[a>>2]=e;break a}case 10:{b=(c[d>>2]|0)+(4-1)&~(4-1);e=c[b>>2]|0;c[d>>2]=b+4;c[a>>2]=e;c[a+4>>2]=((e|0)<0)<<31>>31;break a}case 11:{b=(c[d>>2]|0)+(4-1)&~(4-1);e=c[b>>2]|0;c[d>>2]=b+4;c[a>>2]=e;c[a+4>>2]=0;break a}case 12:{f=(c[d>>2]|0)+(8-1)&~(8-1);b=c[f>>2]|0;e=c[f+4>>2]|0;c[d>>2]=f+8;c[a>>2]=b;c[a+4>>2]=e;break a}case 13:{e=(c[d>>2]|0)+(4-1)&~(4-1);f=c[e>>2]|0;c[d>>2]=e+4;c[a>>2]=(f&65535)<<16>>16;c[a+4>>2]=(((f&65535)<<16>>16|0)<0)<<31>>31;break a}case 14:{e=(c[d>>2]|0)+(4-1)&~(4-1);f=c[e>>2]|0;c[d>>2]=e+4;c[a>>2]=f&65535;c[a+4>>2]=0;break a}case 15:{e=(c[d>>2]|0)+(4-1)&~(4-1);f=c[e>>2]|0;c[d>>2]=e+4;c[a>>2]=(f&255)<<24>>24;c[a+4>>2]=(((f&255)<<24>>24|0)<0)<<31>>31;break a}case 16:{e=(c[d>>2]|0)+(4-1)&~(4-1);f=c[e>>2]|0;c[d>>2]=e+4;c[a>>2]=f&255;c[a+4>>2]=0;break a}case 17:{f=(c[d>>2]|0)+(8-1)&~(8-1);h=+g[f>>3];c[d>>2]=f+8;g[a>>3]=h;break a}case 18:{U[e&1](a,d);break a}default:break a}while(0);while(0);return}function Ea(b,c,e,f){b=b|0;c=c|0;e=e|0;f=f|0;if(!((b|0)==0&(c|0)==0))do{e=e+-1|0;a[e>>0]=d[480+(b&15)>>0]|0|f;b=Xa(b|0,c|0,4)|0;c=v()|0;}while(!((b|0)==0&(c|0)==0));return e|0}function Fa(b,c,d){b=b|0;c=c|0;d=d|0;if(!((b|0)==0&(c|0)==0))do{d=d+-1|0;a[d>>0]=b&7|48;b=Xa(b|0,c|0,3)|0;c=v()|0;}while(!((b|0)==0&(c|0)==0));return d|0}function Ga(b,c,d){b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0;if(c>>>0>0|(c|0)==0&b>>>0>4294967295){do{e=b;b=Wa(b|0,c|0,10,0)|0;f=c;c=v()|0;g=Ra(b|0,c|0,10,0)|0;g=Ta(e|0,f|0,g|0,v()|0)|0;v()|0;d=d+-1|0;a[d>>0]=g&255|48;}while(f>>>0>9|(f|0)==9&e>>>0>4294967295);c=b;}else c=b;if(c)do{g=c;c=(c>>>0)/10|0;d=d+-1|0;a[d>>0]=g-(c*10|0)|48;}while(g>>>0>=10);return d|0}function Ha(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0;f=N;N=N+256|0;if((c|0)>(d|0)&(e&73728|0)==0){$a(f|0,b<<24>>24|0,((c-d|0)>>>0<256?c-d|0:256)|0)|0;if((c-d|0)>>>0>255){b=c-d|0;do{Ba(a,f,256);b=b+-256|0;}while(b>>>0>255);b=c-d&255;}else b=c-d|0;Ba(a,f,b);}N=f;return}function Ia(a,b){a=a|0;b=b|0;if(!a)a=0;else a=Ja(a,b,0)|0;return a|0}function Ja(b,d,e){b=b|0;d=d|0;e=e|0;do if(b){if(d>>>0<128){a[b>>0]=d;b=1;break}if(!(c[c[(Ka()|0)+188>>2]>>2]|0))if((d&-128|0)==57216){a[b>>0]=d;b=1;break}else{c[(ka()|0)>>2]=84;b=-1;break}if(d>>>0<2048){a[b>>0]=d>>>6|192;a[b+1>>0]=d&63|128;b=2;break}if(d>>>0<55296|(d&-8192|0)==57344){a[b>>0]=d>>>12|224;a[b+1>>0]=d>>>6&63|128;a[b+2>>0]=d&63|128;b=3;break}if((d+-65536|0)>>>0<1048576){a[b>>0]=d>>>18|240;a[b+1>>0]=d>>>12&63|128;a[b+2>>0]=d>>>6&63|128;a[b+3>>0]=d&63|128;b=4;break}else{c[(ka()|0)>>2]=84;b=-1;break}}else b=1;while(0);return b|0}function Ka(){return na()|0}function La(a){a=+a;var b=0;g[h>>3]=a;b=c[h>>2]|0;u(c[h+4>>2]|0);return b|0}function Ma(a,b){a=+a;b=b|0;var d=0,e=0,f=0;g[h>>3]=a;d=c[h>>2]|0;e=c[h+4>>2]|0;f=Xa(d|0,e|0,52)|0;v()|0;switch(f&2047){case 0:{if(a!=0.0){a=+Ma(a*18446744073709551616.0,b);d=(c[b>>2]|0)+-64|0;}else d=0;c[b>>2]=d;break}case 2047:break;default:{c[b>>2]=(f&2047)+-1022;c[h>>2]=d;c[h+4>>2]=e&-2146435073|1071644672;a=+g[h>>3];}}return +a}function Na(b,d){b=b|0;d=d|0;var e=0,f=0,g=0;if((c[d+76>>2]|0)>=0?(qa(d)|0)!=0:0){if((b&255|0)!=(a[d+75>>0]|0)?(f=c[d+20>>2]|0,f>>>0<(c[d+16>>2]|0)>>>0):0){c[d+20>>2]=f+1;a[f>>0]=b;b=b&255;}else b=ra(d,b)|0;pa(d);}else g=3;do if((g|0)==3){if((b&255|0)!=(a[d+75>>0]|0)?(e=c[d+20>>2]|0,e>>>0<(c[d+16>>2]|0)>>>0):0){c[d+20>>2]=e+1;a[e>>0]=b;b=b&255;break}b=ra(d,b)|0;}while(0);return b|0}function Oa(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;v=N;N=N+16|0;do if(a>>>0<245){m=a>>>0<11?16:a+11&-8;k=c[736]|0;if(k>>>(m>>>3)&3|0){a=2984+((k>>>(m>>>3)&1^1)+(m>>>3)<<1<<2)|0;b=c[a+8>>2]|0;d=c[b+8>>2]|0;if((d|0)==(a|0))c[736]=k&~(1<<(k>>>(m>>>3)&1^1)+(m>>>3));else{c[d+12>>2]=a;c[a+8>>2]=d;}u=(k>>>(m>>>3)&1^1)+(m>>>3)<<3;c[b+4>>2]=u|3;c[b+u+4>>2]=c[b+u+4>>2]|1;u=b+8|0;N=v;return u|0}l=c[738]|0;if(m>>>0>l>>>0){if(k>>>(m>>>3)|0){a=k>>>(m>>>3)<<(m>>>3)&(2<<(m>>>3)|0-(2<<(m>>>3)));f=((a&0-a)+-1|0)>>>(((a&0-a)+-1|0)>>>12&16);e=f>>>(f>>>5&8)>>>(f>>>(f>>>5&8)>>>2&4);e=(f>>>5&8|((a&0-a)+-1|0)>>>12&16|f>>>(f>>>5&8)>>>2&4|e>>>1&2|e>>>(e>>>1&2)>>>1&1)+(e>>>(e>>>1&2)>>>(e>>>(e>>>1&2)>>>1&1))|0;f=c[2984+(e<<1<<2)+8>>2]|0;a=c[f+8>>2]|0;if((a|0)==(2984+(e<<1<<2)|0)){c[736]=k&~(1<<e);a=k&~(1<<e);}else{c[a+12>>2]=2984+(e<<1<<2);c[2984+(e<<1<<2)+8>>2]=a;a=k;}c[f+4>>2]=m|3;c[f+m+4>>2]=(e<<3)-m|1;c[f+(e<<3)>>2]=(e<<3)-m;if(l|0){d=c[741]|0;if(!(a&1<<(l>>>3))){c[736]=a|1<<(l>>>3);a=2984+(l>>>3<<1<<2)|0;b=2984+(l>>>3<<1<<2)+8|0;}else{a=c[2984+(l>>>3<<1<<2)+8>>2]|0;b=2984+(l>>>3<<1<<2)+8|0;}c[b>>2]=d;c[a+12>>2]=d;c[d+8>>2]=a;c[d+12>>2]=2984+(l>>>3<<1<<2);}c[738]=(e<<3)-m;c[741]=f+m;u=f+8|0;N=v;return u|0}g=c[737]|0;if(g){b=((g&0-g)+-1|0)>>>(((g&0-g)+-1|0)>>>12&16);j=b>>>(b>>>5&8)>>>(b>>>(b>>>5&8)>>>2&4);j=c[3248+((b>>>5&8|((g&0-g)+-1|0)>>>12&16|b>>>(b>>>5&8)>>>2&4|j>>>1&2|j>>>(j>>>1&2)>>>1&1)+(j>>>(j>>>1&2)>>>(j>>>(j>>>1&2)>>>1&1))<<2)>>2]|0;b=j;i=j;j=(c[j+4>>2]&-8)-m|0;while(1){a=c[b+16>>2]|0;if(!a){a=c[b+20>>2]|0;if(!a)break}h=(c[a+4>>2]&-8)-m|0;f=h>>>0<j>>>0;b=a;i=f?a:i;j=f?h:j;}h=i+m|0;if(h>>>0>i>>>0){f=c[i+24>>2]|0;a=c[i+12>>2]|0;do if((a|0)==(i|0)){b=i+20|0;a=c[b>>2]|0;if(!a){b=i+16|0;a=c[b>>2]|0;if(!a){b=0;break}}while(1){e=a+20|0;d=c[e>>2]|0;if(!d){e=a+16|0;d=c[e>>2]|0;if(!d)break;else{a=d;b=e;}}else{a=d;b=e;}}c[b>>2]=0;b=a;}else{b=c[i+8>>2]|0;c[b+12>>2]=a;c[a+8>>2]=b;b=a;}while(0);do if(f|0){a=c[i+28>>2]|0;if((i|0)==(c[3248+(a<<2)>>2]|0)){c[3248+(a<<2)>>2]=b;if(!b){c[737]=g&~(1<<a);break}}else{c[((c[f+16>>2]|0)==(i|0)?f+16|0:f+20|0)>>2]=b;if(!b)break}c[b+24>>2]=f;a=c[i+16>>2]|0;if(a|0){c[b+16>>2]=a;c[a+24>>2]=b;}a=c[i+20>>2]|0;if(a|0){c[b+20>>2]=a;c[a+24>>2]=b;}}while(0);if(j>>>0<16){u=j+m|0;c[i+4>>2]=u|3;u=i+u+4|0;c[u>>2]=c[u>>2]|1;}else{c[i+4>>2]=m|3;c[h+4>>2]=j|1;c[h+j>>2]=j;if(l|0){d=c[741]|0;if(!(1<<(l>>>3)&k)){c[736]=1<<(l>>>3)|k;a=2984+(l>>>3<<1<<2)|0;b=2984+(l>>>3<<1<<2)+8|0;}else{a=c[2984+(l>>>3<<1<<2)+8>>2]|0;b=2984+(l>>>3<<1<<2)+8|0;}c[b>>2]=d;c[a+12>>2]=d;c[d+8>>2]=a;c[d+12>>2]=2984+(l>>>3<<1<<2);}c[738]=j;c[741]=h;}u=i+8|0;N=v;return u|0}}}}else if(a>>>0<=4294967231){m=a+11&-8;e=c[737]|0;if(e){if((a+11|0)>>>8)if(m>>>0>16777215)i=31;else{i=(a+11|0)>>>8<<((((a+11|0)>>>8)+1048320|0)>>>16&8);i=14-((i+520192|0)>>>16&4|(((a+11|0)>>>8)+1048320|0)>>>16&8|((i<<((i+520192|0)>>>16&4))+245760|0)>>>16&2)+(i<<((i+520192|0)>>>16&4)<<(((i<<((i+520192|0)>>>16&4))+245760|0)>>>16&2)>>>15)|0;i=m>>>(i+7|0)&1|i<<1;}else i=0;a=c[3248+(i<<2)>>2]|0;a:do if(!a){d=0;a=0;b=0-m|0;p=61;}else{g=0;b=0-m|0;h=m<<((i|0)==31?0:25-(i>>>1)|0);d=0;while(1){f=(c[a+4>>2]&-8)-m|0;if(f>>>0<b>>>0)if(!f){f=a;b=0;d=a;p=65;break a}else{g=a;b=f;}p=c[a+20>>2]|0;a=c[a+16+(h>>>31<<2)>>2]|0;d=(p|0)==0|(p|0)==(a|0)?d:p;if(!a){a=g;p=61;break}else h=h<<1;}}while(0);if((p|0)==61){if((d|0)==0&(a|0)==0){a=2<<i;if(!((a|0-a)&e))break;k=((a|0-a)&e&0-((a|0-a)&e))+-1|0;l=k>>>(k>>>12&16)>>>(k>>>(k>>>12&16)>>>5&8);d=l>>>(l>>>2&4)>>>(l>>>(l>>>2&4)>>>1&2);a=0;d=c[3248+((k>>>(k>>>12&16)>>>5&8|k>>>12&16|l>>>2&4|l>>>(l>>>2&4)>>>1&2|d>>>1&1)+(d>>>(d>>>1&1))<<2)>>2]|0;}if(!d){i=a;h=b;}else{f=a;p=65;}}if((p|0)==65)while(1){l=(c[d+4>>2]&-8)-m|0;a=l>>>0<b>>>0;b=a?l:b;f=a?d:f;a=c[d+16>>2]|0;if(!a)a=c[d+20>>2]|0;if(!a){i=f;h=b;break}else d=a;}if(((i|0)!=0?h>>>0<((c[738]|0)-m|0)>>>0:0)?(j=i+m|0,j>>>0>i>>>0):0){g=c[i+24>>2]|0;a=c[i+12>>2]|0;do if((a|0)==(i|0)){b=i+20|0;a=c[b>>2]|0;if(!a){b=i+16|0;a=c[b>>2]|0;if(!a){a=0;break}}while(1){f=a+20|0;d=c[f>>2]|0;if(!d){f=a+16|0;d=c[f>>2]|0;if(!d)break;else{a=d;b=f;}}else{a=d;b=f;}}c[b>>2]=0;}else{u=c[i+8>>2]|0;c[u+12>>2]=a;c[a+8>>2]=u;}while(0);do if(g){b=c[i+28>>2]|0;if((i|0)==(c[3248+(b<<2)>>2]|0)){c[3248+(b<<2)>>2]=a;if(!a){c[737]=e&~(1<<b);e=e&~(1<<b);break}}else{c[((c[g+16>>2]|0)==(i|0)?g+16|0:g+20|0)>>2]=a;if(!a)break}c[a+24>>2]=g;b=c[i+16>>2]|0;if(b|0){c[a+16>>2]=b;c[b+24>>2]=a;}b=c[i+20>>2]|0;if(b){c[a+20>>2]=b;c[b+24>>2]=a;}}while(0);b:do if(h>>>0<16){u=h+m|0;c[i+4>>2]=u|3;u=i+u+4|0;c[u>>2]=c[u>>2]|1;}else{c[i+4>>2]=m|3;c[j+4>>2]=h|1;c[j+h>>2]=h;d=h>>>3;if(h>>>0<256){a=c[736]|0;if(!(a&1<<d)){c[736]=a|1<<d;a=2984+(d<<1<<2)|0;b=2984+(d<<1<<2)+8|0;}else{a=c[2984+(d<<1<<2)+8>>2]|0;b=2984+(d<<1<<2)+8|0;}c[b>>2]=j;c[a+12>>2]=j;c[j+8>>2]=a;c[j+12>>2]=2984+(d<<1<<2);break}a=h>>>8;if(a)if(h>>>0>16777215)d=31;else{d=a<<((a+1048320|0)>>>16&8)<<(((a<<((a+1048320|0)>>>16&8))+520192|0)>>>16&4);d=14-(((a<<((a+1048320|0)>>>16&8))+520192|0)>>>16&4|(a+1048320|0)>>>16&8|(d+245760|0)>>>16&2)+(d<<((d+245760|0)>>>16&2)>>>15)|0;d=h>>>(d+7|0)&1|d<<1;}else d=0;a=3248+(d<<2)|0;c[j+28>>2]=d;c[j+16+4>>2]=0;c[j+16>>2]=0;b=1<<d;if(!(e&b)){c[737]=e|b;c[a>>2]=j;c[j+24>>2]=a;c[j+12>>2]=j;c[j+8>>2]=j;break}a=c[a>>2]|0;c:do if((c[a+4>>2]&-8|0)!=(h|0)){e=h<<((d|0)==31?0:25-(d>>>1)|0);while(1){d=a+16+(e>>>31<<2)|0;b=c[d>>2]|0;if(!b)break;if((c[b+4>>2]&-8|0)==(h|0)){a=b;break c}else{e=e<<1;a=b;}}c[d>>2]=j;c[j+24>>2]=a;c[j+12>>2]=j;c[j+8>>2]=j;break b}while(0);t=a+8|0;u=c[t>>2]|0;c[u+12>>2]=j;c[t>>2]=j;c[j+8>>2]=u;c[j+12>>2]=a;c[j+24>>2]=0;}while(0);u=i+8|0;N=v;return u|0}}}else m=-1;while(0);d=c[738]|0;if(d>>>0>=m>>>0){a=d-m|0;b=c[741]|0;if(a>>>0>15){u=b+m|0;c[741]=u;c[738]=a;c[u+4>>2]=a|1;c[b+d>>2]=a;c[b+4>>2]=m|3;}else{c[738]=0;c[741]=0;c[b+4>>2]=d|3;c[b+d+4>>2]=c[b+d+4>>2]|1;}u=b+8|0;N=v;return u|0}f=c[739]|0;if(f>>>0>m>>>0){s=f-m|0;c[739]=s;u=c[742]|0;t=u+m|0;c[742]=t;c[t+4>>2]=s|1;c[u+4>>2]=m|3;u=u+8|0;N=v;return u|0}if(!(c[854]|0)){c[856]=4096;c[855]=4096;c[857]=-1;c[858]=-1;c[859]=0;c[847]=0;c[854]=v&-16^1431655768;a=4096;}else a=c[856]|0;g=m+48|0;h=m+47|0;j=a+h|0;i=0-a|0;if((j&i)>>>0<=m>>>0){u=0;N=v;return u|0}a=c[846]|0;if(a|0?(l=c[844]|0,(l+(j&i)|0)>>>0<=l>>>0?1:(l+(j&i)|0)>>>0>a>>>0):0){u=0;N=v;return u|0}d:do if(!(c[847]&4)){d=c[742]|0;e:do if(d){b=3392;while(1){l=c[b>>2]|0;if(l>>>0<=d>>>0?(l+(c[b+4>>2]|0)|0)>>>0>d>>>0:0)break;a=c[b+8>>2]|0;if(!a){p=128;break e}else b=a;}if((j-f&i)>>>0<2147483647){a=ab(j-f&i|0)|0;if((a|0)==((c[b>>2]|0)+(c[b+4>>2]|0)|0))if((a|0)==(-1|0))a=j-f&i;else{h=j-f&i;f=a;p=145;break d}else{e=a;d=j-f&i;p=136;}}else a=0;}else p=128;while(0);do if((p|0)==128){b=ab(0)|0;if((b|0)!=(-1|0)?(o=c[855]|0,o=((o+-1&b|0)==0?0:(o+-1+b&0-o)-b|0)+(j&i)|0,n=c[844]|0,o>>>0>m>>>0&o>>>0<2147483647):0){l=c[846]|0;if(l|0?(o+n|0)>>>0<=n>>>0|(o+n|0)>>>0>l>>>0:0){a=0;break}a=ab(o|0)|0;if((a|0)==(b|0)){h=o;f=b;p=145;break d}else{e=a;d=o;p=136;}}else a=0;}while(0);do if((p|0)==136){b=0-d|0;if(!(g>>>0>d>>>0&(d>>>0<2147483647&(e|0)!=(-1|0))))if((e|0)==(-1|0)){a=0;break}else{h=d;f=e;p=145;break d}a=c[856]|0;a=h-d+a&0-a;if(a>>>0>=2147483647){h=d;f=e;p=145;break d}if((ab(a|0)|0)==(-1|0)){ab(b|0)|0;a=0;break}else{h=a+d|0;f=e;p=145;break d}}while(0);c[847]=c[847]|4;p=143;}else{a=0;p=143;}while(0);if(((p|0)==143?(j&i)>>>0<2147483647:0)?(s=ab(j&i|0)|0,q=ab(0)|0,r=(q-s|0)>>>0>(m+40|0)>>>0,!((s|0)==(-1|0)|r^1|s>>>0<q>>>0&((s|0)!=(-1|0)&(q|0)!=(-1|0))^1)):0){h=r?q-s|0:a;f=s;p=145;}if((p|0)==145){a=(c[844]|0)+h|0;c[844]=a;if(a>>>0>(c[845]|0)>>>0)c[845]=a;j=c[742]|0;f:do if(j){a=3392;while(1){b=c[a>>2]|0;d=c[a+4>>2]|0;if((f|0)==(b+d|0)){p=154;break}e=c[a+8>>2]|0;if(!e)break;else a=e;}if(((p|0)==154?(t=a+4|0,(c[a+12>>2]&8|0)==0):0)?f>>>0>j>>>0&b>>>0<=j>>>0:0){c[t>>2]=d+h;u=(c[739]|0)+h|0;t=(j+8&7|0)==0?0:0-(j+8)&7;c[742]=j+t;c[739]=u-t;c[j+t+4>>2]=u-t|1;c[j+u+4>>2]=40;c[743]=c[858];break}if(f>>>0<(c[740]|0)>>>0)c[740]=f;d=f+h|0;a=3392;while(1){if((c[a>>2]|0)==(d|0)){p=162;break}b=c[a+8>>2]|0;if(!b)break;else a=b;}if((p|0)==162?(c[a+12>>2]&8|0)==0:0){c[a>>2]=f;l=a+4|0;c[l>>2]=(c[l>>2]|0)+h;l=f+8|0;l=f+((l&7|0)==0?0:0-l&7)|0;a=d+((d+8&7|0)==0?0:0-(d+8)&7)|0;k=l+m|0;i=a-l-m|0;c[l+4>>2]=m|3;g:do if((j|0)==(a|0)){u=(c[739]|0)+i|0;c[739]=u;c[742]=k;c[k+4>>2]=u|1;}else{if((c[741]|0)==(a|0)){u=(c[738]|0)+i|0;c[738]=u;c[741]=k;c[k+4>>2]=u|1;c[k+u>>2]=u;break}h=c[a+4>>2]|0;if((h&3|0)==1){h:do if(h>>>0<256){b=c[a+8>>2]|0;d=c[a+12>>2]|0;if((d|0)==(b|0)){c[736]=c[736]&~(1<<(h>>>3));break}else{c[b+12>>2]=d;c[d+8>>2]=b;break}}else{g=c[a+24>>2]|0;b=c[a+12>>2]|0;do if((b|0)==(a|0)){b=c[a+16+4>>2]|0;if(!b){b=c[a+16>>2]|0;if(!b){b=0;break}else d=a+16|0;}else d=a+16+4|0;while(1){f=b+20|0;e=c[f>>2]|0;if(!e){f=b+16|0;e=c[f>>2]|0;if(!e)break;else{b=e;d=f;}}else{b=e;d=f;}}c[d>>2]=0;}else{u=c[a+8>>2]|0;c[u+12>>2]=b;c[b+8>>2]=u;}while(0);if(!g)break;d=c[a+28>>2]|0;do if((c[3248+(d<<2)>>2]|0)!=(a|0)){c[((c[g+16>>2]|0)==(a|0)?g+16|0:g+20|0)>>2]=b;if(!b)break h}else{c[3248+(d<<2)>>2]=b;if(b|0)break;c[737]=c[737]&~(1<<d);break h}while(0);c[b+24>>2]=g;d=c[a+16>>2]|0;if(d|0){c[b+16>>2]=d;c[d+24>>2]=b;}d=c[a+16+4>>2]|0;if(!d)break;c[b+20>>2]=d;c[d+24>>2]=b;}while(0);a=a+(h&-8)|0;f=(h&-8)+i|0;}else f=i;d=a+4|0;c[d>>2]=c[d>>2]&-2;c[k+4>>2]=f|1;c[k+f>>2]=f;d=f>>>3;if(f>>>0<256){a=c[736]|0;if(!(a&1<<d)){c[736]=a|1<<d;a=2984+(d<<1<<2)|0;b=2984+(d<<1<<2)+8|0;}else{a=c[2984+(d<<1<<2)+8>>2]|0;b=2984+(d<<1<<2)+8|0;}c[b>>2]=k;c[a+12>>2]=k;c[k+8>>2]=a;c[k+12>>2]=2984+(d<<1<<2);break}a=f>>>8;do if(!a)e=0;else{if(f>>>0>16777215){e=31;break}e=a<<((a+1048320|0)>>>16&8)<<(((a<<((a+1048320|0)>>>16&8))+520192|0)>>>16&4);e=14-(((a<<((a+1048320|0)>>>16&8))+520192|0)>>>16&4|(a+1048320|0)>>>16&8|(e+245760|0)>>>16&2)+(e<<((e+245760|0)>>>16&2)>>>15)|0;e=f>>>(e+7|0)&1|e<<1;}while(0);a=3248+(e<<2)|0;c[k+28>>2]=e;c[k+16+4>>2]=0;c[k+16>>2]=0;b=c[737]|0;d=1<<e;if(!(b&d)){c[737]=b|d;c[a>>2]=k;c[k+24>>2]=a;c[k+12>>2]=k;c[k+8>>2]=k;break}a=c[a>>2]|0;i:do if((c[a+4>>2]&-8|0)!=(f|0)){e=f<<((e|0)==31?0:25-(e>>>1)|0);while(1){d=a+16+(e>>>31<<2)|0;b=c[d>>2]|0;if(!b)break;if((c[b+4>>2]&-8|0)==(f|0)){a=b;break i}else{e=e<<1;a=b;}}c[d>>2]=k;c[k+24>>2]=a;c[k+12>>2]=k;c[k+8>>2]=k;break g}while(0);t=a+8|0;u=c[t>>2]|0;c[u+12>>2]=k;c[t>>2]=k;c[k+8>>2]=u;c[k+12>>2]=a;c[k+24>>2]=0;}while(0);u=l+8|0;N=v;return u|0}a=3392;while(1){b=c[a>>2]|0;if(b>>>0<=j>>>0?(u=b+(c[a+4>>2]|0)|0,u>>>0>j>>>0):0)break;a=c[a+8>>2]|0;}g=u+-47+((u+-47+8&7|0)==0?0:0-(u+-47+8)&7)|0;g=g>>>0<(j+16|0)>>>0?j:g;a=h+-40|0;s=f+8|0;s=(s&7|0)==0?0:0-s&7;t=f+s|0;c[742]=t;c[739]=a-s;c[t+4>>2]=a-s|1;c[f+a+4>>2]=40;c[743]=c[858];c[g+4>>2]=27;c[g+8>>2]=c[848];c[g+8+4>>2]=c[849];c[g+8+8>>2]=c[850];c[g+8+12>>2]=c[851];c[848]=f;c[849]=h;c[851]=0;c[850]=g+8;a=g+24|0;do{t=a;a=a+4|0;c[a>>2]=7;}while((t+8|0)>>>0<u>>>0);if((g|0)!=(j|0)){c[g+4>>2]=c[g+4>>2]&-2;c[j+4>>2]=g-j|1;c[g>>2]=g-j;if((g-j|0)>>>0<256){d=2984+((g-j|0)>>>3<<1<<2)|0;a=c[736]|0;if(!(a&1<<((g-j|0)>>>3))){c[736]=a|1<<((g-j|0)>>>3);a=d;b=d+8|0;}else{a=c[d+8>>2]|0;b=d+8|0;}c[b>>2]=j;c[a+12>>2]=j;c[j+8>>2]=a;c[j+12>>2]=d;break}if((g-j|0)>>>8)if((g-j|0)>>>0>16777215)e=31;else{e=(g-j|0)>>>8<<((((g-j|0)>>>8)+1048320|0)>>>16&8);e=14-((e+520192|0)>>>16&4|(((g-j|0)>>>8)+1048320|0)>>>16&8|((e<<((e+520192|0)>>>16&4))+245760|0)>>>16&2)+(e<<((e+520192|0)>>>16&4)<<(((e<<((e+520192|0)>>>16&4))+245760|0)>>>16&2)>>>15)|0;e=(g-j|0)>>>(e+7|0)&1|e<<1;}else e=0;a=3248+(e<<2)|0;c[j+28>>2]=e;c[j+20>>2]=0;c[j+16>>2]=0;b=c[737]|0;d=1<<e;if(!(b&d)){c[737]=b|d;c[a>>2]=j;c[j+24>>2]=a;c[j+12>>2]=j;c[j+8>>2]=j;break}a=c[a>>2]|0;j:do if((c[a+4>>2]&-8|0)!=(g-j|0)){e=g-j<<((e|0)==31?0:25-(e>>>1)|0);while(1){d=a+16+(e>>>31<<2)|0;b=c[d>>2]|0;if(!b)break;if((c[b+4>>2]&-8|0)==(g-j|0)){a=b;break j}else{e=e<<1;a=b;}}c[d>>2]=j;c[j+24>>2]=a;c[j+12>>2]=j;c[j+8>>2]=j;break f}while(0);t=a+8|0;u=c[t>>2]|0;c[u+12>>2]=j;c[t>>2]=j;c[j+8>>2]=u;c[j+12>>2]=a;c[j+24>>2]=0;}}else{u=c[740]|0;if((u|0)==0|f>>>0<u>>>0)c[740]=f;c[848]=f;c[849]=h;c[851]=0;c[745]=c[854];c[744]=-1;c[749]=2984;c[748]=2984;c[751]=2992;c[750]=2992;c[753]=3e3;c[752]=3e3;c[755]=3008;c[754]=3008;c[757]=3016;c[756]=3016;c[759]=3024;c[758]=3024;c[761]=3032;c[760]=3032;c[763]=3040;c[762]=3040;c[765]=3048;c[764]=3048;c[767]=3056;c[766]=3056;c[769]=3064;c[768]=3064;c[771]=3072;c[770]=3072;c[773]=3080;c[772]=3080;c[775]=3088;c[774]=3088;c[777]=3096;c[776]=3096;c[779]=3104;c[778]=3104;c[781]=3112;c[780]=3112;c[783]=3120;c[782]=3120;c[785]=3128;c[784]=3128;c[787]=3136;c[786]=3136;c[789]=3144;c[788]=3144;c[791]=3152;c[790]=3152;c[793]=3160;c[792]=3160;c[795]=3168;c[794]=3168;c[797]=3176;c[796]=3176;c[799]=3184;c[798]=3184;c[801]=3192;c[800]=3192;c[803]=3200;c[802]=3200;c[805]=3208;c[804]=3208;c[807]=3216;c[806]=3216;c[809]=3224;c[808]=3224;c[811]=3232;c[810]=3232;u=h+-40|0;s=f+8|0;s=(s&7|0)==0?0:0-s&7;t=f+s|0;c[742]=t;c[739]=u-s;c[t+4>>2]=u-s|1;c[f+u+4>>2]=40;c[743]=c[858];}while(0);a=c[739]|0;if(a>>>0>m>>>0){s=a-m|0;c[739]=s;u=c[742]|0;t=u+m|0;c[742]=t;c[t+4>>2]=s|1;c[u+4>>2]=m|3;u=u+8|0;N=v;return u|0}}c[(ka()|0)>>2]=12;u=0;N=v;return u|0}function Pa(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;if(!a)return;b=c[740]|0;d=c[a+-4>>2]|0;j=a+-8+(d&-8)|0;do if(!(d&1)){e=c[a+-8>>2]|0;if(!(d&3))return;h=a+-8+(0-e)|0;g=e+(d&-8)|0;if(h>>>0<b>>>0)return;if((c[741]|0)==(h|0)){b=c[j+4>>2]|0;if((b&3|0)!=3){i=h;b=g;break}c[738]=g;c[j+4>>2]=b&-2;c[h+4>>2]=g|1;c[h+g>>2]=g;return}if(e>>>0<256){b=c[h+8>>2]|0;a=c[h+12>>2]|0;if((a|0)==(b|0)){c[736]=c[736]&~(1<<(e>>>3));i=h;b=g;break}else{c[b+12>>2]=a;c[a+8>>2]=b;i=h;b=g;break}}f=c[h+24>>2]|0;b=c[h+12>>2]|0;do if((b|0)==(h|0)){b=c[h+16+4>>2]|0;if(!b){b=c[h+16>>2]|0;if(!b){b=0;break}else a=h+16|0;}else a=h+16+4|0;while(1){e=b+20|0;d=c[e>>2]|0;if(!d){e=b+16|0;d=c[e>>2]|0;if(!d)break;else{b=d;a=e;}}else{b=d;a=e;}}c[a>>2]=0;}else{i=c[h+8>>2]|0;c[i+12>>2]=b;c[b+8>>2]=i;}while(0);if(f){a=c[h+28>>2]|0;if((c[3248+(a<<2)>>2]|0)==(h|0)){c[3248+(a<<2)>>2]=b;if(!b){c[737]=c[737]&~(1<<a);i=h;b=g;break}}else{c[((c[f+16>>2]|0)==(h|0)?f+16|0:f+20|0)>>2]=b;if(!b){i=h;b=g;break}}c[b+24>>2]=f;a=c[h+16>>2]|0;if(a|0){c[b+16>>2]=a;c[a+24>>2]=b;}a=c[h+16+4>>2]|0;if(a){c[b+20>>2]=a;c[a+24>>2]=b;i=h;b=g;}else{i=h;b=g;}}else{i=h;b=g;}}else{i=a+-8|0;b=d&-8;h=a+-8|0;}while(0);if(h>>>0>=j>>>0)return;d=c[j+4>>2]|0;if(!(d&1))return;if(!(d&2)){if((c[742]|0)==(j|0)){j=(c[739]|0)+b|0;c[739]=j;c[742]=i;c[i+4>>2]=j|1;if((i|0)!=(c[741]|0))return;c[741]=0;c[738]=0;return}if((c[741]|0)==(j|0)){j=(c[738]|0)+b|0;c[738]=j;c[741]=h;c[i+4>>2]=j|1;c[h+j>>2]=j;return}f=(d&-8)+b|0;do if(d>>>0<256){a=c[j+8>>2]|0;b=c[j+12>>2]|0;if((b|0)==(a|0)){c[736]=c[736]&~(1<<(d>>>3));break}else{c[a+12>>2]=b;c[b+8>>2]=a;break}}else{g=c[j+24>>2]|0;b=c[j+12>>2]|0;do if((b|0)==(j|0)){b=c[j+16+4>>2]|0;if(!b){b=c[j+16>>2]|0;if(!b){a=0;break}else a=j+16|0;}else a=j+16+4|0;while(1){e=b+20|0;d=c[e>>2]|0;if(!d){e=b+16|0;d=c[e>>2]|0;if(!d)break;else{b=d;a=e;}}else{b=d;a=e;}}c[a>>2]=0;a=b;}else{a=c[j+8>>2]|0;c[a+12>>2]=b;c[b+8>>2]=a;a=b;}while(0);if(g|0){b=c[j+28>>2]|0;if((c[3248+(b<<2)>>2]|0)==(j|0)){c[3248+(b<<2)>>2]=a;if(!a){c[737]=c[737]&~(1<<b);break}}else{c[((c[g+16>>2]|0)==(j|0)?g+16|0:g+20|0)>>2]=a;if(!a)break}c[a+24>>2]=g;b=c[j+16>>2]|0;if(b|0){c[a+16>>2]=b;c[b+24>>2]=a;}b=c[j+16+4>>2]|0;if(b|0){c[a+20>>2]=b;c[b+24>>2]=a;}}}while(0);c[i+4>>2]=f|1;c[h+f>>2]=f;if((i|0)==(c[741]|0)){c[738]=f;return}}else{c[j+4>>2]=d&-2;c[i+4>>2]=b|1;c[h+b>>2]=b;f=b;}d=f>>>3;if(f>>>0<256){b=c[736]|0;if(!(b&1<<d)){c[736]=b|1<<d;b=2984+(d<<1<<2)|0;a=2984+(d<<1<<2)+8|0;}else{b=c[2984+(d<<1<<2)+8>>2]|0;a=2984+(d<<1<<2)+8|0;}c[a>>2]=i;c[b+12>>2]=i;c[i+8>>2]=b;c[i+12>>2]=2984+(d<<1<<2);return}b=f>>>8;if(b)if(f>>>0>16777215)e=31;else{e=b<<((b+1048320|0)>>>16&8)<<(((b<<((b+1048320|0)>>>16&8))+520192|0)>>>16&4);e=14-(((b<<((b+1048320|0)>>>16&8))+520192|0)>>>16&4|(b+1048320|0)>>>16&8|(e+245760|0)>>>16&2)+(e<<((e+245760|0)>>>16&2)>>>15)|0;e=f>>>(e+7|0)&1|e<<1;}else e=0;b=3248+(e<<2)|0;c[i+28>>2]=e;c[i+20>>2]=0;c[i+16>>2]=0;a=c[737]|0;d=1<<e;a:do if(!(a&d)){c[737]=a|d;c[b>>2]=i;c[i+24>>2]=b;c[i+12>>2]=i;c[i+8>>2]=i;}else{b=c[b>>2]|0;b:do if((c[b+4>>2]&-8|0)!=(f|0)){e=f<<((e|0)==31?0:25-(e>>>1)|0);while(1){d=b+16+(e>>>31<<2)|0;a=c[d>>2]|0;if(!a)break;if((c[a+4>>2]&-8|0)==(f|0)){b=a;break b}else{e=e<<1;b=a;}}c[d>>2]=i;c[i+24>>2]=b;c[i+12>>2]=i;c[i+8>>2]=i;break a}while(0);h=b+8|0;j=c[h>>2]|0;c[j+12>>2]=i;c[h>>2]=i;c[i+8>>2]=j;c[i+12>>2]=b;c[i+24>>2]=0;}while(0);j=(c[744]|0)+-1|0;c[744]=j;if(j|0)return;b=3400;while(1){b=c[b>>2]|0;if(!b)break;else b=b+8|0;}c[744]=-1;return}function Qa(a,b){a=a|0;b=b|0;var c=0,d=0,e=0;c=r(b&65535,a&65535)|0;e=(c>>>16)+(r(b&65535,a>>>16)|0)|0;d=r(b>>>16,a&65535)|0;return (u((e>>>16)+(r(b>>>16,a>>>16)|0)+(((e&65535)+d|0)>>>16)|0),e+d<<16|c&65535|0)|0}function Ra(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;e=Qa(a,c)|0;f=v()|0;return (u((r(b,c)|0)+(r(d,a)|0)+f|f&0|0),e|0|0)|0}function Sa(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return (u(b+d+(a+c>>>0>>>0<a>>>0|0)>>>0|0),a+c>>>0|0)|0}function Ta(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;d=b-d-(c>>>0>a>>>0|0)>>>0;return (u(d|0),a-c>>>0|0)|0}function Ua(a){a=a|0;return (a?31-(s(a^a-1)|0)|0:32)|0}function Va(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;if(!b)if(!e){if(f|0){c[f>>2]=(a>>>0)%(d>>>0);c[f+4>>2]=0;}e=0;f=(a>>>0)/(d>>>0)>>>0;return (u(e|0),f)|0}else{if(!f){e=0;f=0;return (u(e|0),f)|0}c[f>>2]=a|0;c[f+4>>2]=b&0;e=0;f=0;return (u(e|0),f)|0}do if(d){if(e|0){h=(s(e|0)|0)-(s(b|0)|0)|0;if(h>>>0<=31){n=h+1|0;i=a>>>((h+1|0)>>>0)&h-31>>31|b<<31-h;m=b>>>((h+1|0)>>>0)&h-31>>31;g=0;h=a<<31-h;break}if(!f){e=0;f=0;return (u(e|0),f)|0}c[f>>2]=a|0;c[f+4>>2]=b|b&0;e=0;f=0;return (u(e|0),f)|0}if(d-1&d|0){h=(s(d|0)|0)+33-(s(b|0)|0)|0;n=h;i=32-h-1>>31&b>>>((h-32|0)>>>0)|(b<<32-h|a>>>(h>>>0))&h-32>>31;m=h-32>>31&b>>>(h>>>0);g=a<<64-h&32-h>>31;h=(b<<64-h|a>>>((h-32|0)>>>0))&32-h>>31|a<<32-h&h-33>>31;break}if(f|0){c[f>>2]=d-1&a;c[f+4>>2]=0;}if((d|0)==1){e=b|b&0;f=a|0|0;return (u(e|0),f)|0}else{f=Ua(d|0)|0;e=b>>>(f>>>0)|0;f=b<<32-f|a>>>(f>>>0)|0;return (u(e|0),f)|0}}else{if(!e){if(f|0){c[f>>2]=(b>>>0)%(d>>>0);c[f+4>>2]=0;}e=0;f=(b>>>0)/(d>>>0)>>>0;return (u(e|0),f)|0}if(!a){if(f|0){c[f>>2]=0;c[f+4>>2]=(b>>>0)%(e>>>0);}d=0;f=(b>>>0)/(e>>>0)>>>0;return (u(d|0),f)|0}if(!(e-1&e)){if(f|0){c[f>>2]=a|0;c[f+4>>2]=e-1&b|b&0;}d=0;f=b>>>((Ua(e|0)|0)>>>0);return (u(d|0),f)|0}h=(s(e|0)|0)-(s(b|0)|0)|0;if(h>>>0<=30){n=h+1|0;i=b<<31-h|a>>>((h+1|0)>>>0);m=b>>>((h+1|0)>>>0);g=0;h=a<<31-h;break}if(!f){e=0;f=0;return (u(e|0),f)|0}c[f>>2]=a|0;c[f+4>>2]=b|b&0;e=0;f=0;return (u(e|0),f)|0}while(0);if(!n){j=h;b=m;a=0;h=0;}else{k=Sa(d|0|0,e|e&0|0,-1,-1)|0;l=v()|0;j=h;b=m;a=n;h=0;do{p=j;j=g>>>31|j<<1;g=h|g<<1;p=i<<1|p>>>31|0;o=i>>>31|b<<1|0;Ta(k|0,l|0,p|0,o|0)|0;n=v()|0;m=n>>31|((n|0)<0?-1:0)<<1;h=m&1;i=Ta(p|0,o|0,m&(d|0)|0,(((n|0)<0?-1:0)>>31|((n|0)<0?-1:0)<<1)&(e|e&0)|0)|0;b=v()|0;a=a-1|0;}while((a|0)!=0);a=0;}if(f|0){c[f>>2]=i;c[f+4>>2]=b;}o=(g|0)>>>31|j<<1|(0<<1|g>>>31)&0|a;p=(g<<1|0>>>31)&-2|h;return (u(o|0),p)|0}function Wa(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Va(a,b,c,d,0)|0}function Xa(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){u(b>>>c|0);return a>>>c|(b&(1<<c)-1)<<32-c}u(0);return b>>>c-32|0}function Ya(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){u(b<<c|(a&(1<<c)-1<<32-c)>>>32-c|0);return a<<c}u(a<<c-32|0);return 0}function Za(a){a=a|0;return (a&255)<<24|(a>>8&255)<<16|(a>>16&255)<<8|a>>>24|0}function _a(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;if((e|0)>=8192){D(b|0,d|0,e|0)|0;return b|0}h=b|0;g=b+e|0;if((b&3)==(d&3)){while(b&3){if(!e)return h|0;a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;e=e-1|0;}e=g&-4|0;f=e-64|0;while((b|0)<=(f|0)){c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[b+16>>2]=c[d+16>>2];c[b+20>>2]=c[d+20>>2];c[b+24>>2]=c[d+24>>2];c[b+28>>2]=c[d+28>>2];c[b+32>>2]=c[d+32>>2];c[b+36>>2]=c[d+36>>2];c[b+40>>2]=c[d+40>>2];c[b+44>>2]=c[d+44>>2];c[b+48>>2]=c[d+48>>2];c[b+52>>2]=c[d+52>>2];c[b+56>>2]=c[d+56>>2];c[b+60>>2]=c[d+60>>2];b=b+64|0;d=d+64|0;}while((b|0)<(e|0)){c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}}else{e=g-4|0;while((b|0)<(e|0)){a[b>>0]=a[d>>0]|0;a[b+1>>0]=a[d+1>>0]|0;a[b+2>>0]=a[d+2>>0]|0;a[b+3>>0]=a[d+3>>0]|0;b=b+4|0;d=d+4|0;}}while((b|0)<(g|0)){a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;}return h|0}function $a(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0;f=b+e|0;d=d&255;if((e|0)>=67){while(b&3){a[b>>0]=d;b=b+1|0;}g=d|d<<8|d<<16|d<<24;while((b|0)<=((f&-4)-64|0)){c[b>>2]=g;c[b+4>>2]=g;c[b+8>>2]=g;c[b+12>>2]=g;c[b+16>>2]=g;c[b+20>>2]=g;c[b+24>>2]=g;c[b+28>>2]=g;c[b+32>>2]=g;c[b+36>>2]=g;c[b+40>>2]=g;c[b+44>>2]=g;c[b+48>>2]=g;c[b+52>>2]=g;c[b+56>>2]=g;c[b+60>>2]=g;b=b+64|0;}while((b|0)<(f&-4|0)){c[b>>2]=g;b=b+4|0;}}while((b|0)<(f|0)){a[b>>0]=d;b=b+1|0;}return f-e|0}function ab(a){a=a|0;var b=0,d=0;d=C()|0;b=c[i>>2]|0;if((a|0)>0&(b+a|0)<(b|0)|(b+a|0)<0){H(b+a|0)|0;w(12);return -1}if((b+a|0)>(d|0))if(!(E(b+a|0)|0)){w(12);return -1}c[i>>2]=b+a;return b|0}function bb(a,b){a=a|0;b=b|0;return Q[a&1](b|0)|0}function cb(a,b,c,d,e,f,g){a=a|0;b=b|0;c=+c;d=d|0;e=e|0;f=f|0;g=g|0;return R[a&1](b|0,+c,d|0,e|0,f|0,g|0)|0}function db(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return S[a&1](b|0,c|0,d|0)|0}function eb(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;return T[a&1](b|0,c|0,d|0,e|0)|0}function fb(a,b,c){a=a|0;b=b|0;c=c|0;U[a&1](b|0,c|0);}function gb(a){a=a|0;t(0);return 0}function hb(a,b,c,d,e,f){a=a|0;b=+b;c=c|0;d=d|0;e=e|0;f=f|0;t(1);return 0}function ib(a,b,c){a=a|0;b=b|0;c=c|0;t(2);return 0}function jb(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;t(3);return 0}function kb(a,b){a=a|0;b=b|0;t(4);}

	// EMSCRIPTEN_END_FUNCS
	var Q=[gb,ga];var R=[hb,xa];var S=[ib,ha];var T=[jb,ia];var U=[kb,ya];return {___errno_location:ka,___muldi3:Ra,___udivdi3:Wa,_abort_run:aa,_bitshift64Lshr:Xa,_bitshift64Shl:Ya,_enable_debug:ba,_free:Pa,_i64Add:Sa,_i64Subtract:Ta,_llvm_bswap_i32:Za,_malloc:Oa,_memcpy:_a,_memset:$a,_ping:_,_read_register:ca,_reset:ea,_run:$,_sbrk:ab,_set_stop_address:Z,_write_register:da,dynCall_ii:bb,dynCall_iidiiii:cb,dynCall_iiii:db,dynCall_iiiii:eb,dynCall_vii:fb,establishStackSpace:Y,stackAlloc:V,stackRestore:X,stackSave:W}})


	// EMSCRIPTEN_END_ASM
	(asmGlobalArg,asmLibraryArg,buffer);var ___errno_location=Module["___errno_location"]=asm["___errno_location"];var ___muldi3=Module["___muldi3"]=asm["___muldi3"];var ___udivdi3=Module["___udivdi3"]=asm["___udivdi3"];var _abort_run=Module["_abort_run"]=asm["_abort_run"];var _bitshift64Lshr=Module["_bitshift64Lshr"]=asm["_bitshift64Lshr"];var _bitshift64Shl=Module["_bitshift64Shl"]=asm["_bitshift64Shl"];var _enable_debug=Module["_enable_debug"]=asm["_enable_debug"];var _free=Module["_free"]=asm["_free"];var _i64Add=Module["_i64Add"]=asm["_i64Add"];var _i64Subtract=Module["_i64Subtract"]=asm["_i64Subtract"];var _llvm_bswap_i32=Module["_llvm_bswap_i32"]=asm["_llvm_bswap_i32"];var _malloc=Module["_malloc"]=asm["_malloc"];var _memcpy=Module["_memcpy"]=asm["_memcpy"];var _memset=Module["_memset"]=asm["_memset"];var _ping=Module["_ping"]=asm["_ping"];var _read_register=Module["_read_register"]=asm["_read_register"];var _reset=Module["_reset"]=asm["_reset"];var _run=Module["_run"]=asm["_run"];var _sbrk=Module["_sbrk"]=asm["_sbrk"];var _set_stop_address=Module["_set_stop_address"]=asm["_set_stop_address"];var _write_register=Module["_write_register"]=asm["_write_register"];var establishStackSpace=Module["establishStackSpace"]=asm["establishStackSpace"];var stackAlloc=Module["stackAlloc"]=asm["stackAlloc"];var stackRestore=Module["stackRestore"]=asm["stackRestore"];var stackSave=Module["stackSave"]=asm["stackSave"];var dynCall_ii=Module["dynCall_ii"]=asm["dynCall_ii"];var dynCall_iidiiii=Module["dynCall_iidiiii"]=asm["dynCall_iidiiii"];var dynCall_iiii=Module["dynCall_iiii"]=asm["dynCall_iiii"];var dynCall_iiiii=Module["dynCall_iiiii"]=asm["dynCall_iiiii"];var dynCall_vii=Module["dynCall_vii"]=asm["dynCall_vii"];Module["asm"]=asm;Module["ccall"]=ccall;if(memoryInitializer){if(!isDataURI(memoryInitializer)){memoryInitializer=locateFile(memoryInitializer);}if(ENVIRONMENT_IS_NODE||ENVIRONMENT_IS_SHELL){var data=readBinary(memoryInitializer);HEAPU8.set(data,GLOBAL_BASE);}else{addRunDependency();var applyMemoryInitializer=function(data){if(data.byteLength)data=new Uint8Array(data);HEAPU8.set(data,GLOBAL_BASE);if(Module["memoryInitializerRequest"])delete Module["memoryInitializerRequest"].response;removeRunDependency();};var doBrowserLoad=function(){readAsync(memoryInitializer,applyMemoryInitializer,function(){throw "could not load memory initializer "+memoryInitializer});};var memoryInitializerBytes=tryParseAsDataURI(memoryInitializer);if(memoryInitializerBytes){applyMemoryInitializer(memoryInitializerBytes.buffer);}else if(Module["memoryInitializerRequest"]){var useRequest=function(){var request=Module["memoryInitializerRequest"];var response=request.response;if(request.status!==200&&request.status!==0){var data=tryParseAsDataURI(Module["memoryInitializerRequestURL"]);if(data){response=data.buffer;}else{console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: "+request.status+", retrying "+memoryInitializer);doBrowserLoad();return}}applyMemoryInitializer(response);};if(Module["memoryInitializerRequest"].response){setTimeout(useRequest,0);}else{Module["memoryInitializerRequest"].addEventListener("load",useRequest);}}else{doBrowserLoad();}}}var calledRun;Module["then"]=function(func){if(calledRun){func(Module);}else{var old=Module["onRuntimeInitialized"];Module["onRuntimeInitialized"]=function(){if(old)old();func(Module);};}return Module};function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status;}dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller;};function run(args){if(runDependencies>0){return}preRun();if(runDependencies>0)return;function doRun(){if(calledRun)return;calledRun=true;if(ABORT)return;initRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun();}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("");},1);doRun();},1);}else{doRun();}}Module["run"]=run;function exit(status,implicit){if(implicit&&noExitRuntime&&status===0){return}if(noExitRuntime);else{ABORT=true;if(Module["onExit"])Module["onExit"](status);}quit_(status,new ExitStatus(status));}function abort(what){if(Module["onAbort"]){Module["onAbort"](what);}what+="";out(what);err(what);ABORT=true;throw "abort("+what+"). Build with -s ASSERTIONS=1 for more info."}Module["abort"]=abort;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()();}}noExitRuntime=true;run();



	  return Module
	}
	);
	})();
	module.exports = Module;
	    module.exports = Module;
	});

	var Thumbulator_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });


	var Thumbulator = (function () {
	    function Thumbulator(bus, options) {
	        if (options === void 0) { options = {}; }
	        this._module = null;
	        this._options = null;
	        this._options = tslib_es6.__assign({ stopAddress: 0 }, options);
	        this._module = thumbulator(this._getApi(bus, this._options));
	        this.enableDebug(false);
	    }
	    Thumbulator.prototype.init = function () {
	        return tslib_es6.__awaiter(this, void 0, void 0, function () {
	            return tslib_es6.__generator(this, function (_a) {
	                this._module._set_stop_address(this._options.stopAddress);
	                return [2];
	            });
	        });
	    };
	    Thumbulator.prototype.ping = function () {
	        return this._module.ccall('ping', 'string', [], []);
	    };
	    Thumbulator.prototype.run = function (cycles) {
	        return this._module._run(cycles);
	    };
	    Thumbulator.prototype.abort = function () {
	        this._module._abort_run();
	    };
	    Thumbulator.prototype.enableDebug = function (enable) {
	        this._module._enable_debug(enable ? 1 : 0);
	    };
	    Thumbulator.prototype.reset = function () {
	        this._module._reset();
	    };
	    Thumbulator.prototype.readRegister = function (register) {
	        if (register < 0 || register > 15) {
	            throw new Error("illegal thumb register " + register);
	        }
	        return this._module._read_register(register);
	    };
	    Thumbulator.prototype.writeRegister = function (register, value) {
	        if (register < 0 || register > 15) {
	            throw new Error("illegal thumb register " + register);
	        }
	        this._module._write_register(register, value);
	    };
	    Thumbulator.prototype._getApi = function (bus, options) {
	        var printer = options.printer || (function (data) { return console.log('thumbulator: ' + data); });
	        return {
	            print: printer,
	            printErr: printer,
	            trapOnInstructionFetch: options.trapOnInstructionFetch || (function () { return 0; }),
	            trapOnBx32: options.trapOnBx32 || (function () { return 3; }),
	            busRead16: bus.read16,
	            busRead32: bus.read32 || (function (address) { return (bus.read16(address) & 0xffff) | (bus.read16(address + 2) << 16); }),
	            busWrite16: bus.write16,
	            busWrite32: bus.write32 ||
	                (function (address, value) { return (bus.write16(address, value & 0xffff), bus.write16(address + 2, value >>> 16)); })
	        };
	    };
	    return Thumbulator;
	}());
	exports.default = Thumbulator;
	});

	var Thumbulator = unwrapExports(Thumbulator_1);

	function encodeWithPrefix(value, width, signed = true, prefix = '') {
	    if (!signed && value < 0) {
	        return (encodeWithPrefix(value >>> 16, width && width > 8 ? width - 4 : 4, false, prefix) +
	            encodeWithPrefix(value & 0xffff, 4));
	    }
	    let result = Math.abs(value)
	        .toString(16)
	        .toUpperCase();
	    if (typeof width !== 'undefined') {
	        while (result.length < width) {
	            result = '0' + result;
	        }
	    }
	    return (value < 0 ? '-' : '') + prefix + result;
	}
	function encode(value, width, signed = true) {
	    return encodeWithPrefix(value, width, signed, '$');
	}

	function hostIsLittleEndian() {
	    const buffer8 = new Uint8Array([1, 2, 3, 4]), buffer32 = new Uint32Array(buffer8.buffer);
	    return buffer32[0] === 0x04030201;
	}
	class Soc {
	    constructor(blx32Handler = () => 3) {
	        this.trap = new lib_1();
	        this._thumbulatorBus = {
	            read16: (address) => {
	                if (address & 0x01) {
	                    this._triggerTrap(`unaligned 16 bit ARM read from ${encode(address, 8, false)}`);
	                    return 0;
	                }
	                const region = address >>> 28, addr = address & 0x0fffffff;
	                switch (region) {
	                    case 0x0:
	                        if (addr < 0x8000) {
	                            return this.getRom16(addr);
	                        }
	                        break;
	                    case 0x4:
	                        if (addr < 0x2000) {
	                            return this.getRam16(addr);
	                        }
	                        break;
	                    case 0xe:
	                        switch (addr) {
	                            case 0x001fc000:
	                                return this._armMamcr;
	                        }
	                        break;
	                }
	                this._triggerTrap(`invalid 16 bit ARM read from ${encode(address, 8, false)}`);
	            },
	            read32: (address) => {
	                if (address & 0x03) {
	                    this._triggerTrap(`unaligned 32 bit ARM read from ${encode(address, 8, false)}`);
	                    return 0;
	                }
	                const region = address >>> 28, addr = address & 0x0fffffff;
	                switch (region) {
	                    case 0x0:
	                        if (addr < 0x8000) {
	                            return this.getRom32(addr);
	                        }
	                        break;
	                    case 0x4:
	                        if (addr < 0x2000) {
	                            return this.getRam32(addr);
	                        }
	                        break;
	                    case 0xe:
	                        switch (addr) {
	                            case 0x8004:
	                            case 0x8008:
	                                return 0;
	                        }
	                        break;
	                }
	                this._triggerTrap(`invalid 32 bit ARM read from ${encode(address, 8, false)}`);
	            },
	            write16: (address, value) => {
	                if (address & 0x01) {
	                    this._triggerTrap(`unaligned 16 bit ARM write: ${encode(value, 4)} -> ${encode(address, 8, false)}`);
	                    return;
	                }
	                const region = address >>> 28, addr = address & 0x0fffffff;
	                switch (region) {
	                    case 0x04:
	                        if (addr < 0x2000) {
	                            this.setRam16(addr, value & 0xffff);
	                            return;
	                        }
	                        break;
	                    case 0xe:
	                        switch (addr) {
	                            case 0x001fc000:
	                                this._armMamcr = value;
	                                return;
	                        }
	                        break;
	                }
	                this._triggerTrap(`invalid 16 bit ARM write: ${encode(value, 4)} -> ${encode(address, 8, false)}`);
	            },
	            write32: (address, value) => {
	                if (address & 0x03) {
	                    this._triggerTrap(`unaligned 32 bit ARM write: ${encode(value, 8, false)} -> ${encode(address, 8, false)}`);
	                    return;
	                }
	                const region = address >>> 28, addr = address & 0x0fffffff;
	                switch (region) {
	                    case 0x4:
	                        if (addr < 0x2000) {
	                            this.setRam32(addr, value);
	                            return;
	                        }
	                    case 0xe:
	                        switch (addr) {
	                            case 0x8004:
	                            case 0x8008:
	                                return;
	                        }
	                        break;
	                }
	                this._triggerTrap(`invalid 32 bit ARM write: ${encode(value, 8, false)} -> ${encode(address, 8, false)}`);
	            }
	        };
	        this._romBuffer = new ArrayBuffer(0x8000);
	        this._ramBuffer = new ArrayBuffer(0x2000);
	        this._armMamcr = 0;
	        this._thumbulator = null;
	        if (hostIsLittleEndian()) {
	            this.getRom16 = address => this._rom16[address >>> 1];
	            this.getRom32 = address => this._rom32[address >>> 2];
	            this.getRam16 = address => this._ram16[address >>> 1];
	            this.getRam32 = address => this._ram32[address >>> 2];
	            this.setRam16 = (address, value) => (this._ram16[address >>> 1] = value);
	            this.setRam32 = (address, value) => (this._ram32[address >>> 2] = value);
	        }
	        else {
	            this.getRom16 = address => this._rom8[address] | (this._rom8[address + 1] << 8);
	            this.getRom32 = address => this._rom8[address] |
	                (this._rom8[address + 1] << 8) |
	                (this._rom8[address + 2] << 16) |
	                (this._rom8[address + 3] << 24);
	            this.getRam16 = address => this._ram8[address] | (this._ram8[address + 1] << 8);
	            this.getRam32 = address => this._ram8[address] |
	                (this._ram8[address + 1] << 8) |
	                (this._ram8[address + 2] << 16) |
	                (this._ram8[address + 3] << 24);
	            this.setRam16 = (address, value) => {
	                this._ram8[address] = value & 0xff;
	                this._ram8[address + 1] = (value >>> 8) & 0xff;
	            };
	            this.setRam32 = (address, value) => {
	                this._ram8[address] = value & 0xff;
	                this._ram8[address + 1] = (value >>> 8) & 0xff;
	                this._ram8[address + 2] = (value >>> 16) & 0xff;
	                this._ram8[address + 3] = (value >>> 24) & 0xff;
	            };
	        }
	        this._rom8 = new Uint8Array(this._romBuffer);
	        this._rom16 = new Uint16Array(this._romBuffer);
	        this._rom32 = new Uint32Array(this._romBuffer);
	        this._ram8 = new Uint8Array(this._ramBuffer);
	        this._ram16 = new Uint16Array(this._ramBuffer);
	        this._ram32 = new Uint32Array(this._ramBuffer);
	        this._thumbulator = new Thumbulator(this._thumbulatorBus, {
	            stopAddress: 32772,
	            trapOnBx32: blx32Handler
	        });
	        this.reset();
	    }
	    init() {
	        return this._thumbulator.init();
	    }
	    reset() { }
	    getRom() {
	        return this._rom8;
	    }
	    getRam() {
	        return this._ram8;
	    }
	    run(entry) {
	        this._thumbulator.reset();
	        this._thumbulator.enableDebug(false);
	        for (let i = 0; i <= 12; i++) {
	            this._thumbulator.writeRegister(i, 0);
	        }
	        this._thumbulator.writeRegister(13, 0x40001fb4);
	        this._thumbulator.writeRegister(14, 32772 + 1);
	        this._thumbulator.writeRegister(15, entry);
	        this._armMamcr = 0;
	        const trap = this._thumbulator.run(500000);
	        if (trap !== 20 && trap !== 10) {
	            this._triggerTrap(`ARM execution trapped: ${trap}`);
	        }
	    }
	    getThumbulator() {
	        return this._thumbulator;
	    }
	    _triggerTrap(message) {
	        this._thumbulator.abort();
	        this.trap.dispatch(message);
	    }
	}

	class CartridgeDPCPlus extends AbstractCartridge {
	    constructor(buffer) {
	        super();
	        this._banks = new Array(6);
	        this._fetchers = new Array(8);
	        this._fractionalFetchers = new Array(8);
	        this._musicFetchers = new Array(3);
	        this._parameters = new Uint8Array(8);
	        this._parameterIndex = 0;
	        this._rng = 0;
	        this._clockAccumulator = 0;
	        this._lastCpuTime = 0;
	        this._fastFetch = false;
	        this._ldaPending = false;
	        this._cpuTimeProvider = null;
	        this._soc = new Soc();
	        if (buffer.length < 28 * 0x0400 || buffer.length > 0x8000) {
	            throw new Error(`not a DPC+ image: invalid lenght ${buffer.length}`);
	        }
	        this._rom = this._soc.getRom();
	        for (let i = 0; i < 6; i++) {
	            this._banks[i] = new Uint8Array(this._rom.buffer, 0x0c00 + i * 0x1000, 0x1000);
	        }
	        this._ram = this._soc.getRam();
	        this._imageRam = new Uint8Array(this._ram.buffer, 0x0c00, 0x1000);
	        const offset = 0x8000 - buffer.length;
	        for (let i = 0; i < buffer.length; i++) {
	            this._rom[offset + i] = buffer[i];
	        }
	        for (let i = 0; i < 8; i++) {
	            this._fetchers[i] = new Fetcher$1();
	            this._fractionalFetchers[i] = new FractionalFetcher();
	        }
	        for (let i = 0; i < 3; i++) {
	            this._musicFetchers[i] = new MusicFetcher();
	        }
	        this._soc.trap.addHandler(message => this.triggerTrap(2, message));
	        this.reset();
	    }
	    static matchesBuffer(buffer) {
	        const signatureCounts = searchForSignatures(buffer, ['DPC+'.split('').map(x => x.charCodeAt(0))]);
	        return signatureCounts[0] === 2;
	    }
	    init() {
	        return this._soc.init();
	    }
	    reset() {
	        this._soc.reset();
	        this._currentBank = this._banks[5];
	        for (let i = 0; i < 0x0300; i++) {
	            this._soc.setRam32(i << 2, this._soc.getRom32(i << 2));
	        }
	        for (let i = 0x1b00; i < 0x2000; i++) {
	            this._soc.setRam32((0x0300 + i - 0x1b00) << 2, this._soc.getRom32(i << 2));
	        }
	        this._currentBank = this._banks[5];
	        for (let i = 0; i < 8; i++) {
	            this._parameters[i] = 0;
	        }
	        for (let i = 0; i < 8; i++) {
	            this._fetchers[i].reset();
	            this._fractionalFetchers[i].reset();
	        }
	        for (let i = 0; i < 3; i++) {
	            this._musicFetchers[i].reset();
	        }
	        this._parameterIndex = 0;
	        this._fastFetch = this._ldaPending = false;
	        this._rng = 0x2b435044;
	        this._lastCpuTime = 0;
	        this._clockAccumulator = 0;
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_dpc_plus;
	    }
	    setBus(bus) {
	        this._bus = bus;
	        return this;
	    }
	    setCpuTimeProvider(provider) {
	        this._cpuTimeProvider = provider;
	        return this;
	    }
	    read(address) {
	        return this._access(address, this._bus.getLastDataBusValue());
	    }
	    peek(address) {
	        return this._currentBank[address & 0x0fff];
	    }
	    write(address, value) {
	        this._access(address, value);
	    }
	    triggerTrap(reason, message) {
	        super.triggerTrap(reason, message);
	    }
	    _access(address, value) {
	        address &= 0x0fff;
	        const readResult = this._currentBank[address];
	        if (this._fastFetch && this._ldaPending && address > 0x7f && address < 0x0ff6 && readResult < 0x28) {
	            address = readResult;
	        }
	        this._ldaPending = false;
	        if (address < 0x28) {
	            const idx = address & 0x07, fetcher = this._fetchers[idx], fractionalFetcher = this._fractionalFetchers[idx];
	            let result = 0;
	            switch ((address >>> 3) & 0x07) {
	                case 0x00:
	                    switch (idx) {
	                        case 0x00:
	                            this._advanceRng();
	                            return this._rng & 0xff;
	                        case 0x01:
	                            this._rewindRng();
	                            return this._rng & 0xff;
	                        case 0x02:
	                            return (this._rng >>> 8) & 0xff;
	                        case 0x03:
	                            return (this._rng >>> 16) & 0xff;
	                        case 0x04:
	                            return (this._rng >>> 24) & 0xff;
	                        case 0x05: {
	                            this._clockMusicFetchers();
	                            let acc = 0;
	                            for (let i = 0; i < 3; i++) {
	                                acc += this._imageRam[(this._musicFetchers[i].waveform << 5) + this._musicFetchers[i].waveformSample()];
	                            }
	                            return acc & 0xff;
	                        }
	                    }
	                    return 0;
	                case 0x01:
	                    result = this._imageRam[fetcher.pointer];
	                    fetcher.increment();
	                    return result;
	                case 0x02:
	                    result = this._imageRam[fetcher.pointer] & fetcher.mask();
	                    fetcher.increment();
	                    return result;
	                case 0x03:
	                    result = this._imageRam[fractionalFetcher.pointer >>> 8];
	                    fractionalFetcher.increment();
	                    return result;
	                case 0x04:
	                    return idx < 4 ? fetcher.mask() : 0;
	                default:
	                    return 0;
	            }
	        }
	        else if (address < 0x80) {
	            const idx = address & 0x07, fetcher = this._fetchers[idx], fractionalFetcher = this._fractionalFetchers[idx];
	            switch (((address - 0x28) >>> 3) & 0x0f) {
	                case 0x00:
	                    fractionalFetcher.setPointerLo(value);
	                    break;
	                case 0x01:
	                    fractionalFetcher.setPointerHi(value);
	                    break;
	                case 0x02:
	                    fractionalFetcher.setFraction(value);
	                    break;
	                case 0x03:
	                    fetcher.top = value;
	                    break;
	                case 0x04:
	                    fetcher.bottom = value;
	                    break;
	                case 0x05:
	                    fetcher.setPointerLo(value);
	                    break;
	                case 0x06:
	                    switch (idx) {
	                        case 0x00:
	                            this._fastFetch = value === 0;
	                            break;
	                        case 0x01:
	                            if (this._parameterIndex < 8) {
	                                this._parameters[this._parameterIndex++] = value;
	                            }
	                            break;
	                        case 0x02:
	                            this._dispatchFunction(value);
	                            break;
	                        case 0x05:
	                        case 0x06:
	                        case 0x07:
	                            this._musicFetchers[idx - 0x05].waveform = value & 0x7f;
	                            break;
	                    }
	                    break;
	                case 0x07:
	                    fetcher.decrement();
	                    this._imageRam[fetcher.pointer] = value;
	                    break;
	                case 0x08:
	                    fetcher.setPointerHi(value);
	                    break;
	                case 0x09:
	                    switch (idx) {
	                        case 0x00:
	                            this._rng = 0x2b435044;
	                            break;
	                        case 0x01:
	                            this._rng = (this._rng & 0xffffff00) | value;
	                            break;
	                        case 0x02:
	                            this._rng = (this._rng & 0xffff00ff) | (value << 8);
	                            break;
	                        case 0x03:
	                            this._rng = (this._rng & 0xff00ffff) | (value << 16);
	                            break;
	                        case 0x04:
	                            this._rng = (this._rng & 0x00ffffff) | (value << 24);
	                            break;
	                        case 0x05:
	                        case 0x06:
	                        case 0x07:
	                            this._musicFetchers[idx - 0x05].frequency = this._soc.getRam32(0x2000 - 0x400 + (value << 2));
	                            break;
	                    }
	                    break;
	                case 0x0a:
	                    this._imageRam[fetcher.pointer] = value;
	                    fetcher.increment();
	                    break;
	            }
	        }
	        else if (address > 0x0ff5 && address < 0x0ffc) {
	            this._currentBank = this._banks[address - 0x0ff6];
	        }
	        if (this._fastFetch && address > 0x7f && address < 0x0ff6) {
	            this._ldaPending = readResult === 0xa9;
	        }
	        return readResult;
	    }
	    _clockMusicFetchers() {
	        const cpuTime = this._cpuTimeProvider();
	        this._clockAccumulator += (cpuTime - this._lastCpuTime) * 20000;
	        this._lastCpuTime = cpuTime;
	        const clocks = Math.floor(this._clockAccumulator);
	        this._clockAccumulator -= clocks;
	        if (clocks === 0) {
	            return;
	        }
	        for (let i = 0; i < 3; i++) {
	            this._musicFetchers[i].increment(clocks);
	        }
	    }
	    _dispatchFunction(index) {
	        const romBase = this._parameters[0] + (this._parameters[1] << 8);
	        switch (index) {
	            case 0:
	                this._parameterIndex = 0;
	                break;
	            case 1:
	                for (let i = 0; i < this._parameters[3]; i++) {
	                    this._ram[0x0c00 + ((this._fetchers[this._parameters[2] & 0x07].pointer + i) & 0x0fff)] = this._rom[0x0c00 + (romBase + i) % 0x7400];
	                }
	                this._parameterIndex = 0;
	                break;
	            case 2:
	                for (let i = 0; i < this._parameters[3]; i++) {
	                    this._ram[0x0c00 + ((this._fetchers[this._parameters[2] & 0x07].pointer + i) & 0x0fff)] = this._parameters[0];
	                }
	                this._parameterIndex = 0;
	                break;
	            case 254:
	            case 255:
	                this._soc.run(0x0c0b);
	                break;
	        }
	    }
	    _advanceRng() {
	        this._rng = (this._rng & (1 << 10) ? 0x10adab1e : 0x00) ^ ((this._rng >>> 11) | (this._rng << 21));
	    }
	    _rewindRng() {
	        this._rng =
	            this._rng & (1 << 31)
	                ? ((0x10adab1e ^ this._rng) << 11) | ((0x10adab1e ^ this._rng) >>> 21)
	                : (this._rng << 11) | (this._rng >>> 21);
	    }
	}
	class Fetcher$1 {
	    constructor() {
	        this.pointer = 0;
	        this.top = 0;
	        this.bottom = 0;
	    }
	    contructor() {
	        this.reset();
	    }
	    reset() {
	        this.pointer = this.top = this.bottom = 0;
	    }
	    setPointerHi(value) {
	        this.pointer = (this.pointer & 0xff) | ((value & 0x0f) << 8);
	    }
	    setPointerLo(value) {
	        this.pointer = (this.pointer & 0x0f00) | (value & 0xff);
	    }
	    increment() {
	        this.pointer = (this.pointer + 1) & 0xfff;
	    }
	    decrement() {
	        this.pointer = (this.pointer + 0xfff) & 0xfff;
	    }
	    mask() {
	        return ((this.top - (this.pointer & 0xff)) & 0xff) > ((this.top - this.bottom) & 0xff) ? 0xff : 0;
	    }
	}
	class FractionalFetcher {
	    constructor() {
	        this.pointer = 0;
	        this.fraction = 0;
	    }
	    contructor() {
	        this.reset();
	    }
	    reset() {
	        this.pointer = this.fraction = 0;
	    }
	    setPointerHi(value) {
	        this.pointer = (this.pointer & 0x00ffff) | ((value & 0x0f) << 16);
	    }
	    setPointerLo(value) {
	        this.pointer = (this.pointer & 0x0f00ff) | ((value & 0xff) << 8);
	    }
	    setFraction(value) {
	        this.fraction = value;
	        this.pointer &= 0x0fff00;
	    }
	    increment() {
	        this.pointer = (this.pointer + this.fraction) & 0x0fffff;
	    }
	}
	class MusicFetcher {
	    constructor() {
	        this.frequency = ~0;
	        this.counter = ~0;
	        this.waveform = 0;
	        this.reset();
	    }
	    reset() {
	        this.frequency = 0;
	        this.waveform = 0;
	        this.counter = 0;
	    }
	    increment(clocks) {
	        this.counter = (this.counter + clocks * this.frequency) | 0;
	    }
	    waveformSample() {
	        return this.counter >>> 27;
	    }
	}

	class CartridgeCDF extends AbstractCartridge {
	    constructor(buffer) {
	        super();
	        this._handleBxCDF0 = (address) => {
	            const thumbulator = this._soc.getThumbulator(), r2 = thumbulator.readRegister(2), r3 = thumbulator.readRegister(3);
	            switch (address) {
	                case 0x000006e2:
	                    this._musicStreams[r2 % 3].frequency = r3;
	                    return 0;
	                case 0x000006e6:
	                    this._musicStreams[r2 % 3].counter = 0;
	                    return 0;
	                case 0x000006ea:
	                    thumbulator.writeRegister(2, this._musicStreams[r2 % 3].counter);
	                    return 0;
	                case 0x000006ee:
	                    this._musicStreams[r2 % 3].waveformSize = r3;
	                    return 0;
	            }
	            return 3;
	        };
	        this._handleBxCDF1 = (address) => {
	            const thumbulator = this._soc.getThumbulator(), r2 = thumbulator.readRegister(2), r3 = thumbulator.readRegister(3);
	            switch (address) {
	                case 0x00000752:
	                    this._musicStreams[r2 % 3].frequency = r3;
	                    return 0;
	                case 0x00000756:
	                    this._musicStreams[r2 % 3].counter = 0;
	                    return 0;
	                case 0x0000075a:
	                    thumbulator.writeRegister(2, this._musicStreams[r2 % 3].counter);
	                    return 0;
	                case 0x0000075e:
	                    this._musicStreams[r2 % 3].waveformSize = r3;
	                    return 0;
	            }
	            return 3;
	        };
	        this._banks = new Array(7);
	        this._currentBank = null;
	        this._rom = null;
	        this._ram = null;
	        this._displayRam = null;
	        this._musicStreams = new Array(3);
	        this._clockAccumulator = 0;
	        this._lastCpuTime = 0;
	        this._soc = null;
	        this._fastFetch = false;
	        this._digitalAudio = false;
	        this._fastJumpCountdown = 0;
	        this._fastFetchPending = false;
	        this._jmpOperandAddress = 0;
	        this._ldaOperandAddress = 0;
	        this._datastreamBase = 0;
	        this._datastreamIncrementBase = 0;
	        this._waveformBase = 0;
	        this._jumpstream = 0;
	        this._jumpstreamMask = 0;
	        this._amplitudeStream = 0;
	        this._bus = null;
	        this._cpuTimeProvider = null;
	        const version = CartridgeCDF.getVersion(buffer);
	        switch (version) {
	            case 0:
	                this._jumpstreamMask = 0xff;
	                this._amplitudeStream = 34;
	                this._datastreamBase = 0x06e0;
	                this._datastreamIncrementBase = 0x0768;
	                this._waveformBase = 0x7f0;
	                break;
	            case 1:
	                this._jumpstreamMask = 0xff;
	                this._amplitudeStream = 34;
	                this._datastreamBase = 0x00a0;
	                this._datastreamIncrementBase = 0x0128;
	                this._waveformBase = 0x01b0;
	                break;
	            case 2:
	                this._jumpstreamMask = 0xfe;
	                this._amplitudeStream = 35;
	                this._datastreamBase = 0x0098;
	                this._datastreamIncrementBase = 0x0124;
	                this._waveformBase = 0x01b0;
	                break;
	            default:
	                throw new Error('not a CDF image: missing signature');
	        }
	        if (buffer.length !== 0x8000) {
	            throw new Error(`not a CDF image: invalid lenght ${buffer.length}`);
	        }
	        this._soc = new Soc(version === 0 ? this._handleBxCDF0 : this._handleBxCDF1);
	        this._soc.trap.addHandler(message => this.triggerTrap(2, message));
	        this._rom = this._soc.getRom();
	        for (let i = 0; i < 0x8000; i++) {
	            this._rom[i] = buffer[i];
	        }
	        for (let i = 0; i < 7; i++) {
	            this._banks[i] = new Uint8Array(this._rom.buffer, 0x1000 * (i + 1), 0x1000);
	        }
	        this._ram = this._soc.getRam();
	        this._displayRam = new Uint8Array(this._soc.getRam().buffer, 0x0800, 0x1000);
	        for (let i = 0; i < 3; i++) {
	            this._musicStreams[i] = new MusicStream();
	        }
	        this.reset();
	    }
	    static getVersion(buffer) {
	        const sig = 'CDF'.split('').map(x => x.charCodeAt(0)), startAddress = searchForSignature(buffer, [...sig, -1, ...sig, -1, ...sig]);
	        if (startAddress < 0) {
	            return 3;
	        }
	        switch (buffer[startAddress + 3]) {
	            case 0:
	                return 0;
	            case 1:
	                return 1;
	            case 'J'.charCodeAt(0):
	                return 2;
	            default:
	                return 3;
	        }
	    }
	    static matchesBuffer(buffer) {
	        return CartridgeCDF.getVersion(buffer) !== 3;
	    }
	    init() {
	        return this._soc.init();
	    }
	    reset() {
	        for (let i = 0; i < 0x0200; i++) {
	            this._soc.setRam32(i << 2, this._soc.getRom32(i << 2));
	        }
	        this._fastFetch = false;
	        this._digitalAudio = false;
	        this._fastJumpCountdown = 0;
	        this._fastFetchPending = false;
	        this._jmpOperandAddress = 0;
	        this._ldaOperandAddress = 0;
	        this._currentBank = this._banks[6];
	        for (let i = 0; i < 3; i++) {
	            this._musicStreams[i].reset();
	        }
	        this._lastCpuTime = 0;
	        this._clockAccumulator = 0;
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_cdf;
	    }
	    setBus(bus) {
	        this._bus = bus;
	        return this;
	    }
	    setCpuTimeProvider(provider) {
	        this._cpuTimeProvider = provider;
	        return this;
	    }
	    read(address) {
	        return this._access(address, this._bus.getLastDataBusValue());
	    }
	    peek(address) {
	        return this._currentBank[address & 0x0fff];
	    }
	    write(address, value) {
	        this._access(address, value);
	    }
	    _access(address, value) {
	        address &= 0x0fff;
	        const romValue = this._currentBank[address];
	        if (this._fastJumpCountdown-- > 0 && address === this._jmpOperandAddress) {
	            this._jmpOperandAddress++;
	            return this._datastreamReadWithIncrement(this._jumpstream, 0x0100);
	        }
	        if (this._fastFetch &&
	            romValue === 0x4c &&
	            (this._currentBank[(address + 1) & 0x0fff] & this._jumpstreamMask) === 0 &&
	            this._currentBank[(address + 2) & 0x0fff] === 0) {
	            this._fastJumpCountdown = 2;
	            this._jmpOperandAddress = (address + 1) & 0x0fff;
	            this._jumpstream = 33 + this._currentBank[(address + 1) & 0x0fff];
	            return romValue;
	        }
	        this._fastJumpCountdown = 0;
	        if (this._fastFetch &&
	            this._fastFetchPending &&
	            this._ldaOperandAddress === address &&
	            romValue <= this._amplitudeStream) {
	            this._fastFetchPending = false;
	            if (romValue === this._amplitudeStream) {
	                this._clockMusicStreams();
	                if (this._digitalAudio) {
	                    const counter = this._musicStreams[0].counter, sampleAddress = this._soc.getRam32(this._waveformBase) + (counter >>> 21);
	                    let sample = 0;
	                    if (sampleAddress < 0x8000) {
	                        sample = this._rom[sampleAddress];
	                    }
	                    if (sampleAddress > 0x40000000 && sampleAddress < 0x40002000) {
	                        sample = this._ram[sampleAddress - 0x40000000];
	                    }
	                    if ((counter & 0x100000) === 0) {
	                        sample >>>= 4;
	                    }
	                    return sample & 0x0f;
	                }
	                else {
	                    let acc = 0;
	                    for (let i = 0; i < 3; i++) {
	                        acc += this._displayRam[(this._getWaveform(i) +
	                            (this._musicStreams[i].counter >>> this._musicStreams[i].waveformSize)) &
	                            0x0fff];
	                    }
	                    return acc;
	                }
	            }
	            return this._datastreamRead(romValue);
	        }
	        this._fastFetchPending = false;
	        if (address >= 0x0ff0) {
	            switch (address) {
	                case 0x0ff0:
	                    this._datastreamWriteWithIncrement(32, value, 0x0100);
	                    break;
	                case 0x0ff1: {
	                    let pointer = this._getDatastreamPointer(32);
	                    pointer <<= 8;
	                    pointer &= 0xf0000000;
	                    pointer |= value << 20;
	                    this._setDatastreamPointer(32, pointer);
	                    break;
	                }
	                case 0x0ff2:
	                    this._fastFetch = (value & 0x0f) === 0;
	                    this._digitalAudio = (value & 0xf0) === 0;
	                    break;
	                case 0x0ff3:
	                    switch (value) {
	                        case 254:
	                        case 255:
	                            this._soc.run(0x080b);
	                            break;
	                    }
	                    break;
	            }
	            if (address > 0x0ff4 && address < 0x0ffc) {
	                this._currentBank = this._banks[address - 0x0ff5];
	            }
	        }
	        if (this._fastFetch && romValue === 0xa9) {
	            this._fastFetchPending = true;
	            this._ldaOperandAddress = (address + 1) & 0x0fff;
	        }
	        return romValue;
	    }
	    _clockMusicStreams() {
	        const cpuTime = this._cpuTimeProvider();
	        this._clockAccumulator += (cpuTime - this._lastCpuTime) * 20000;
	        this._lastCpuTime = cpuTime;
	        const clocks = Math.floor(this._clockAccumulator);
	        this._clockAccumulator -= clocks;
	        if (clocks === 0) {
	            return;
	        }
	        for (let i = 0; i < 3; i++) {
	            this._musicStreams[i].increment(clocks);
	        }
	    }
	    _getDatastreamPointer(stream) {
	        return this._soc.getRam32(this._datastreamBase + 4 * stream);
	    }
	    _setDatastreamPointer(stream, value) {
	        this._soc.setRam32(this._datastreamBase + 4 * stream, value);
	    }
	    _getDatastreamIncrement(stream) {
	        return this._soc.getRam32(this._datastreamIncrementBase + 4 * stream);
	    }
	    _datastreamRead(stream) {
	        const pointer = this._getDatastreamPointer(stream), value = this._displayRam[pointer >>> 20];
	        this._setDatastreamPointer(stream, (pointer + (this._getDatastreamIncrement(stream) << 12)) | 0);
	        return value;
	    }
	    _datastreamReadWithIncrement(stream, increment) {
	        const pointer = this._getDatastreamPointer(stream), value = this._displayRam[pointer >>> 20];
	        this._setDatastreamPointer(stream, (pointer + (increment << 12)) | 0);
	        return value;
	    }
	    _datastreamWriteWithIncrement(stream, value, increment) {
	        const pointer = this._getDatastreamPointer(stream);
	        this._displayRam[pointer >>> 20] = value;
	        this._setDatastreamPointer(stream, (pointer + (increment << 12)) | 0);
	    }
	    _getWaveform(index) {
	        const value = this._soc.getRam32(this._waveformBase + 4 * index);
	        return (value - 0x40000000 - 0x0800) & 0x0fff;
	    }
	}
	class MusicStream {
	    constructor() {
	        this.counter = 0;
	        this.frequency = 0;
	        this.waveformSize = 27;
	    }
	    reset() {
	        this.counter = this.frequency = 0;
	        this.waveformSize = 27;
	    }
	    increment(clocks) {
	        this.counter = (this.counter + clocks * this.frequency) | 0;
	    }
	}

	class Cartridge8040 extends AbstractCartridge {
	    constructor(buffer) {
	        super();
	        this._bank = null;
	        this._bank0 = new Uint8Array(0x1000);
	        this._bank1 = new Uint8Array(0x1000);
	        this._bus = null;
	        if (buffer.length !== 0x2000) {
	            throw new Error(`buffer is not an 8k cartridge image: wrong length ${buffer.length}`);
	        }
	        for (let i = 0; i < 0x1000; i++) {
	            this._bank0[i] = buffer[i];
	            this._bank1[i] = buffer[0x1000 + i];
	        }
	        this.reset();
	    }
	    static matchesBuffer(buffer) {
	        const signatureCounts = searchForSignatures(buffer, [
	            [0xad, 0x00, 0x08],
	            [0xad, 0x40, 0x08],
	            [0x2c, 0x00, 0x08],
	            [0x0c, 0x00, 0x08, 0x4c],
	            [0x0c, 0xff, 0x0f, 0x4c]
	        ]);
	        for (const count of signatureCounts) {
	            if (count >= 2) {
	                return true;
	            }
	        }
	        return false;
	    }
	    reset() {
	        this._bank = this._bank0;
	    }
	    read(address) {
	        return this.peek(address);
	    }
	    peek(address) {
	        address &= 0x0fff;
	        return this._bank[address];
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_8k_econobanking;
	    }
	    setBus(bus) {
	        this._bus = bus;
	        this._bus.event.read.addHandler(this._onBusAccess, this);
	        this._bus.event.write.addHandler(this._onBusAccess, this);
	        return this;
	    }
	    _onBusAccess(accessType, self) {
	        const address = self._bus.getLastAddresBusValue() & 0x1840;
	        switch (address) {
	            case 0x0800:
	                self._bank = self._bank0;
	                break;
	            case 0x0840:
	                self._bank = self._bank1;
	                break;
	        }
	    }
	}

	class CartridgePP extends AbstractCartridge {
	    constructor(buffer) {
	        super();
	        this._banks = new Array(8);
	        this._segments = new Array(4);
	        this._ram = new Uint8Array(0x40);
	        this._bankSwitchPending = false;
	        this._pendingBank = 0;
	        this._accessCounter = 0;
	        this._previousAddressBusValue = 0;
	        if (buffer.length !== 0x2000 && buffer.length !== 0x2003) {
	            throw new Error(`buffer is not a PP cartridge image; wrong length ${buffer.length} bytes`);
	        }
	        for (let i = 0; i < 8; i++) {
	            this._banks[i] = new Uint8Array(0x0400);
	            for (let j = 0; j < 0x0400; j++) {
	                this._banks[i][j] = buffer[i * 0x0400 + j];
	            }
	        }
	        this.reset();
	    }
	    getType() {
	        return CartridgeInfo.CartridgeType.bankswitch_8k_pp;
	    }
	    reset() {
	        this._switchLayout(0);
	        this._bankSwitchPending = false;
	    }
	    randomize(rng) {
	        for (let i = 0; i < 0x40; i++) {
	            this._ram[i] = rng.int(0xff);
	        }
	    }
	    setBus(bus) {
	        this._bus = bus;
	        bus.event.read.addHandler(CartridgePP._onBusAccess, this);
	        bus.event.write.addHandler(CartridgePP._onBusAccess, this);
	        return this;
	    }
	    read(address) {
	        address &= 0x0fff;
	        this._access(address, this._bus.getLastDataBusValue());
	        if (address < 0x40) {
	            return this._ram[address];
	        }
	        if (address < 0x80) {
	            return this._bus.getLastDataBusValue();
	        }
	        return this._segments[address >>> 10][address & 0x03ff];
	    }
	    write(address, value) {
	        this._access(address & 0x0fff, value);
	    }
	    peek(address) {
	        address &= 0x0fff;
	        if (address < 0x40) {
	            return this._ram[address];
	        }
	        if (address < 0x80) {
	            return this._bus.getLastDataBusValue();
	        }
	        return this._segments[address >>> 10][address & 0x03ff];
	    }
	    static _onBusAccess(accessType, self) {
	        let address = self._bus.getLastAddresBusValue();
	        if (self._bankSwitchPending && address !== self._previousAddressBusValue && --self._accessCounter === 0) {
	            self._switchLayout(self._pendingBank);
	            self._bankSwitchPending = false;
	        }
	        if (address & 0x1000) {
	            return;
	        }
	        address &= 0xff;
	        if (address >= 0x30 && address <= 0x3f) {
	            self._pendingBank = address & 0x0f;
	            self._accessCounter = 3;
	            self._bankSwitchPending = true;
	        }
	    }
	    _access(address, value) {
	        if (address >= 0x40 && address < 0x80) {
	            this._ram[address - 0x40] = value;
	        }
	    }
	    _switchLayout(index) {
	        switch (index) {
	            case 0:
	            case 8:
	                return this._configureSegments(0, 0, 1, 2);
	            case 1:
	            case 9:
	                return this._configureSegments(0, 1, 3, 2);
	            case 2:
	            case 10:
	                return this._configureSegments(4, 5, 6, 7);
	            case 3:
	            case 11:
	                return this._configureSegments(7, 4, 3, 2);
	            case 4:
	            case 12:
	                return this._configureSegments(0, 0, 6, 7);
	            case 5:
	            case 13:
	                return this._configureSegments(0, 1, 7, 6);
	            case 6:
	            case 14:
	                return this._configureSegments(3, 2, 4, 5);
	            case 7:
	            case 15:
	                return this._configureSegments(6, 0, 5, 1);
	            default:
	                throw new Error('illegal layout index');
	        }
	    }
	    _configureSegments(zero, one, two, three) {
	        this._segments[0] = this._banks[zero];
	        this._segments[1] = this._banks[one];
	        this._segments[2] = this._banks[two];
	        this._segments[3] = this._banks[three];
	    }
	}

	class CartridgeDetector {
	    detectCartridgeType(buffer) {
	        if (buffer.length % 8448 === 0) {
	            return CartridgeInfo.CartridgeType.bankswitch_supercharger;
	        }
	        if (buffer.length < 0x0800) {
	            return CartridgeInfo.CartridgeType.vanilla_2k;
	        }
	        if (buffer.length >= 10240 && buffer.length <= 10496) {
	            return CartridgeInfo.CartridgeType.bankswitch_8k_DPC;
	        }
	        switch (buffer.length) {
	            case 0x0800:
	                return this._detect2k(buffer);
	            case 0x1000:
	                return CartridgeInfo.CartridgeType.vanilla_4k;
	            case 0x2000:
	                return this._detect8k(buffer);
	            case 0x2003:
	                return CartridgeInfo.CartridgeType.bankswitch_8k_pp;
	            case 0x3000:
	                return CartridgeInfo.CartridgeType.bankswitch_12k_FA;
	            case 0x4000:
	                return this._detect16k(buffer);
	            case 0x7000:
	                return CartridgeInfo.CartridgeType.bankswitch_FA2;
	            case 0x7400:
	                return this._detect29k(buffer);
	            case 0x8000:
	                return this._detect32k(buffer);
	            case 0x10000:
	                return this._detect64k(buffer);
	            default:
	                return CartridgeInfo.CartridgeType.unknown;
	        }
	    }
	    _detect2k(buffer) {
	        if (CartridgeCV.matchesBuffer(buffer)) {
	            return CartridgeInfo.CartridgeType.bankswitch_2k_cv;
	        }
	        return CartridgeInfo.CartridgeType.vanilla_2k;
	    }
	    _detect8k(buffer) {
	        const f8Matches = CartridgeF8.matchesBuffer(buffer);
	        if (CartridgeE0.matchesBuffer(buffer)) {
	            return CartridgeInfo.CartridgeType.bankswitch_8k_E0;
	        }
	        if (Cartridge3F.matchesBuffer(buffer)) {
	            return CartridgeInfo.CartridgeType.bankswitch_8k_3F;
	        }
	        if (CartridgeUA.matchesBuffer(buffer)) {
	            return CartridgeInfo.CartridgeType.bankswitch_8k_UA;
	        }
	        if (!f8Matches && CartridgeFE.matchesBuffer(buffer)) {
	            return CartridgeInfo.CartridgeType.bankswitch_8k_FE;
	        }
	        if (Cartridge8040.matchesBuffer(buffer)) {
	            return CartridgeInfo.CartridgeType.bankswitch_8k_econobanking;
	        }
	        return CartridgeInfo.CartridgeType.bankswitch_8k_F8;
	    }
	    _detect16k(buffer) {
	        if (CartrdigeE7.matchesBuffer(buffer)) {
	            return CartridgeInfo.CartridgeType.bankswitch_16k_E7;
	        }
	        return CartridgeInfo.CartridgeType.bankswitch_16k_F6;
	    }
	    _detect29k(buffer) {
	        if (CartridgeFA2.matchesBuffer(buffer)) {
	            return CartridgeInfo.CartridgeType.bankswitch_FA2;
	        }
	        return CartridgeInfo.CartridgeType.bankswitch_dpc_plus;
	    }
	    _detect32k(buffer) {
	        if (Cartridge3E.matchesBuffer(buffer)) {
	            return CartridgeInfo.CartridgeType.bankswitch_3E;
	        }
	        if (CartridgeDPCPlus.matchesBuffer(buffer)) {
	            return CartridgeInfo.CartridgeType.bankswitch_dpc_plus;
	        }
	        if (CartridgeCDF.matchesBuffer(buffer)) {
	            return CartridgeInfo.CartridgeType.bankswitch_cdf;
	        }
	        return CartridgeInfo.CartridgeType.bankswitch_32k_F4;
	    }
	    _detect64k(buffer) {
	        if (CartridgeEF.matchesBuffer(buffer)) {
	            return CartridgeInfo.CartridgeType.bankswitch_64k_EF;
	        }
	        return CartridgeInfo.CartridgeType.bankswitch_64k_F0;
	    }
	}

	class CartridgeFactory {
	    createCartridge(buffer, cartridgeType) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const cartridge = this._createCartridge(buffer, cartridgeType);
	            yield cartridge.init();
	            return cartridge;
	        });
	    }
	    _createCartridge(buffer, cartridgeType) {
	        if (typeof cartridgeType === 'undefined') {
	            const detector = new CartridgeDetector();
	            cartridgeType = detector.detectCartridgeType(buffer);
	        }
	        switch (cartridgeType) {
	            case CartridgeInfo.CartridgeType.vanilla_2k:
	                return new Cartridge2k(buffer);
	            case CartridgeInfo.CartridgeType.vanilla_4k:
	                return new Cartridge4k(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_2k_cv:
	                return new CartridgeCV(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_8k_F8:
	                return new CartridgeF8(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_8k_E0:
	                return new CartridgeE0(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_8k_3F:
	                return new Cartridge3F(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_8k_FE:
	                return new CartridgeFE(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_8k_UA:
	                return new CartridgeUA(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_8k_DPC:
	                return new CartridgeDPC(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_8k_econobanking:
	                return new Cartridge8040(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_8k_pp:
	                return new CartridgePP(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_12k_FA:
	                return new CartridgeFA(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_16k_F6:
	                return new CartridgeF6(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_16k_E7:
	                return new CartrdigeE7(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_FA2:
	                return new CartridgeFA2(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_32k_F4:
	                return new CartridgeF4(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_64k_F0:
	                return new CartridgeF0(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_64k_EF:
	                return new CartridgeEF(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_3E:
	                return new Cartridge3E(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_supercharger:
	                return new CartridgeSupercharger(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_dpc_plus:
	                return new CartridgeDPCPlus(buffer);
	            case CartridgeInfo.CartridgeType.bankswitch_cdf:
	                return new CartridgeCDF(buffer);
	            default:
	                throw new Error(`invalid or unsupported cartridge image`);
	        }
	    }
	}

	class AsyncIO {
	    constructor(_board) {
	        this._board = _board;
	        this.message = new lib_1();
	        this._bufferOut = new Uint8Array(256);
	        this._bufferIn = new Uint8Array(256);
	        this._indexBufferOut = 0;
	        this._indexBufferIn = -1;
	        this._bus = null;
	        this._bus = this._board.getBus();
	        this._board.systemReset.addHandler(AsyncIO._onReset, this);
	        this._bus.event.write.addHandler(AsyncIO._onWrite, this);
	        this._bus.event.read.addHandler(AsyncIO._onRead, this);
	        this.reset();
	    }
	    reset() {
	        for (let i = 0; i < this._bufferOut.length; i++) {
	            this._bufferOut[i] = 0;
	        }
	        this._indexBufferOut = 0;
	        return this;
	    }
	    send(message) {
	        this._indexBufferIn = message.length > 256 ? 255 : message.length - 1;
	        for (let i = 0; i <= this._indexBufferIn; i++) {
	            this._bufferIn[i] = message[i];
	        }
	    }
	    static _onWrite(accessType, self) {
	        if (accessType !== 0) {
	            return;
	        }
	        switch (self._bus.getLastAddresBusValue()) {
	            case 0x30:
	                self._bufferOut[self._indexBufferOut] = self._bus.getLastDataBusValue();
	                self._indexBufferOut = (self._indexBufferOut + 1) % self._bufferOut.length;
	                break;
	            case 0x31: {
	                const count = self._bus.getLastDataBusValue();
	                const data = new Uint8Array(count);
	                for (let i = 0; i < count; i++) {
	                    const j = (self._indexBufferOut - 1 + self._bufferOut.length) % self._bufferOut.length;
	                    data[count - i - 1] = self._bufferOut[j];
	                    self._indexBufferOut = j;
	                }
	                self.message.dispatch(data);
	                break;
	            }
	        }
	    }
	    static _onRead(accessType, self) {
	        if (accessType !== 0) {
	            return;
	        }
	        switch (self._bus.getLastAddresBusValue()) {
	            case 0x30:
	                self._bus.setDataBusValue(self._indexBufferIn >= 0 ? self._bufferIn[self._indexBufferIn--] : 0);
	                break;
	            case 0x31: {
	                self._bus.setDataBusValue(self._indexBufferIn >= 0 ? self._indexBufferIn + 1 : 0);
	                break;
	            }
	        }
	    }
	    static _onReset(payload, self) {
	        self.reset();
	    }
	}

	class PeriodicScheduler {
	    constructor(_period) {
	        this._period = _period;
	    }
	    setPeriod(period) {
	        this._period = period;
	        return this;
	    }
	    getPeriod() {
	        return this._period;
	    }
	    start(worker, context) {
	        let terminate = false;
	        const handler = () => {
	            if (terminate) {
	                return;
	            }
	            worker(context);
	            setTimeout(handler, this._period);
	        };
	        setTimeout(handler, this._period);
	        return {
	            stop: () => (terminate = true)
	        };
	    }
	}

	var setImmediate = createCommonjsModule(function (module, exports) {
	(function (global, factory) {
		 module.exports = factory() ;
	}(commonjsGlobal, (function () {
	var context = (function () {
	  /* eslint no-eval: 0 */
	  return this || (0, eval)('this');
	})();

	// @see http://codeforhire.com/2013/09/21/setimmediate-and-messagechannel-broken-on-internet-explorer-10/
	var useNative = (function () {
	  return !(context.navigator && /Trident|Edge/.test(context.navigator.userAgent));
	})();

	var nextId = 1;
	var lock = false;
	var TASKS = {};

	function wrap(handler) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  var len = args.length;

	  return !len ? function () {
	    return handler.call(undefined);
	  } : len === 1 ? function () {
	    return handler.call(undefined, args[0]);
	  } : len === 2 ? function () {
	    return handler.call(undefined, args[0], args[1]);
	  } : len === 3 ? function () {
	    return handler.call(undefined, args[0], args[1], args[2]);
	  } : function () {
	    return handler.apply(undefined, args);
	  };
	}

	function create(args) {
	  TASKS[nextId] = wrap.apply(undefined, args);
	  return nextId++;
	}

	function clear(handleId) {
	  delete TASKS[handleId];
	}

	function run(handleId) {
	  if (lock) {
	    context.setTimeout(wrap(run, handleId), 0);
	  } else {
	    var task = TASKS[handleId];

	    if (task) {
	      lock = true;

	      try {
	        task();
	      } finally {
	        clear(handleId);
	        lock = false;
	      }
	    }
	  }
	}

	function init() {
	  var polifill = function polifill() {
	    var handleId = create(arguments);
	    context.setTimeout(wrap(run, handleId), 0);
	    return handleId;
	  };

	  polifill.usePolifill = 'setTimeout';

	  return polifill;
	}

	function canUse() {
	  return 'setTimeout' in context;
	}

	var setTimeoutPolifill = Object.freeze({
		init: init,
		canUse: canUse
	});

	function init$1() {
	  var polifill = function polifill() {
	    var handleId = create(arguments);
	    context.process.nextTick(wrap(run, handleId));
	    return handleId;
	  };

	  polifill.usePolifill = 'nextTick';

	  return polifill;
	}

	// Don't get fooled by e.g. browserify environments.
	// For Node.js before 0.9
	function canUse$1() {
	  return Object.prototype.toString.call(context.process) === '[object process]';
	}

	var nextTickPolifill = Object.freeze({
		init: init$1,
		canUse: canUse$1
	});

	function init$2() {
	  var messagePrefix = 'setImmediate$' + Math.random() + '$';

	  var onGlobalMessage = function onGlobalMessage(event) {
	    if (event.source === context && typeof event.data === 'string' && event.data.indexOf(messagePrefix) === 0) {

	      run(Number(event.data.slice(messagePrefix.length)));
	    }
	  };

	  if (context.addEventListener) {
	    context.addEventListener('message', onGlobalMessage, false);
	  } else {
	    context.attachEvent('onmessage', onGlobalMessage);
	  }

	  var polifill = function polifill() {
	    var handleId = create(arguments);
	    context.postMessage(messagePrefix + handleId, '*');
	    return handleId;
	  };

	  polifill.usePolifill = 'postMessage';

	  return polifill;
	}

	// For non-IE10 modern browsers
	function canUse$2() {
	  if (context.importScripts || !context.postMessage) {
	    return false;
	  }

	  if (context.navigator && /Chrome/.test(context.navigator.userAgent)) {
	    //skip this method due to heavy minor GC on heavy use.
	    return false;
	  }

	  var asynch = true;
	  var oldOnMessage = context.onmessage;
	  context.onmessage = function () {
	    asynch = false;
	  };

	  context.postMessage('', '*');
	  context.onmessage = oldOnMessage;
	  return asynch;
	}

	var postMessagePolifill = Object.freeze({
		init: init$2,
		canUse: canUse$2
	});

	function init$3() {
	  var channel = new context.MessageChannel();

	  channel.port1.onmessage = function (event) {
	    run(Number(event.data));
	  };

	  var polifill = function polifill() {
	    var handleId = create(arguments);
	    channel.port2.postMessage(handleId);
	    return handleId;
	  };

	  polifill.usePolifill = 'messageChannel';

	  return polifill;
	}

	// For web workers, where supported
	function canUse$3() {
	  return Boolean(context.MessageChannel);
	}

	var messageChannelPolifill = Object.freeze({
		init: init$3,
		canUse: canUse$3
	});

	function init$4() {
	  var html = context.document.documentElement;

	  var polifill = function polifill() {
	    var handleId = create(arguments);
	    var script = context.document.createElement('script');

	    script.onreadystatechange = function () {
	      run(handleId);
	      script.onreadystatechange = null;
	      html.removeChild(script);
	      script = null;
	    };

	    html.appendChild(script);
	    return handleId;
	  };

	  polifill.usePolifill = 'readyStateChange';

	  return polifill;
	}

	// For IE 6–8
	function canUse$4() {
	  return context.document && 'onreadystatechange' in context.document.createElement('script');
	}

	var readyStateChangePolifill = Object.freeze({
		init: init$4,
		canUse: canUse$4
	});

	var POLIFILLS = [nextTickPolifill, postMessagePolifill, messageChannelPolifill, readyStateChangePolifill];

	var setImmediate = useNative ? context.setImmediate || context.msSetImmediate || usePolifill(POLIFILLS, setTimeoutPolifill) : init();

	var clearImmediate = useNative ? context.clearImmediate || context.msClearImmediate || clear : clear;

	function polifill() {
	  if (context.setImmediate !== setImmediate) {
	    context.setImmediate = setImmediate;
	    context.msSetImmediate = setImmediate;
	    context.clearImmediate = clearImmediate;
	    context.msClearImmediate = clearImmediate;
	  }
	}

	function usePolifill(list, def) {
	  for (var i = 0; i < list.length; i++) {
	    var _polifill = list[i];
	    if (_polifill.canUse()) {
	      return _polifill.init();
	    }
	  }

	  return def.init();
	}

	var index = {
	  setImmediate: setImmediate,
	  clearImmediate: clearImmediate,
	  polifill: polifill
	};

	return index;

	})));

	});
	var setImmediate_1 = setImmediate.setImmediate;

	let index = 0;
	function setImmediate$1(callback) {
	    if (index === 0) {
	        setTimeout(callback, 0);
	    }
	    else {
	        setImmediate_1(callback);
	    }
	    index = (index + 1) % 10;
	}

	class ImmediateScheduler {
	    start(worker, context) {
	        let terminate = false;
	        function handler() {
	            if (terminate) {
	                return;
	            }
	            worker(context);
	            setImmediate$1(handler);
	        }
	        setImmediate$1(handler);
	        return {
	            stop: () => (terminate = true)
	        };
	    }
	}

	const getTimestamp = self.performance && self.performance.now
	    ? () => self.performance.now()
	    : () => Date.now();

	const THRESHOLD = 1;
	class ConstantTimesliceScheduler {
	    start(worker, context, _timeSlice) {
	        const timeSlice = _timeSlice || 50;
	        let running = true;
	        function handler() {
	            if (!running) {
	                return;
	            }
	            const timestampStart = getTimestamp();
	            let emulationTime = 0, delta = 0;
	            while (getTimestamp() - timestampStart < timeSlice) {
	                do {
	                    delta = getTimestamp() - timestampStart - emulationTime;
	                } while (delta < THRESHOLD);
	                emulationTime += worker(context, delta);
	            }
	            delta = getTimestamp() - timestampStart - emulationTime;
	            if (delta > 0) {
	                emulationTime += worker(context, delta);
	            }
	            if (running) {
	                setImmediate$1(handler);
	            }
	        }
	        setImmediate$1(handler);
	        return { stop: () => (running = false) };
	    }
	}

	const CORRECTION_THESHOLD = 3, MAX_ACCUMULATED_DELTA = 100;
	class ConstantCyclesScheduler {
	    start(worker, context) {
	        let terminate = false, targetSleepInterval = -1, lastYieldTimestamp = 0, accumulatedDelta = 0;
	        function handler() {
	            if (terminate) {
	                return;
	            }
	            const timestamp0 = getTimestamp(), targetDuration = worker(context) || 0, timestamp1 = getTimestamp();
	            let delay = targetDuration - timestamp1 + timestamp0;
	            if (targetSleepInterval >= 0) {
	                accumulatedDelta += targetSleepInterval - timestamp0 + lastYieldTimestamp;
	            }
	            if (accumulatedDelta > MAX_ACCUMULATED_DELTA) {
	                accumulatedDelta = MAX_ACCUMULATED_DELTA;
	            }
	            else if (accumulatedDelta < -MAX_ACCUMULATED_DELTA) {
	                accumulatedDelta = -MAX_ACCUMULATED_DELTA;
	            }
	            if (Math.abs(accumulatedDelta) > CORRECTION_THESHOLD) {
	                delay += accumulatedDelta;
	                accumulatedDelta = 0;
	            }
	            if (delay < 0) {
	                delay = 0;
	                accumulatedDelta = delay;
	            }
	            if (delay > 0) {
	                setTimeout(handler, Math.round(delay));
	            }
	            else {
	                setImmediate$1(handler);
	            }
	            targetSleepInterval = delay;
	            lastYieldTimestamp = getTimestamp();
	        }
	        setImmediate$1(handler);
	        return {
	            stop: () => (terminate = true)
	        };
	    }
	}

	const SAFETY_FACTOR = 3;
	class ConstantTimesliceScheduler$1 {
	    start(worker, context, _timeSlice) {
	        const timeSlice = _timeSlice || 100;
	        let timestamp0 = getTimestamp(), emulationTime = 0, running = true;
	        function handler() {
	            if (!running) {
	                return;
	            }
	            const timestamp = getTimestamp();
	            let delta = timestamp - timestamp0 - emulationTime;
	            if (delta > SAFETY_FACTOR * timeSlice) {
	                delta = SAFETY_FACTOR * timeSlice;
	                timestamp0 = timestamp - delta;
	                emulationTime = 0;
	            }
	            emulationTime += worker(context, delta);
	            const timeToSleep = timeSlice - getTimestamp() + timestamp;
	            if (timeToSleep > 0) {
	                setTimeout(handler, timeToSleep);
	            }
	            else {
	                setImmediate$1(handler);
	            }
	        }
	        setImmediate$1(handler);
	        return { stop: () => (running = false) };
	    }
	}

	class Factory$1 {
	    createPeriodicScheduler(period) {
	        return new PeriodicScheduler(period);
	    }
	    createImmediateScheduler() {
	        return new ImmediateScheduler();
	    }
	    createLimitingScheduler(strategy = 1) {
	        switch (strategy) {
	            case 0:
	                return new ConstantTimesliceScheduler();
	            case 1:
	                return new ConstantCyclesScheduler();
	            case 2:
	                return new ConstantTimesliceScheduler$1();
	            default:
	                throw new Error('invalud limiting scheduling strategy');
	        }
	    }
	    getLimitingSchedulingStrategies() {
	        return [
	            0,
	            1,
	            2
	        ];
	    }
	    describeLimitingSchedulingStrategy(strategy) {
	        switch (strategy) {
	            case 0:
	                return 'Busy wait, constant timeslice length';
	            case 1:
	                return 'Constant cycle count';
	            case 2:
	                return 'Constant timeslice length';
	            default:
	                throw new Error('invalid limiting scheduling strategy');
	        }
	    }
	}

	class ClockProbe {
	    constructor(_scheduler) {
	        this._scheduler = _scheduler;
	        this.frequencyUpdate = new lib_1();
	        this._counter = 0;
	        this._frequency = 0;
	    }
	    attach(clock) {
	        if (this._clock) {
	            this.detach();
	        }
	        this._clock = clock;
	        clock.addHandler(this._clockHandler, this);
	        return this;
	    }
	    start() {
	        if (this._measurementTask) {
	            return this;
	        }
	        this._timestamp = Date.now();
	        this._counter = 0;
	        this._measurementTask = this._scheduler.start(this._updateMeasurement, this);
	        return this;
	    }
	    detach() {
	        if (!this._clock) {
	            return this;
	        }
	        this._clock.removeHandler(this._clockHandler, this);
	        this._clock = undefined;
	        return this;
	    }
	    stop() {
	        if (!this._measurementTask) {
	            return this;
	        }
	        this._measurementTask.stop();
	        this._measurementTask = undefined;
	        return this;
	    }
	    getFrequency() {
	        return this._frequency;
	    }
	    _updateMeasurement(probe) {
	        const timestamp = Date.now();
	        probe._frequency = probe._counter / (timestamp - probe._timestamp) * 1000;
	        probe._counter = 0;
	        probe._timestamp = timestamp;
	        probe.frequencyUpdate.dispatch(probe._frequency);
	    }
	    _clockHandler(clocks, ctx) {
	        ctx._counter += clocks;
	    }
	}

	var Mutex_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Mutex = /** @class */ (function () {
	    function Mutex() {
	        this._queue = [];
	        this._pending = false;
	    }
	    Mutex.prototype.isLocked = function () {
	        return this._pending;
	    };
	    Mutex.prototype.acquire = function () {
	        var _this = this;
	        var ticket = new Promise(function (resolve) { return _this._queue.push(resolve); });
	        if (!this._pending) {
	            this._dispatchNext();
	        }
	        return ticket;
	    };
	    Mutex.prototype.runExclusive = function (callback) {
	        return this
	            .acquire()
	            .then(function (release) {
	            var result;
	            try {
	                result = callback();
	            }
	            catch (e) {
	                release();
	                throw (e);
	            }
	            return Promise
	                .resolve(result)
	                .then(function (x) { return (release(), x); }, function (e) {
	                release();
	                throw e;
	            });
	        });
	    };
	    Mutex.prototype._dispatchNext = function () {
	        if (this._queue.length > 0) {
	            this._pending = true;
	            this._queue.shift()(this._dispatchNext.bind(this));
	        }
	        else {
	            this._pending = false;
	        }
	    };
	    return Mutex;
	}());
	exports.default = Mutex;
	});

	unwrapExports(Mutex_1);

	var lib$2 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.Mutex = Mutex_1.default;
	});

	unwrapExports(lib$2);
	var lib_1$2 = lib$2.Mutex;

	const CLOCK_UPDATE_INTERVAL = 2000;
	class EmulationService {
	    constructor() {
	        this.stateChanged = new lib_1();
	        this.emulationError = new lib_1();
	        this._enforceRateLimit = true;
	        this._state = EmulationServiceInterface.State.stopped;
	        this._lastError = null;
	        this._scheduler = null;
	        this._clockProbe = new ClockProbe(new PeriodicScheduler(CLOCK_UPDATE_INTERVAL));
	        this._mutex = new lib_1$2();
	        this._schedulerFactory = new Factory$1();
	        this._limitingStrategy = 1;
	        this.frequencyUpdate = this._clockProbe.frequencyUpdate;
	        this._updateScheduler();
	    }
	    init() {
	        return Promise.resolve();
	    }
	    start(buffer, config, cartridgeType) {
	        const factory = new CartridgeFactory();
	        return this._mutex.runExclusive(() => __awaiter(this, void 0, void 0, function* () {
	            try {
	                this._stop();
	                this._limitingStrategy = config.pcmAudio
	                    ? 2
	                    : 1;
	                this._updateScheduler();
	                if (this._state === EmulationServiceInterface.State.error) {
	                    return this._state;
	                }
	                const cartridge = yield factory.createCartridge(buffer, cartridgeType), board = new Board(config, cartridge);
	                this._board = board;
	                this._board.trap.addHandler(EmulationService._trapHandler, this);
	                if (config.asyncIO) {
	                    this._asyncIO = new AsyncIO(board);
	                }
	                this._context = new EmulationContext(board, this._asyncIO);
	                this._clockProbe.attach(this._board.clock);
	                this._setState(EmulationServiceInterface.State.paused);
	            }
	            catch (e) {
	                this._setError(e);
	            }
	            return this._state;
	        }));
	    }
	    stop() {
	        return this._mutex.runExclusive(() => this._stop());
	    }
	    pause() {
	        return this._mutex.runExclusive(() => {
	            try {
	                if (this._state === EmulationServiceInterface.State.running) {
	                    this._board.getTimer().stop();
	                    this._board.suspend();
	                    this._setState(EmulationServiceInterface.State.paused);
	                    this._clockProbe.stop();
	                }
	            }
	            catch (e) {
	                this._setError(e);
	            }
	            return this._state;
	        });
	    }
	    resume() {
	        return this._mutex.runExclusive(() => {
	            if (this._state === EmulationServiceInterface.State.paused) {
	                try {
	                    this._tryToResume();
	                }
	                catch (e) {
	                    this._setError(e);
	                }
	            }
	            return this._state;
	        });
	    }
	    reset() {
	        return this._mutex.runExclusive(() => {
	            try {
	                switch (this._state) {
	                    case EmulationServiceInterface.State.running:
	                    case EmulationServiceInterface.State.paused:
	                        this._board.reset();
	                        break;
	                    case EmulationServiceInterface.State.error:
	                        this._board.reset();
	                        this._tryToResume();
	                        break;
	                }
	            }
	            catch (e) {
	                this._setError(e);
	            }
	            return this._state;
	        });
	    }
	    getState() {
	        return this._state;
	    }
	    getEmulationContext() {
	        switch (this._state) {
	            case EmulationServiceInterface.State.running:
	            case EmulationServiceInterface.State.paused:
	                return this._context;
	            default:
	                return null;
	        }
	    }
	    getLastError() {
	        return this._lastError;
	    }
	    getFrequency() {
	        return this._clockProbe.getFrequency();
	    }
	    getRateLimit() {
	        return this._enforceRateLimit;
	    }
	    setRateLimit(enforce) {
	        if (this._enforceRateLimit === enforce) {
	            return Promise.resolve(undefined);
	        }
	        return this._mutex.runExclusive(() => {
	            if (this._state === EmulationServiceInterface.State.running) {
	                this._board.getTimer().stop();
	            }
	            this._enforceRateLimit = enforce;
	            this._updateScheduler();
	            if (this._state === EmulationServiceInterface.State.running) {
	                this._board.getTimer().start(this._scheduler);
	            }
	        });
	    }
	    static _trapHandler(trap, self) {
	        self._setError(new Error(`TRAP: ${trap.message}`));
	        self.emulationError.dispatch(self._lastError);
	    }
	    _stop() {
	        try {
	            if (this._state === EmulationServiceInterface.State.running) {
	                this._board.getTimer().stop();
	                this._board.suspend();
	                this._board.trap.removeHandler(EmulationService._trapHandler, this);
	                this._clockProbe.stop().detach();
	            }
	            this._board = null;
	            this._context = null;
	            this._asyncIO = undefined;
	            this._setState(EmulationServiceInterface.State.stopped);
	        }
	        catch (e) {
	            this._setError(e);
	        }
	        return this._state;
	    }
	    _tryToResume() {
	        if (this._state === EmulationServiceInterface.State.running) {
	            return;
	        }
	        this._board.getTimer().start(this._scheduler);
	        this._board.resume();
	        this._setState(EmulationServiceInterface.State.running);
	        this._clockProbe.start();
	    }
	    _setError(e) {
	        this._lastError = e;
	        this._setState(EmulationServiceInterface.State.error);
	    }
	    _setState(state) {
	        if (state !== this._state) {
	            this._state = state;
	            this.stateChanged.dispatch(state);
	        }
	        return this._state;
	    }
	    _updateScheduler() {
	        this._scheduler = this._enforceRateLimit
	            ? this._schedulerFactory.createLimitingScheduler(this._limitingStrategy)
	            : this._schedulerFactory.createImmediateScheduler();
	    }
	}

	class DriverManager {
	    constructor() {
	        this._drivers = new Map();
	        this._driversBound = false;
	    }
	    bind(emulationService) {
	        if (this._driversBound) {
	            return this;
	        }
	        this._emulationService = emulationService;
	        if (this._shouldBindDrivers()) {
	            this._bindDrivers();
	        }
	        this._emulationService.stateChanged.addHandler(DriverManager._onEmuStateChange, this);
	        return this;
	    }
	    unbind() {
	        if (!this._emulationService) {
	            return this;
	        }
	        this._unbindDrivers();
	        this._emulationService.stateChanged.removeHandler(DriverManager._onEmuStateChange, this);
	        this._emulationService = null;
	        return this;
	    }
	    addDriver(driver, binder) {
	        this._drivers.set(driver, new DriverManager.DriverContext(driver, binder));
	        if (this._driversBound) {
	            binder(this._emulationService.getEmulationContext(), driver);
	        }
	        return this;
	    }
	    removeDriver(driver) {
	        if (!this._drivers.get(driver)) {
	            return this;
	        }
	        driver.unbind();
	        this._drivers.delete(driver);
	        return this;
	    }
	    static _onEmuStateChange(newState, self) {
	        if (self._shouldBindDrivers(newState)) {
	            self._bindDrivers();
	        }
	        else {
	            self._unbindDrivers();
	        }
	    }
	    _shouldBindDrivers(state = this._emulationService ? this._emulationService.getState() : undefined) {
	        return (this._emulationService &&
	            (state === EmulationServiceInterface.State.running || state === EmulationServiceInterface.State.paused));
	    }
	    _bindDrivers() {
	        if (this._driversBound) {
	            return;
	        }
	        this._drivers.forEach(driverContext => driverContext.binder(this._emulationService.getEmulationContext(), driverContext.driver));
	        this._driversBound = true;
	    }
	    _unbindDrivers() {
	        if (!this._driversBound) {
	            return;
	        }
	        this._drivers.forEach(driverContext => driverContext.driver.unbind());
	        this._driversBound = false;
	    }
	}
	(function (DriverManager) {
	    class DriverContext {
	        constructor(driver, binder) {
	            this.driver = driver;
	            this.binder = binder;
	        }
	    }
	    DriverManager.DriverContext = DriverContext;
	})(DriverManager || (DriverManager = {}));

	const RPC_TYPE = {
	    emulationPause: 'emulation/pause',
	    emulationReset: 'emulation/reset',
	    emulationResume: 'emulation/resume',
	    emulationSetRateLimit: 'emulation/setRateLimit',
	    emulationStart: 'emulation/start',
	    emulationStop: 'emulation/stop',
	    emulationFetchLastError: 'emulation/fetchLastError',
	    getVideoParameters: 'video/getParameters',
	    getWaveformAudioParameters: (index) => `audio/waveform/getParameters/${index}`,
	    getPCMAudioParameters: (index) => `audio/pcm/getParameters/${index}`,
	    setup: '/setup'
	};
	Object.freeze(RPC_TYPE);
	const SIGNAL_TYPE = {
	    emulationError: 'emulation/error',
	    emulationFrequencyUpdate: 'emulation/frequencyUpdate',
	    videoNewFrame: 'video/newFrame',
	    videoReturnSurface: 'video/returnSurface',
	    controlStateUpdate: 'control/stateUpdate',
	    waveformAudioVolumeChange: 'audio/waveform/volumeChange',
	    waveformAudioBufferChange: 'audio/waveform/bufferChange',
	    pcmAudioNewFrame: (index) => `audio/pcm/newFrame/${index}`,
	    pcmAudioTogglePause: (index) => `audio/pcm/togglePause/${index}`,
	    pcmAudioReturnFrame: (index) => `audio/pcm/returnFrame/${index}`,
	    audioStop: 'audio/stop',
	    messageFromAsyncIO: 'asyncIO/messageFrom',
	    messageToAsyncIO: 'asyncIO/messageTo'
	};
	Object.freeze(SIGNAL_TYPE);

	class VideoDriver {
	    constructor(_rpc) {
	        this._rpc = _rpc;
	        this._active = false;
	        this._video = null;
	        this._mutex = new lib_1$2();
	        this._surfacePool = null;
	        this._managedSurfacesById = null;
	        this._ids = null;
	        this._width = 0;
	        this._height = 0;
	        this._nextId = 0;
	    }
	    init() {
	        this._rpc
	            .registerSignalHandler(SIGNAL_TYPE.videoReturnSurface, this._onReturnSurfaceFromHost.bind(this))
	            .registerRpcHandler(RPC_TYPE.getVideoParameters, this._onGetVideoParameters.bind(this));
	    }
	    bind(video) {
	        this._mutex.runExclusive(() => this._bind(video));
	    }
	    unbind() {
	        this._mutex.runExclusive(() => this._unbind());
	    }
	    static _onNewFrame(surface, self) {
	        if (!self._active) {
	            console.warn('new frame passed to inactive driver');
	            return;
	        }
	        if (!self._managedSurfaces.has(surface)) {
	            console.warn(`surface not registered`);
	            return;
	        }
	        const buffer = surface.getUnderlyingBuffer(), id = self._ids.get(self._managedSurfaces.get(surface));
	        self._rpc.signal(SIGNAL_TYPE.videoNewFrame, {
	            id,
	            width: self._width,
	            height: self._height,
	            buffer
	        }, [buffer]);
	    }
	    _bind(video) {
	        return __awaiter(this, void 0, void 0, function* () {
	            if (this._active) {
	                return;
	            }
	            this._width = video.getWidth();
	            this._height = video.getHeight();
	            this._video = video;
	            this._surfacePool = new Pool(() => ArrayBufferSurface.createFromArrayBuffer(this._width, this._height, new ArrayBuffer(4 * this._width * this._height)));
	            this._managedSurfacesById = new Map();
	            this._managedSurfaces = new WeakMap();
	            this._ids = new WeakMap();
	            this._video.setSurfaceFactory(() => {
	                const managedSurface = this._surfacePool.get(), surface = managedSurface.get();
	                const isNewSurface = !this._ids.has(managedSurface);
	                if (isNewSurface) {
	                    const id = this._nextId++;
	                    this._ids.set(managedSurface, id);
	                    this._managedSurfacesById.set(id, managedSurface);
	                    this._managedSurfaces.set(surface, managedSurface);
	                    surface.fill(0xff000000);
	                }
	                return managedSurface.get();
	            });
	            this._video.newFrame.addHandler(VideoDriver._onNewFrame, this);
	            this._active = true;
	        });
	    }
	    _unbind() {
	        return __awaiter(this, void 0, void 0, function* () {
	            if (!this._active) {
	                return;
	            }
	            this._active = false;
	            this._video.setSurfaceFactory(null);
	            this._video.newFrame.removeHandler(VideoDriver._onNewFrame, this);
	            this._video = null;
	            this._surfacePool = null;
	            this._managedSurfacesById = null;
	            this._ids = null;
	        });
	    }
	    _onReturnSurfaceFromHost(message) {
	        if (!this._active) {
	            console.warn('surface returned from host to inactive driver');
	            return;
	        }
	        const surface = this._managedSurfacesById.get(message.id);
	        if (!surface) {
	            console.warn(`invalid member ID ${message.id}`);
	            return;
	        }
	        surface.get().replaceUnderlyingBuffer(this._width, this._height, message.buffer);
	        surface.release();
	    }
	    _onGetVideoParameters() {
	        return {
	            width: this._width,
	            height: this._height
	        };
	    }
	}

	class ControlDriver {
	    constructor(_rpc) {
	        this._rpc = _rpc;
	        this._active = false;
	        this._emulationContext = null;
	    }
	    init() {
	        this._rpc.registerSignalHandler(SIGNAL_TYPE.controlStateUpdate, this._onControlStateUpdate.bind(this));
	    }
	    bind(emulationContext) {
	        if (this._active) {
	            return;
	        }
	        this._active = true;
	        this._emulationContext = emulationContext;
	    }
	    unbind() {
	        if (!this._active) {
	            return;
	        }
	        this._active = false;
	        this._emulationContext = null;
	    }
	    _onControlStateUpdate(controlState) {
	        if (!this._active) {
	            return;
	        }
	        for (let i = 0; i < 2; i++) {
	            this._applyJoystickState(controlState.joystickState[i], this._emulationContext.getJoystick(i));
	        }
	        for (let i = 0; i < 4; i++) {
	            this._applyPaddleState(controlState.paddleState[i], this._emulationContext.getPaddle(i));
	        }
	        this._applyControlPanelState(controlState.controlPanelState, this._emulationContext.getControlPanel());
	    }
	    _applyJoystickState(state, joystick) {
	        joystick.getUp().toggle(state.up);
	        joystick.getDown().toggle(state.down);
	        joystick.getLeft().toggle(state.left);
	        joystick.getRight().toggle(state.right);
	        joystick.getFire().toggle(state.fire);
	    }
	    _applyPaddleState(state, paddle) {
	        paddle.setValue(state.value);
	        paddle.getFire().toggle(state.fire);
	    }
	    _applyControlPanelState(state, panel) {
	        panel.getDifficultySwitchP0().toggle(state.difficulty0);
	        panel.getDifficultySwitchP1().toggle(state.difficulty1);
	        panel.getResetButton().toggle(state.reset);
	        panel.getColorSwitch().toggle(state.color);
	        panel.getSelectSwitch().toggle(state.select);
	    }
	}

	class WaveformAudioDriver {
	    constructor(_index, _rpc) {
	        this._index = _index;
	        this._rpc = _rpc;
	        this._audio = null;
	        this._rpc.registerRpcHandler(RPC_TYPE.getWaveformAudioParameters(this._index), this._onGetWaveformAudioParameters.bind(this));
	    }
	    bind(audio) {
	        if (this._audio) {
	            return;
	        }
	        this._audio = audio;
	        this._audio.bufferChanged.addHandler(WaveformAudioDriver._onBufferChanged, this);
	        this._audio.volumeChanged.addHandler(WaveformAudioDriver._onVolumeChanged, this);
	        this._audio.stop.addHandler(WaveformAudioDriver._onStop, this);
	    }
	    unbind() {
	        if (!this._audio) {
	            return;
	        }
	        this._audio.bufferChanged.removeHandler(WaveformAudioDriver._onBufferChanged, this);
	        this._audio.volumeChanged.removeHandler(WaveformAudioDriver._onVolumeChanged, this);
	        this._audio.stop.removeHandler(WaveformAudioDriver._onStop, this);
	        this._audio = null;
	    }
	    static _onBufferChanged(key, self) {
	        self._rpc.signal(SIGNAL_TYPE.waveformAudioBufferChange, {
	            index: self._index,
	            key
	        });
	    }
	    static _onVolumeChanged(value, self) {
	        self._rpc.signal(SIGNAL_TYPE.waveformAudioVolumeChange, {
	            index: self._index,
	            value
	        });
	    }
	    static _onStop(value, self) {
	        self._rpc.signal(SIGNAL_TYPE.audioStop, self._index);
	    }
	    _onGetWaveformAudioParameters() {
	        return { volume: this._audio.getVolume() };
	    }
	}

	class PCMAudioDriver {
	    constructor(index, _rpc) {
	        this._rpc = _rpc;
	        this._enabled = false;
	        this._sampleRate = 0;
	        this._frameSize = 0;
	        this._pendingFrames = new Map();
	        this._nextId = 0;
	        this._paused = false;
	        this._signalNewFrame = '';
	        this._signalTogglePause = '';
	        this._rpc
	            .registerRpcHandler(RPC_TYPE.getPCMAudioParameters(index), this._onGetPCMAudioParameters.bind(this))
	            .registerSignalHandler(SIGNAL_TYPE.pcmAudioReturnFrame(index), this._onReturnFrame.bind(this));
	        this._signalNewFrame = SIGNAL_TYPE.pcmAudioNewFrame(index);
	        this._signalTogglePause = SIGNAL_TYPE.pcmAudioTogglePause(index);
	    }
	    bind(endpoint) {
	        if (this._enabled) {
	            this.unbind();
	        }
	        this._endpoint = endpoint;
	        this._endpoint.newFrame.addHandler(PCMAudioDriver._onNewFrame, this);
	        this._endpoint.togglePause.addHandler(PCMAudioDriver._onTogglePause, this);
	        this._sampleRate = this._endpoint.getSampleRate();
	        this._frameSize = this._endpoint.getFrameSize();
	        this._enabled = true;
	    }
	    unbind() {
	        if (!this._enabled) {
	            return;
	        }
	        this._endpoint.newFrame.removeHandler(PCMAudioDriver._onNewFrame, this);
	        this._endpoint.togglePause.removeHandler(PCMAudioDriver._onTogglePause, this);
	        this._endpoint = null;
	        this._pendingFrames.clear();
	        this._sampleRate = this._frameSize = 0;
	        this._enabled = false;
	    }
	    static _onNewFrame(frame, self) {
	        if (!self._enabled) {
	            frame.dispose();
	            return;
	        }
	        const id = self._nextId++, data = frame.get();
	        self._pendingFrames.set(id, frame);
	        self._rpc.signal(self._signalNewFrame, {
	            id,
	            buffer: data.buffer
	        }, [data.buffer]);
	    }
	    static _onTogglePause(paused, self) {
	        self._paused = paused;
	        self._rpc.signal(self._signalTogglePause, {
	            paused
	        });
	    }
	    _onGetPCMAudioParameters() {
	        return {
	            sampleRate: this._sampleRate,
	            frameSize: this._frameSize,
	            paused: this._paused
	        };
	    }
	    _onReturnFrame(msg) {
	        if (!this._enabled || !this._pendingFrames.has(msg.id)) {
	            return;
	        }
	        const frame = this._pendingFrames.get(msg.id);
	        this._pendingFrames.delete(msg.id);
	        frame.adopt(new Float32Array(msg.buffer));
	        frame.release();
	    }
	}

	class AsyncIO$1 {
	    constructor() {
	        this.message = new lib_1();
	        this._io = null;
	    }
	    bind(io) {
	        if (this._io) {
	            return;
	        }
	        if (io) {
	            io.message.addHandler(AsyncIO$1._onAsyncIOMessage, this);
	        }
	        this._io = io;
	    }
	    unbind() {
	        if (!this._io) {
	            return;
	        }
	        this._io.message.removeHandler(AsyncIO$1._onAsyncIOMessage, this);
	        this._io = null;
	    }
	    send(message) {
	        if (this._io) {
	            this._io.send(message);
	        }
	    }
	    static _onAsyncIOMessage(message, self) {
	        self.message.dispatch(message);
	    }
	}

	class EmulationBackend {
	    constructor(_rpc) {
	        this._rpc = _rpc;
	        this._videoDriver = null;
	        this._service = new EmulationService();
	    }
	    startup() {
	        const driverManager = new DriverManager(), videoDriver = new VideoDriver(this._rpc), controlDriver = new ControlDriver(this._rpc), waveformAduioDrivers = [0, 1].map(i => new WaveformAudioDriver(i, this._rpc)), pcmAudioDriver = new PCMAudioDriver(0, this._rpc), asyncIODriver = new AsyncIO$1();
	        this._rpc
	            .registerRpcHandler(RPC_TYPE.setup, this._onSetup.bind(this))
	            .registerRpcHandler(RPC_TYPE.emulationFetchLastError, this._onFetchLastError.bind(this))
	            .registerRpcHandler(RPC_TYPE.emulationPause, this._onEmulationPause.bind(this))
	            .registerRpcHandler(RPC_TYPE.emulationReset, this._onEmulationReset.bind(this))
	            .registerRpcHandler(RPC_TYPE.emulationResume, this._onEmulationResume.bind(this))
	            .registerRpcHandler(RPC_TYPE.emulationSetRateLimit, this._onEmulationSetRateLimit.bind(this))
	            .registerRpcHandler(RPC_TYPE.emulationStart, this._onEmulationStart.bind(this))
	            .registerRpcHandler(RPC_TYPE.emulationStop, this._onEmulationStop.bind(this))
	            .registerSignalHandler(SIGNAL_TYPE.messageToAsyncIO, data => asyncIODriver.send(data));
	        asyncIODriver.message.addHandler(message => this._rpc.signal(SIGNAL_TYPE.messageFromAsyncIO, message));
	        this._service.frequencyUpdate.addHandler(EmulationBackend._onFrequencyUpdate, this);
	        this._service.emulationError.addHandler(EmulationBackend._onEmulationError, this);
	        this._videoDriver = videoDriver;
	        videoDriver.init();
	        controlDriver.init();
	        driverManager
	            .addDriver(videoDriver, (context, driver) => driver.bind(context.getRawVideo()))
	            .addDriver(controlDriver, (context, driver) => driver.bind(context))
	            .addDriver(pcmAudioDriver, (context, driver) => driver.bind(context.getPCMChannel()))
	            .addDriver(asyncIODriver, (context, driver) => driver.bind(context.getAsyncIO()))
	            .bind(this._service);
	        for (let i = 0; i < 2; i++) {
	            driverManager.addDriver(waveformAduioDrivers[i], (context, driver) => driver.bind(context.getWaveformChannels()[i]));
	        }
	    }
	    static _onFrequencyUpdate(frequency, self) {
	        self._rpc.signal(SIGNAL_TYPE.emulationFrequencyUpdate, frequency);
	    }
	    static _onEmulationError(error, self) {
	        self._rpc.signal(SIGNAL_TYPE.emulationError, error ? error.message : null);
	    }
	    _onSetup(msg) {
	        this._videoDriver.init();
	    }
	    _onFetchLastError() {
	        const lastError = this._service.getLastError();
	        return lastError ? lastError.message : null;
	    }
	    _onEmulationPause() {
	        return this._service.pause();
	    }
	    _onEmulationReset() {
	        return this._service.reset();
	    }
	    _onEmulationResume() {
	        return this._service.resume();
	    }
	    _onEmulationStart(message) {
	        return this._service.start(message.buffer, message.config, message.cartridgeType);
	    }
	    _onEmulationStop() {
	        return this._service.stop();
	    }
	    _onEmulationSetRateLimit(message) {
	        return this._service.setRateLimit(message);
	    }
	}

	const emulationBackend = new EmulationBackend(getRpc());
	emulationBackend.startup();

}());
//# sourceMappingURL=stellerator.min.js.map
